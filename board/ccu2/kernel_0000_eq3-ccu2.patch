diff -Naur linux-3.4.11/arch/arm/boot/.gitignore linux-HEAD/arch/arm/boot/.gitignore
--- linux-3.4.11/arch/arm/boot/.gitignore	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/boot/.gitignore	2015-11-18 09:04:24.000000000 +0000
@@ -1,6 +1,8 @@
 Image
+uImage
 zImage
 xipImage
 bootpImage
 uImage
+ceImage
 *.dtb
diff -Naur linux-3.4.11/arch/arm/boot/Makefile linux-HEAD/arch/arm/boot/Makefile
--- linux-3.4.11/arch/arm/boot/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/boot/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -25,7 +25,7 @@
 
 export ZRELADDR INITRD_PHYS PARAMS_PHYS
 
-targets := Image zImage xipImage bootpImage uImage
+targets := Image zImage xipImage bootpImage uImage ceImage
 
 ifeq ($(CONFIG_XIP_KERNEL),y)
 
@@ -98,6 +98,10 @@
 	$(call if_changed,objcopy)
 	@echo '  Kernel: $@ is ready'
 
+$(obj)/ceImage: $(obj)/zImage FORCE
+	$(call if_changed,ceimage)
+	@echo '  CE-Image $@ is ready'
+
 PHONY += initrd FORCE
 initrd:
 	@test "$(INITRD_PHYS)" != "" || \
diff -Naur linux-3.4.11/arch/arm/configs/eq3_ccu2_defconfig linux-HEAD/arch/arm/configs/eq3_ccu2_defconfig
--- linux-3.4.11/arch/arm/configs/eq3_ccu2_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/configs/eq3_ccu2_defconfig	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,2066 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.4.11 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_DANGEROUS=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=".ccu2"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="ccu2"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_FHANDLE=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+CONFIG_AUDIT_LOGINUID_IMMUTABLE=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_CHIP=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_RCU_BOOST=y
+CONFIG_RCU_BOOST_PRIO=1
+CONFIG_RCU_BOOST_DELAY=500
+CONFIG_IKCONFIG=m
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+# CONFIG_CPUSETS is not set
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_MEM_RES_CTLR=y
+CONFIG_CGROUP_MEM_RES_CTLR_KMEM=y
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_CGROUP=m
+# CONFIG_DEBUG_BLK_CGROUP is not set
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+CONFIG_MM_OWNER=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+# CONFIG_UID16 is not set
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_LDM_PARTITION=y
+# CONFIG_LDM_DEBUG is not set
+CONFIG_SGI_PARTITION=y
+# CONFIG_ULTRIX_PARTITION is not set
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=m
+CONFIG_IOSCHED_CFQ=m
+CONFIG_CFQ_GROUP_IOSCHED=y
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+CONFIG_ARCH_MXS=y
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PXA168 is not set
+# CONFIG_ARCH_PXA910 is not set
+# CONFIG_ARCH_MMP2 is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+CONFIG_MXS_HAVE_AMBA_DUART=y
+CONFIG_MXS_HAVE_PLATFORM_AUART=y
+CONFIG_MXS_HAVE_PLATFORM_FEC=y
+CONFIG_MXS_HAVE_PLATFORM_GPMI_NAND=y
+CONFIG_MXS_HAVE_PLATFORM_MXS_I2C=y
+CONFIG_MXS_HAVE_PLATFORM_MXS_MMC=y
+CONFIG_MXS_OCOTP=y
+CONFIG_SOC_IMX28=y
+
+#
+# MXS platforms:
+#
+# CONFIG_MACH_STMP378X_DEVB is not set
+# CONFIG_MACH_MX23EVK is not set
+# CONFIG_MACH_MX28EVK is not set
+# CONFIG_MACH_TX28 is not set
+# CONFIG_MACH_M28EVK is not set
+# CONFIG_MACH_APX4DEVKIT is not set
+CONFIG_MACH_EQ3_CCU2=y
+CONFIG_USB_WORKAROUND_MX28=y
+CONFIG_MACH_EQ3_CCU2_DEFAULT=y
+CONFIG_SPI_EQ3SPI=m
+CONFIG_PLAT_EQ3_IC200_DEVICE=m
+# CONFIG_PLAT_EQ3_RESCUE_MODE is not set
+
+#
+# System MMU
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_NR_BANKS=8
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_CLEANCACHE=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=m
+CONFIG_BINFMT_MISC=m
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+# CONFIG_PM_TEST_SUSPEND is not set
+CONFIG_CAN_PM_TRACE=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=m
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_ROUTE_CLASSID=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+CONFIG_ARPD=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=m
+CONFIG_INET_DIAG=m
+CONFIG_INET_TCP_DIAG=m
+CONFIG_INET_UDP_DIAG=m
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_BIC=m
+CONFIG_TCP_CONG_CUBIC=m
+CONFIG_TCP_CONG_WESTWOOD=m
+CONFIG_TCP_CONG_HTCP=m
+CONFIG_TCP_CONG_HSTCP=m
+CONFIG_TCP_CONG_HYBLA=m
+CONFIG_TCP_CONG_VEGAS=m
+CONFIG_TCP_CONG_SCALABLE=m
+CONFIG_TCP_CONG_LP=m
+CONFIG_TCP_CONG_VENO=m
+CONFIG_TCP_CONG_YEAH=m
+CONFIG_TCP_CONG_ILLINOIS=m
+CONFIG_DEFAULT_RENO=y
+CONFIG_DEFAULT_TCP_CONG="reno"
+CONFIG_TCP_MD5SIG=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_ACCT=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NETFILTER_TPROXY is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=m
+
+#
+# Xtables targets
+#
+CONFIG_NETFILTER_XT_TARGET_AUDIT=m
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HL=m
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=m
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_RATEEST=m
+CONFIG_NETFILTER_XT_TARGET_TEE=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CPU=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_DEVGROUP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ECN=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HL=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_NFACCT=m
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_RPFILTER=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=m
+CONFIG_NET_SCTPPROBE=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+CONFIG_SCTP_HMAC_SHA1=y
+# CONFIG_SCTP_HMAC_MD5 is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+CONFIG_HAVE_BPF_JIT=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_FIRMWARE_IN_KERNEL is not set
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+CONFIG_CONNECTOR=m
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_DOCG4 is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_GPMI_NAND=y
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=m
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+CONFIG_BLK_DEV_CRYPTOLOOP=m
+# CONFIG_BLK_DEV_DRBD is not set
+CONFIG_BLK_DEV_NBD=m
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=m
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085 is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+CONFIG_EEPROM_93CX6=m
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=m
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=m
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=m
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+CONFIG_NETCONSOLE=m
+CONFIG_NETCONSOLE_DYNAMIC=y
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+CONFIG_TUN=m
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_FEC=y
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+CONFIG_SMSC_PHY=y
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=m
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=m
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=m
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_MXS_RAW_AUART=m
+CONFIG_MXS_RAW_AUART_PORT0=y
+# CONFIG_MXS_RAW_AUART_PORT1 is not set
+CONFIG_EQ3_CHAR_LOOPBACK=m
+
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+CONFIG_SERIAL_MXS_AUART=y
+CONFIG_SERIAL_MXS_AUART_CONSOLE=y
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_LEVELED_GPIO is not set
+CONFIG_RAW_DRIVER=m
+CONFIG_MAX_RAW_DEVS=256
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=m
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_MXS=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=m
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_PXA2XX_MMP is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=m
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+CONFIG_GPIO_MXS=y
+# CONFIG_GPIO_PL061 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_GPIO_WATCHDOG is not set
+# CONFIG_ARM_SP805_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_RC5T583 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+CONFIG_REGULATOR_USERSPACE_CONSUMER=m
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_EXYNOS_VIDEO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_DWC3 is not set
+CONFIG_USB_MON=m
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_MXS=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+CONFIG_USB_FSL_USB2=m
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+CONFIG_USB_G_MULTI=m
+CONFIG_USB_G_MULTI_RNDIS=y
+# CONFIG_USB_G_MULTI_CDC is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=m
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=m
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+CONFIG_MMC_MXS=m
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_RENESAS_TPU is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_OT200 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGER_TIMER=y
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+CONFIG_LEDS_TRIGGER_GPIO=m
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+CONFIG_RTC_DRV_RS5C372=y
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+CONFIG_RTC_DRV_STMP=y
+CONFIG_RTC_DRV_STMP_WATCHDOG=y
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+# CONFIG_AMBA_PL08X is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_TIMB_DMA is not set
+# CONFIG_PL330_DMA is not set
+CONFIG_MXS_DMA=y
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=m
+# CONFIG_UIO_PDRV is not set
+# CONFIG_UIO_PDRV_GENIRQ is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKSRC_MMIO=y
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers (EXPERIMENTAL)
+#
+
+#
+# Rpmsg drivers (EXPERIMENTAL)
+#
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_POWERSAVE=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+
+#
+# DEVFREQ Drivers
+#
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_XATTR=y
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_NFS_FAKE_UID=y
+CONFIG_NFS_FAKE_UID_NUMBER=505
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=m
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=m
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHED_DEBUG=y
+CONFIG_SCHEDSTATS=y
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_RING_BUFFER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_LL is not set
+# CONFIG_OC_ETM is not set
+# CONFIG_ARM_KPROBES_TEST is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=m
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=m
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=m
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=m
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=m
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=m
+# CONFIG_CRC8 is not set
+CONFIG_AUDIT_GENERIC=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
diff -Naur linux-3.4.11/arch/arm/configs/eq3_ccu2-rescue_defconfig linux-HEAD/arch/arm/configs/eq3_ccu2-rescue_defconfig
--- linux-3.4.11/arch/arm/configs/eq3_ccu2-rescue_defconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/configs/eq3_ccu2-rescue_defconfig	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,2067 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.4.11 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_HAVE_PWM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=".ccu2-rescue"
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="ccu2-rescue"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_FHANDLE=y
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_CHIP=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_RCU_BOOST=y
+CONFIG_RCU_BOOST_PRIO=1
+CONFIG_RCU_BOOST_DELAY=500
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE="/home/markus/projects/ccu2/trunk/Product/CCU2Rescue/work/buildroot-2012.08/output/images/rootfs.cpio"
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+# CONFIG_INITRAMFS_COMPRESSION_NONE is not set
+CONFIG_INITRAMFS_COMPRESSION_GZIP=y
+# CONFIG_INITRAMFS_COMPRESSION_BZIP2 is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZMA is not set
+# CONFIG_INITRAMFS_COMPRESSION_XZ is not set
+# CONFIG_INITRAMFS_COMPRESSION_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_JUMP_LABEL=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBDAF is not set
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+CONFIG_ARCH_MXS=y
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PXA168 is not set
+# CONFIG_ARCH_PXA910 is not set
+# CONFIG_ARCH_MMP2 is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PICOXCELL is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+CONFIG_MXS_HAVE_AMBA_DUART=y
+CONFIG_MXS_HAVE_PLATFORM_AUART=y
+CONFIG_MXS_HAVE_PLATFORM_FEC=y
+CONFIG_MXS_HAVE_PLATFORM_GPMI_NAND=y
+CONFIG_MXS_HAVE_PLATFORM_MXS_I2C=y
+CONFIG_MXS_HAVE_PLATFORM_MXS_MMC=y
+CONFIG_MXS_OCOTP=y
+CONFIG_SOC_IMX28=y
+
+#
+# MXS platforms:
+#
+# CONFIG_MACH_STMP378X_DEVB is not set
+# CONFIG_MACH_MX23EVK is not set
+# CONFIG_MACH_MX28EVK is not set
+# CONFIG_MACH_TX28 is not set
+# CONFIG_MACH_M28EVK is not set
+# CONFIG_MACH_APX4DEVKIT is not set
+CONFIG_MACH_EQ3_CCU2=y
+CONFIG_USB_WORKAROUND_MX28=y
+CONFIG_MACH_EQ3_CCU2_DEFAULT=y
+CONFIG_SPI_EQ3SPI=y
+CONFIG_PLAT_EQ3_IC200_DEVICE=y
+CONFIG_PLAT_EQ3_RESCUE_MODE=y
+
+#
+# System MMU
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_NR_BANKS=8
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_CLEANCACHE=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_CC_STACKPROTECTOR=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE="console=ttyAMA0,115200 ubi.mtd=7 ubi.mtd=6 mtdparts=gpmi-nand:1024k(fcb),1024k(bbt),1024k(bootenv),1536k(bootstream0),6M(bootstream1),4M(kernel),48M(user),-(root)"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+# CONFIG_SUSPEND is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ARM_CPU_SUSPEND is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_BIC=y
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_TCP_CONG_WESTWOOD=y
+CONFIG_TCP_CONG_HTCP=y
+CONFIG_TCP_CONG_HSTCP=y
+CONFIG_TCP_CONG_HYBLA=y
+CONFIG_TCP_CONG_VEGAS=y
+CONFIG_TCP_CONG_SCALABLE=y
+CONFIG_TCP_CONG_LP=y
+CONFIG_TCP_CONG_VENO=y
+CONFIG_TCP_CONG_YEAH=y
+CONFIG_TCP_CONG_ILLINOIS=y
+# CONFIG_DEFAULT_BIC is not set
+# CONFIG_DEFAULT_CUBIC is not set
+# CONFIG_DEFAULT_HTCP is not set
+# CONFIG_DEFAULT_HYBLA is not set
+# CONFIG_DEFAULT_VEGAS is not set
+# CONFIG_DEFAULT_VENO is not set
+# CONFIG_DEFAULT_WESTWOOD is not set
+CONFIG_DEFAULT_RENO=y
+CONFIG_DEFAULT_TCP_CONG="reno"
+CONFIG_TCP_MD5SIG=y
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+CONFIG_BQL=y
+CONFIG_HAVE_BPF_JIT=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+# CONFIG_DMA_SHARED_BUFFER is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_DOCG4 is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_GPMI_NAND=y
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+# CONFIG_BLK_DEV_DRBD is not set
+CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085 is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+CONFIG_EEPROM_93CX6=y
+# CONFIG_EEPROM_93XX46 is not set
+CONFIG_IWMC3200TOP=y
+# CONFIG_IWMC3200TOP_DEBUG is not set
+# CONFIG_IWMC3200TOP_DEBUGFS is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_MII=y
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+CONFIG_NETCONSOLE=y
+CONFIG_NETCONSOLE_DYNAMIC=y
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_ETHERNET=y
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_FEC=y
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+CONFIG_SMSC_PHY=y
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+CONFIG_SERIAL_AMBA_PL011=y
+CONFIG_SERIAL_AMBA_PL011_CONSOLE=y
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+CONFIG_SERIAL_MXS_AUART=y
+CONFIG_SERIAL_MXS_AUART_CONSOLE=y
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_LEVELED_GPIO is not set
+CONFIG_RAW_DRIVER=y
+CONFIG_MAX_RAW_DEVS=256
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_MXS=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_PXA2XX_MMP is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+CONFIG_GPIO_MXS=y
+# CONFIG_GPIO_PL061 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_ADC121 is not set
+# CONFIG_SENSORS_ADS782X is not set
+# CONFIG_SENSORS_AD7814 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_GPIO_WATCHDOG is not set
+# CONFIG_ARM_SP805_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_RC5T583 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+# CONFIG_REGULATOR_DUMMY is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+CONFIG_REGULATOR_USERSPACE_CONSUMER=y
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_EXYNOS_VIDEO is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HIDRAW=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+CONFIG_HID_KYE=y
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+CONFIG_HID_KENSINGTON=y
+# CONFIG_HID_LCPOWER is not set
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+# CONFIG_USB_ARCH_HAS_XHCI is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+CONFIG_USB_DYNAMIC_MINORS=y
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_MXS=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=y
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+CONFIG_USB_STORAGE_REALTEK=y
+CONFIG_REALTEK_AUTOPM=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_ISD200=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_USB_STORAGE_ONETOUCH=y
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_USB_STORAGE_CYPRESS_ATACB=y
+CONFIG_USB_STORAGE_ENE_UB6250=y
+CONFIG_USB_UAS=y
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_GADGET=m
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_GADGET_DEBUG_FS=y
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+CONFIG_USB_FSL_USB2=m
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+CONFIG_USB_G_MULTI=m
+CONFIG_USB_G_MULTI_RNDIS=y
+# CONFIG_USB_G_MULTI_CDC is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+CONFIG_USB_GPIO_VBUS=y
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+CONFIG_MMC_MXS=y
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_RENESAS_TPU is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_OT200 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+CONFIG_RTC_DRV_RS5C372=y
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+CONFIG_RTC_DRV_STMP=y
+CONFIG_RTC_DRV_STMP_WATCHDOG=y
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+# CONFIG_AMBA_PL08X is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_TIMB_DMA is not set
+# CONFIG_PL330_DMA is not set
+CONFIG_MXS_DMA=y
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=y
+# CONFIG_UIO_PDRV is not set
+# CONFIG_UIO_PDRV_GENIRQ is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+CONFIG_STAGING=y
+# CONFIG_USBIP_CORE is not set
+# CONFIG_ECHO is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_RTS5139 is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_IIO is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_PHONE is not set
+# CONFIG_RAMSTER is not set
+# CONFIG_USB_WPAN_HCD is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKSRC_MMIO=y
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers (EXPERIMENTAL)
+#
+
+#
+# Rpmsg drivers (EXPERIMENTAL)
+#
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_POWERSAVE=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+
+#
+# DEVFREQ Drivers
+#
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="ascii"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_RW is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_XATTR=y
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=y
+CONFIG_NLS_CODEPAGE_775=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_CODEPAGE_852=y
+CONFIG_NLS_CODEPAGE_855=y
+CONFIG_NLS_CODEPAGE_857=y
+CONFIG_NLS_CODEPAGE_860=y
+CONFIG_NLS_CODEPAGE_861=y
+CONFIG_NLS_CODEPAGE_862=y
+CONFIG_NLS_CODEPAGE_863=y
+CONFIG_NLS_CODEPAGE_864=y
+CONFIG_NLS_CODEPAGE_865=y
+CONFIG_NLS_CODEPAGE_866=y
+CONFIG_NLS_CODEPAGE_869=y
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=y
+CONFIG_NLS_CODEPAGE_874=y
+CONFIG_NLS_ISO8859_8=y
+CONFIG_NLS_CODEPAGE_1250=y
+CONFIG_NLS_CODEPAGE_1251=y
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_ISO8859_3=y
+CONFIG_NLS_ISO8859_4=y
+CONFIG_NLS_ISO8859_5=y
+CONFIG_NLS_ISO8859_6=y
+CONFIG_NLS_ISO8859_7=y
+CONFIG_NLS_ISO8859_9=y
+CONFIG_NLS_ISO8859_13=y
+CONFIG_NLS_ISO8859_14=y
+CONFIG_NLS_ISO8859_15=y
+CONFIG_NLS_KOI8_R=y
+CONFIG_NLS_KOI8_U=y
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_STRIP_ASM_SYMS=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_LKDTM is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_TEST_KSTRTOX is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
diff -Naur linux-3.4.11/arch/arm/include/asm/atomic.h linux-HEAD/arch/arm/include/asm/atomic.h
--- linux-3.4.11/arch/arm/include/asm/atomic.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/include/asm/atomic.h	2015-11-18 09:04:24.000000000 +0000
@@ -208,6 +208,15 @@
 
 #endif /* __LINUX_ARM_ARCH__ */
 
+static inline void atomic_set_mask(unsigned long mask, unsigned long *addr)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	*addr |= mask;
+	local_irq_restore(flags);
+}
+
 #define atomic_xchg(v, new) (xchg(&((v)->counter), new))
 
 static inline int __atomic_add_unless(atomic_t *v, int a, int u)
diff -Naur linux-3.4.11/arch/arm/include/asm/mach/udc_pxa2xx.h linux-HEAD/arch/arm/include/asm/mach/udc_pxa2xx.h
--- linux-3.4.11/arch/arm/include/asm/mach/udc_pxa2xx.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/include/asm/mach/udc_pxa2xx.h	2015-11-18 09:04:24.000000000 +0000
@@ -14,6 +14,9 @@
         void (*udc_command)(int cmd);
 #define	PXA2XX_UDC_CMD_CONNECT		0	/* let host see us */
 #define	PXA2XX_UDC_CMD_DISCONNECT	1	/* so host won't see us */
+#define	PXA2XX_UDC_CMD_CONNECT_LATE	2	/* like PXA2XX_UDC_CMD_CONNECT
+						 * but called when udc has
+						 * been enabled */
 
 	/* Boards following the design guidelines in the developer's manual,
 	 * with on-chip GPIOs not Lubbock's weird hardware, can have a sane
diff -Naur linux-3.4.11/arch/arm/Kconfig linux-HEAD/arch/arm/Kconfig
--- linux-3.4.11/arch/arm/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -625,19 +625,30 @@
 	  Orion-1 (5181), Orion-VoIP (5181L), Orion-NAS (5182),
 	  Orion-2 (5281), Orion-1-90 (6183).
 
-config ARCH_MMP
-	bool "Marvell PXA168/910/MMP2"
+config ARCH_PXA168
+	bool "Marvell PXA168"
+	select ARCH_MMP
+	select CPU_PXA168
+	help
+	  Support for Marvell PXA168 processor line.
+
+config ARCH_PXA910
+	bool "Marvell PXA910"
 	depends on MMU
-	select ARCH_REQUIRE_GPIOLIB
-	select CLKDEV_LOOKUP
-	select GENERIC_CLOCKEVENTS
+	select ARCH_MMP
+	select CPU_PXA910
 	select GPIO_PXA
-	select TICK_ONESHOT
-	select PLAT_PXA
-	select SPARSE_IRQ
 	select GENERIC_ALLOCATOR
 	help
-	  Support for Marvell's PXA168/PXA910(MMP) and MMP2 processor line.
+	  Support for Marvell PXA910 processor line.
+
+config ARCH_MMP2
+	bool "Marvell MMP2"
+	depends on MMU
+	select ARCH_MMP
+	select CPU_MMP2
+	help
+	  Support for Marvell MMP2 processor line.
 
 config ARCH_KS8695
 	bool "Micrel/Kendin KS8695"
@@ -1080,6 +1091,16 @@
 source "arch/arm/mach-pxa/Kconfig"
 source "arch/arm/plat-pxa/Kconfig"
 
+config ARCH_MMP
+	bool
+	select ARCH_REQUIRE_GPIOLIB
+	select CLKDEV_LOOKUP
+	select GENERIC_CLOCKEVENTS
+	select HAVE_SCHED_CLOCK
+	select TICK_ONESHOT
+	select PLAT_PXA
+	select SPARSE_IRQ
+
 source "arch/arm/mach-mmp/Kconfig"
 
 source "arch/arm/mach-realview/Kconfig"
diff -Naur linux-3.4.11/arch/arm/lib/backtrace.S linux-HEAD/arch/arm/lib/backtrace.S
--- linux-3.4.11/arch/arm/lib/backtrace.S	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/lib/backtrace.S	2015-11-18 09:04:24.000000000 +0000
@@ -115,8 +115,9 @@
 #define instr r4
 #define reg   r5
 #define stack r6
+#define dummy r8			/* prevent misaligned stack */
 
-.Ldumpstm:	stmfd	sp!, {instr, reg, stack, r7, lr}
+.Ldumpstm:	stmfd	sp!, {instr, reg, stack, r7, dummy, lr}
 		mov	stack, r0
 		mov	instr, r1
 		mov	reg, #10
@@ -140,7 +141,7 @@
 		teq	r7, #0
 		adrne	r0, .Lcr
 		blne	printk
-		ldmfd	sp!, {instr, reg, stack, r7, pc}
+		ldmfd	sp!, {instr, reg, stack, r7, dummy, pc}
 
 .Lfp:		.asciz	"%cr%d:%08x"
 .Lcr:		.asciz	"\n"
diff -Naur linux-3.4.11/arch/arm/mach-mmp/clock.h linux-HEAD/arch/arm/mach-mmp/clock.h
--- linux-3.4.11/arch/arm/mach-mmp/clock.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/clock.h	2015-11-18 09:04:24.000000000 +0000
@@ -69,3 +69,9 @@
 
 extern struct clk clk_pxa168_gpio;
 extern struct clk clk_pxa168_timers;
+
+#ifdef CONFIG_ARCH_PXA168
+extern struct clk		clk_asys;
+extern struct clk		clk_sspx;
+extern struct clkops const	ssp_clk_ops;
+#endif
diff -Naur linux-3.4.11/arch/arm/mach-mmp/clock-pxa168.c linux-HEAD/arch/arm/mach-mmp/clock-pxa168.c
--- linux-3.4.11/arch/arm/mach-mmp/clock-pxa168.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/clock-pxa168.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,301 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/io.h>
+#include <mach/regs-apbc.h>
+
+#include "clock.h"
+
+static void mpmu_clk_enable(struct clk *clk)
+{
+	if (clk->fnclksel >= 0) {
+		uint32_t	acgr = __raw_readl(APB_VIRT_BASE + 
+						   0x50000 + 0x1024);
+
+		__raw_writel((1u << clk->fnclksel) | acgr,
+			     APB_VIRT_BASE + 0x50000 + 0x1024);
+	}
+}
+
+static void mpmu_clk_disable(struct clk *clk)
+{
+	if (clk->fnclksel >= 0) {
+		uint32_t	acgr = __raw_readl(APB_VIRT_BASE + 
+						   0x50000 + 0x1024);
+
+		__raw_writel(~(1u << clk->fnclksel) & acgr,
+			     APB_VIRT_BASE + 0x50000 + 0x1024);
+	}
+}
+
+static bool mpmu_clk_is_enabled(struct clk *clk)
+{
+	if (clk->fnclksel == 0) {
+		/* always enabled*/
+		return true;
+	} else {
+		uint32_t	acgr = __raw_readl(APB_VIRT_BASE + 
+						   0x50000 + 0x1024);
+		return (acgr & (1u << clk->fnclksel)) != 0;
+	}
+}
+
+#include <linux/rational.h>
+static int mpmu_clk_calc_numerators(unsigned long rate,
+				    unsigned long base_freq,
+				    unsigned long *num,
+				    unsigned long *den,
+				    char const *clock_name)
+{
+	uint64_t		f;
+
+	rational_best_approximation(base_freq, rate, 0x7fff, 0xfff,
+				    num, den);
+
+	if (*num == 0) {
+		printk(KERN_WARNING
+		       "%s: failed to calculate numerator for %lu/%lu\n",
+		       clock_name, base_freq, rate);
+		return -EINVAL;
+	}
+		
+	f  = base_freq;
+	f *= *den;
+	f  = div64_u64(f, *num);
+
+	if (f != rate) {
+		printk(KERN_WARNING
+		       "%s: failed to approximate rate %lu (%lu/%lu -> %lu)\n",
+		       clock_name, rate, *num, *den, (unsigned long)f);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static unsigned long mpmu_clk_calc_frequency(unsigned long base_freq,
+					     unsigned int reg,
+					     char const *clock_name)
+{
+	unsigned int	num = (reg >> 16) & 0x7fff;
+	unsigned int	den = (reg >>  0) & 0xfff;
+	uint64_t	f;
+
+	if (num == 0) {
+		printk(KERN_WARNING "%s: numerator is zero (%08x)\n",
+		       clock_name, reg);
+		return 0;
+	}
+
+	f = base_freq * den;
+	f = div64_u64(f, num);
+
+	if (f > ULONG_MAX) {
+		printk(KERN_WARNING
+		       "%s: resulting frequency too large (%08x)\n",
+		       clock_name, reg);
+		return ULONG_MAX;
+	}
+
+	return f;
+}
+
+/* ASYSCLK */
+
+static unsigned long const	MHz_312 = 312000000;
+static int asys_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long	num;
+	unsigned long	den;
+	int		rc;
+
+	rc = mpmu_clk_calc_numerators(rate, MHz_312, &num, &den, "ASYSCLK");
+	if (rc < 0)
+		return rc;
+		
+	__raw_writel((num << 16) | (den << 0), clk->clk_rst);
+	return 0;
+}
+
+static unsigned long asys_clk_getrate(struct clk *clk)
+{
+	if (!mpmu_clk_is_enabled(clk))
+		return 0;
+	else {
+		uint32_t	reg = __raw_readl(clk->clk_rst);
+		return mpmu_clk_calc_frequency(reg, MHz_312, "ASYSCLK");
+	}
+}
+
+static struct clkops const	asys_clk_ops = {
+	.enable		= mpmu_clk_enable,
+	.disable	= mpmu_clk_disable,
+	.setrate	= asys_clk_setrate,
+	.getrate	= asys_clk_getrate,
+};
+
+struct clk clk_asys = {
+	.clk_rst	=  (void __iomem *)(APB_VIRT_BASE + 0x50000 + 0x1050),
+	.fnclksel	=  19,
+	.enable_val	=  (1 << 16) | (1 << 0), /* 312 MHz */
+	.ops		=  &asys_clk_ops,
+};
+
+/* SSPx_CLK */
+
+static int sspx_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	unsigned long	num;
+	unsigned long	den;
+	int		rc;
+
+	/* can not use clk api here, since sspx + asys operations are locked
+	 * by the same spinlock (clocks_lock) */
+	unsigned long	base_freq = asys_clk_getrate(&clk_asys);
+
+	rc = mpmu_clk_calc_numerators(rate, base_freq, &num, &den, "SSPx_CLK");
+	if (rc < 0)
+		return rc;
+		
+	__raw_writel((num << 16) | (den << 0), clk->clk_rst);
+	return 0;
+}
+
+static unsigned long sspx_clk_getrate(struct clk *clk)
+{
+	uint32_t	reg = __raw_readl(clk->clk_rst);
+	/* can not use clk api here, since sspx + asys operations are locked
+	 * by the same spinlock (clocks_lock) */
+	unsigned long	base_freq = asys_clk_getrate(&clk_asys);
+
+	return mpmu_clk_calc_frequency(reg, base_freq, "SSPx_CLK");
+}
+
+static struct clkops const	sspx_clk_ops = {
+	.enable		= mpmu_clk_enable,
+	.disable	= mpmu_clk_disable,
+	.setrate	= sspx_clk_setrate,
+	.getrate	= sspx_clk_getrate,
+};
+
+static struct clk const	*clk_sspx_user;
+struct clk clk_sspx = {
+	.clk_rst	=  (void __iomem *)(APB_VIRT_BASE + 0x50000 + 0x1054),
+	.fnclksel	=  -1,
+	.enable_val	=  (32 << 16) | (1 << 0), /* 9.75 MHz */
+	.ops		=  &sspx_clk_ops,
+};
+
+/* SSP_CLK */
+
+static void ssp_clk_enable(struct clk *clk)
+{
+	uint32_t clk_rst;
+
+	clk_rst = APBC_APBCLK | APBC_FNCLK | APBC_FNCLKSEL(clk->fnclksel);
+	__raw_writel(clk_rst, clk->clk_rst);
+}
+
+static void ssp_clk_disable(struct clk *clk)
+{
+	__raw_writel(0, clk->clk_rst);
+}
+
+static unsigned long ssp_clk_getrate(struct clk *clk)
+{
+	uint32_t	reg = __raw_readl(clk->clk_rst);
+
+	switch ((reg >> 4) & 0x7) {
+	case 0:	return   6500000;
+	case 1: return  13000000;
+	case 2: return  26000000;
+	case 3: return  52000000;
+	case 4: return sspx_clk_getrate(&clk_sspx);
+	case 5: return   1000000;
+	case 6: return    500000;
+	default:
+		printk(KERN_WARNING "%s: unexpected register value %08x\n",
+		       __func__, reg);
+		return 0;
+	}
+}
+
+inline static bool ssp_clk_allow_variable_rate(void)
+{
+#ifdef CONFIG_PXA168_VARIABLE_SSP_RATE
+	return true;
+#else
+	return false;
+#endif
+}
+
+static int ssp_clk_setrate(struct clk *clk, unsigned long rate)
+{
+	int		used_asysclk = clk->fnclksel == 4;
+	int		rc = 0;
+	uint32_t	 clk_rst;
+
+	WARN_ON(used_asysclk && clk_sspx_user != clk);
+
+	switch (rate) {
+	case   500000:	clk->fnclksel = 6; break;
+	case  1000000:	clk->fnclksel = 5; break;
+	case  6500000:	clk->fnclksel = 0; break;
+	case 13000000:	clk->fnclksel = 1; break;
+	case 26000000:	clk->fnclksel = 2; break;
+	case 52000000:	clk->fnclksel = 3; break;
+	case        0:
+		printk(KERN_WARNING "%s: unsupported rate %lu\n", __func__,
+		       rate);
+		return -EINVAL;
+		break;
+	default:
+		if (clk_sspx_user && clk_sspx_user != clk) {
+			printk(KERN_WARNING "%s: parent clock already used\n",
+			       __func__);
+			rc = -EBUSY;
+		} else if (!ssp_clk_allow_variable_rate()) {
+			printk(KERN_WARNING "%s: unsupported rate %lu\n",
+			       __func__, rate);
+			rc = -EINVAL;
+		} else
+			/* can not use clk api here, since sspx_clk + ssp_clk
+			 * operations are locked by the same spinlock (clocks_lock) */
+			rc = sspx_clk_setrate(&clk_sspx, rate);
+
+		if (rc < 0)
+			return rc;
+
+		clk_sspx_user = clk;
+		clk->fnclksel = 4;
+		break;
+	}
+
+	clk_rst = APBC_APBCLK | APBC_FNCLK | APBC_FNCLKSEL(clk->fnclksel);
+	__raw_writel(clk_rst, clk->clk_rst);
+
+	if (used_asysclk && clk->fnclksel != 4)
+		clk_sspx_user = NULL;
+
+	return 0;
+}
+
+struct clkops const		ssp_clk_ops = {
+	.enable		=  ssp_clk_enable,
+	.disable	=  ssp_clk_disable,
+	.setrate	=  ssp_clk_setrate,
+	.getrate	=  ssp_clk_getrate,
+};
diff -Naur linux-3.4.11/arch/arm/mach-mmp/devices.c linux-HEAD/arch/arm/mach-mmp/devices.c
--- linux-3.4.11/arch/arm/mach-mmp/devices.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/devices.c	2015-11-18 09:04:24.000000000 +0000
@@ -14,7 +14,7 @@
 #include <mach/devices.h>
 
 int __init pxa_register_device(struct pxa_device_desc *desc,
-				void *data, size_t size)
+				void const *data, size_t size)
 {
 	struct platform_device *pdev;
 	struct resource res[2 + MAX_RESOURCE_DMA];
diff -Naur linux-3.4.11/arch/arm/mach-mmp/include/mach/devices.h linux-HEAD/arch/arm/mach-mmp/include/mach/devices.h
--- linux-3.4.11/arch/arm/mach-mmp/include/mach/devices.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/include/mach/devices.h	2015-11-18 09:04:24.000000000 +0000
@@ -49,5 +49,5 @@
 	.dma		= { _dma },					\
 }
 
-extern int pxa_register_device(struct pxa_device_desc *, void *, size_t);
+extern int pxa_register_device(struct pxa_device_desc *, void const *, size_t);
 #endif /* __MACH_DEVICE_H */
diff -Naur linux-3.4.11/arch/arm/mach-mmp/include/mach/gpio.h linux-HEAD/arch/arm/mach-mmp/include/mach/gpio.h
--- linux-3.4.11/arch/arm/mach-mmp/include/mach/gpio.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/include/mach/gpio.h	2015-11-18 09:04:24.000000000 +0000
@@ -4,5 +4,14 @@
 #include <asm-generic/gpio.h>
 
 #include <mach/cputype.h>
+#include <mach/irqs.h>
 
+static inline int irq_to_gpio(int irq)
+{
+	if (irq >= MMP_GPIO_TO_IRQ(0) &&
+	    irq < MMP_GPIO_TO_IRQ(MMP_NR_BUILTIN_GPIO))
+		return MMP_IRQ_TO_GPIO(irq);
+	else
+		return -ENOSYS;
+}
 #endif /* __ASM_MACH_GPIO_H */
diff -Naur linux-3.4.11/arch/arm/mach-mmp/include/mach/irqs.h linux-HEAD/arch/arm/mach-mmp/include/mach/irqs.h
--- linux-3.4.11/arch/arm/mach-mmp/include/mach/irqs.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/include/mach/irqs.h	2015-11-18 09:04:24.000000000 +0000
@@ -221,6 +221,7 @@
 #define IRQ_GPIO_START			128
 #define MMP_NR_BUILTIN_GPIO		192
 #define MMP_GPIO_TO_IRQ(gpio)		(IRQ_GPIO_START + (gpio))
+#define MMP_IRQ_TO_GPIO(irq)		((irq) - IRQ_GPIO_START)
 
 #define IRQ_BOARD_START			(IRQ_GPIO_START + MMP_NR_BUILTIN_GPIO)
 #define MMP_NR_IRQS			IRQ_BOARD_START
diff -Naur linux-3.4.11/arch/arm/mach-mmp/include/mach/mfp-pxa168.h linux-HEAD/arch/arm/mach-mmp/include/mach/mfp-pxa168.h
--- linux-3.4.11/arch/arm/mach-mmp/include/mach/mfp-pxa168.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/include/mach/mfp-pxa168.h	2015-11-18 09:04:24.000000000 +0000
@@ -105,6 +105,7 @@
 #define GPIO84_GPIO		MFP_CFG(GPIO84, AF0)
 #define GPIO85_GPIO		MFP_CFG(GPIO85, AF0)
 #define GPIO86_GPIO		MFP_CFG(GPIO86, AF0)
+#define MFP_EXT_WKUP_GPIO	MFP_CFG(EXT_WKUP, AF6) /* GPIO86 */
 #define GPIO87_GPIO		MFP_CFG(GPIO87, AF0)
 #define GPIO88_GPIO		MFP_CFG(GPIO88, AF0)
 #define GPIO89_GPIO		MFP_CFG(GPIO89, AF0)
@@ -184,6 +185,7 @@
 #define GPIO23_SMC_nLUA		MFP_CFG(GPIO23, AF0)
 #define GPIO25_SMC_nLLA		MFP_CFG(GPIO25, AF0)
 #define GPIO27_SMC_IRQ		MFP_CFG(GPIO27, AF0)
+#define GPIO27_SMC_RDY		MFP_CFG(GPIO27, AF4)
 #define GPIO28_SMC_RDY		MFP_CFG(GPIO28, AF0)
 #define GPIO29_SMC_SCLK		MFP_CFG(GPIO29, AF0)
 #define GPIO34_SMC_nCS1		MFP_CFG(GPIO34, AF2)
@@ -207,8 +209,30 @@
 #define GPIO9_UART3_RXD		MFP_CFG(GPIO9, AF2)
 #define GPIO1O_UART3_CTS	MFP_CFG(GPIO10, AF2)
 #define GPIO11_UART3_RTS	MFP_CFG(GPIO11, AF2)
-#define GPIO88_UART2_TXD	MFP_CFG(GPIO88, AF2)
+#define GPIO12_UART3_DSR	MFP_CFG(GPIO12, AF2)
+#define GPIO13_UART3_DCD	MFP_CFG(GPIO13, AF2)
+#define GPIO30_UART3_TXD	MFP_CFG_DRV(GPIO30, AF2, FAST)
+#define GPIO31_UART3_RXD	MFP_CFG(GPIO31, AF2)
+#define GPIO32_UART3_CTS	MFP_CFG(GPIO32, AF2)
+#define GPIO33_UART3_RTS	MFP_CFG(GPIO33, AF2)
+#define GPIO86_UART2_CTS	MFP_CFG(GPIO86, AF2)
+#define GPIO87_UART2_RTS	MFP_CFG(GPIO87, AF2)
+#define GPIO88_UART2_TXD	MFP_CFG_DRV(GPIO88, AF2, FAST)
+#define GPIO88_UART2_RXD	MFP_CFG(GPIO88, AF3)
 #define GPIO89_UART2_RXD	MFP_CFG(GPIO89, AF2)
+#define GPIO89_UART2_TXD	MFP_CFG_DRV(GPIO89, AF3, FAST)
+#define GPIO98_UART3_TXD	MFP_CFG_DRV(GPIO98, AF2, FAST)
+#define GPIO98_UART3_RXD	MFP_CFG(GPIO98, AF3)
+#define GPIO99_UART3_RXD	MFP_CFG(GPIO99, AF2)
+#define GPIO99_UART3_TXD	MFP_CFG_DRV(GPIO99, AF3, FAST)
+#define GPIO100_UART3_CTS	MFP_CFG(GPIO100, AF2)
+#define GPIO100_UART3_RTS	MFP_CFG(GPIO100, AF3)
+#define GPIO101_UART3_RTS	MFP_CFG(GPIO101, AF2)
+#define GPIO101_UART3_CTS	MFP_CFG(GPIO101, AF3)
+#define GPIO102_UART3_DSR	MFP_CFG(GPIO102, AF2)
+#define GPIO103_UART3_DCD	MFP_CFG(GPIO103, AF2)
+#define GPIO104_UART1_DSR	MFP_CFG(GPIO104, AF2)
+#define GPIO105_UART1_DCD	MFP_CFG(GPIO105, AF2)
 #define GPIO107_UART1_TXD	MFP_CFG_DRV(GPIO107, AF1, FAST)
 #define GPIO107_UART1_RXD	MFP_CFG_DRV(GPIO107, AF2, FAST)
 #define GPIO108_UART1_RXD	MFP_CFG_DRV(GPIO108, AF1, FAST)
@@ -219,8 +243,14 @@
 #define GPIO110_UART1_CTS	MFP_CFG(GPIO110, AF2)
 #define GPIO111_UART1_RI	MFP_CFG(GPIO111, AF1)
 #define GPIO111_UART1_DSR	MFP_CFG(GPIO111, AF2)
-#define GPIO112_UART1_DTR	MFP_CFG(GPIO111, AF1)
+#define GPIO112_UART1_DTR	MFP_CFG(GPIO112, AF1)
 #define GPIO112_UART1_DCD	MFP_CFG(GPIO112, AF2)
+#define MFP_PRI_TDI_UART2_CTS	MFP_CFG(PRI_TDI, AF2)
+#define MFP_PRI_TMS_UART2_RTS	MFP_CFG(PRI_TMS, AF2)
+#define MFP_PRI_TCK_UART2_RXD	MFP_CFG_DRV(PRI_TCK, AF2, FAST)
+#define MFP_PRI_TCK_UART2_TXD	MFP_CFG_DRV(PRI_TCK, AF3, FAST)
+#define MFP_PRI_TDO_UART2_TXD	MFP_CFG_DRV(PRI_TDO, AF2, FAST)
+#define MFP_PRI_TDO_UART2_RXD	MFP_CFG_DRV(PRI_TDO, AF3, FAST)
 
 /* MMC1 */
 #define GPIO37_MMC1_DAT7	MFP_CFG(GPIO37, AF1)
@@ -233,10 +263,23 @@
 #define GPIO41_MMC1_DAT0	MFP_CFG(GPIO41, AF1)
 #define GPIO49_MMC1_CMD		MFP_CFG(GPIO49, AF1)
 #define GPIO43_MMC1_CLK		MFP_CFG(GPIO43, AF1)
+#define GPIO44_MMC1_CLK		MFP_CFG(GPIO44, AF1)
 #define GPIO53_MMC1_CD		MFP_CFG(GPIO53, AF1)
 #define GPIO46_MMC1_WP		MFP_CFG(GPIO46, AF1)
 
 /* MMC2 */
+#define GPIO8_MMC2_DAT7		MFP_CFG_DRV(GPIO8, AF1, FAST)
+#define GPIO8_MMC2_CMD		MFP_CFG_DRV(GPIO8, AF4, FAST)
+#define GPIO9_MMC2_DAT6		MFP_CFG_DRV(GPIO9, AF1, FAST)
+#define GPIO9_MMC2_CLK		MFP_CFG_DRV(GPIO9, AF4, FAST)
+#define GPIO10_MMC2_DAT5	MFP_CFG_DRV(GPIO10, AF1, FAST)
+#define GPIO11_MMC2_DAT4	MFP_CFG_DRV(GPIO11, AF1, FAST)
+#define GPIO12_MMC2_DAT3	MFP_CFG_DRV(GPIO12, AF1, FAST)
+#define GPIO13_MMC2_DAT2	MFP_CFG_DRV(GPIO13, AF1, FAST)
+#define GPIO14_MMC2_DAT1	MFP_CFG_DRV(GPIO14, AF1, FAST)
+#define GPIO15_MMC2_DAT0	MFP_CFG_DRV(GPIO15, AF1, FAST)
+#define GPIO21_MMC2_CLK		MFP_CFG_DRV(GPIO21, AF1, FAST)
+#define GPIO22_MMC2_CLK		MFP_CFG_DRV(GPIO22, AF1, FAST)
 #define	GPIO28_MMC2_CMD		MFP_CFG_DRV(GPIO28, AF6, FAST)
 #define	GPIO29_MMC2_CLK		MFP_CFG_DRV(GPIO29, AF6, FAST)
 #define	GPIO30_MMC2_DAT0	MFP_CFG_DRV(GPIO30, AF6, FAST)
@@ -244,6 +287,24 @@
 #define	GPIO32_MMC2_DAT2	MFP_CFG_DRV(GPIO32, AF6, FAST)
 #define	GPIO33_MMC2_DAT3	MFP_CFG_DRV(GPIO33, AF6, FAST)
 
+/* MMC3 */
+#define GPIO0_MMC3_DAT7		MFP_CFG(GPIO0, AF6)
+#define GPIO0_MMC3_CMD		MFP_CFG(GPIO0, AF4)
+#define GPIO1_MMC3_DAT6		MFP_CFG(GPIO1, AF6)
+#define GPIO1_MMC3_CLK		MFP_CFG(GPIO1, AF4)
+#define GPIO2_MMC3_DAT5		MFP_CFG(GPIO2, AF6)
+#define GPIO3_MMC3_DAT4		MFP_CFG(GPIO3, AF6)
+#define GPIO4_MMC3_DAT3		MFP_CFG(GPIO4, AF6)
+#define GPIO5_MMC3_DAT2		MFP_CFG(GPIO5, AF6)
+#define GPIO6_MMC3_DAT1		MFP_CFG(GPIO6, AF6)
+#define GPIO7_MMC3_DAT0		MFP_CFG(GPIO7, AF6)
+#define GPIO8_MMC3_CLK		MFP_CFG(GPIO8, AF6)
+#define GPIO9_MMC3_CMD		MFP_CFG(GPIO9, AF6)
+#define GPIO16_MMC3_CD		MFP_CFG(GPIO16, AF6)
+#define GPIO34_MMC3_CD		MFP_CFG(GPIO34, AF6)
+#define GPIO35_MMC3_CMD		MFP_CFG(GPIO35, AF6)
+#define GPIO36_MMC3_CLK		MFP_CFG(GPIO36, AF6)
+
 /* MMC4 */
 #define GPIO125_MMC4_DAT3       MFP_CFG_DRV(GPIO125, AF7, FAST)
 #define GPIO126_MMC4_DAT2       MFP_CFG_DRV(GPIO126, AF7, FAST)
@@ -252,6 +313,46 @@
 #define GPIO1_2_MMC4_CMD        MFP_CFG_DRV(GPIO1_2, AF7, FAST)
 #define GPIO2_2_MMC4_CLK        MFP_CFG_DRV(GPIO2_2, AF7, FAST)
 
+#define GPIO86_MMC2_DAT7	MFP_CFG_DRV(GPIO86, AF1, FAST)
+#define GPIO87_MMC2_DAT6	MFP_CFG_DRV(GPIO87, AF1, FAST)
+#define GPIO88_MMC2_DAT5	MFP_CFG_DRV(GPIO88, AF1, FAST)
+#define GPIO89_MMC2_DAT4	MFP_CFG_DRV(GPIO89, AF1, FAST)
+#define GPIO90_MMC2_DAT3	MFP_CFG_DRV(GPIO90, AF1, FAST)
+#define GPIO91_MMC2_DAT2	MFP_CFG_DRV(GPIO91, AF1, FAST)
+#define GPIO92_MMC2_DAT1	MFP_CFG_DRV(GPIO92, AF1, FAST)
+#define GPIO93_MMC2_DAT0	MFP_CFG_DRV(GPIO93, AF1, FAST)
+#define GPIO94_MMC2_CMD		MFP_CFG_DRV(GPIO94, AF1, FAST)
+#define GPIO95_MMC2_CLK		MFP_CFG_DRV(GPIO95, AF1, FAST)
+#define GPIO96_MMC2_CLK		MFP_CFG_DRV(GPIO96, AF3, FAST)
+#define GPIO106_MMC2_CLK	MFP_CFG_DRV(GPIO106, AF4, FAST)
+#define GPIO117_MMC2_CMD	MFP_CFG_DRV(GPIO117, AF4, FAST)
+#define GPIO118_MMC2_CMD	MFP_CFG_DRV(GPIO118, AF4, FAST)
+#define GPIO119_MMC2_DAT0	MFP_CFG_DRV(GPIO119, AF4, FAST)
+#define GPIO120_MMC2_DAT1	MFP_CFG_DRV(GPIO120, AF4, FAST)
+#define GPIO121_MMC2_DAT2	MFP_CFG_DRV(GPIO121, AF4, FAST)
+#define GPIO122_MMC2_DAT3	MFP_CFG_DRV(GPIO122, AF4, FAST)
+
+/* MMC4 */
+#define MFP_PRI_TDI_MMC4_DAT3	MFP_CFG_DRV(PRI_TDI, AF7, FAST)
+#define MFP_PRI_TMS_MMC4_DAT3	MFP_CFG_DRV(PRI_TMS, AF7, FAST)
+#define MFP_PRI_TCK_MMC4_DAT3	MFP_CFG_DRV(PRI_TCK, AF7, FAST)
+#define MFP_PRI_TDO_MMC4_DAT3	MFP_CFG_DRV(PRI_TDO, AF7, FAST)
+#define MFP_PRI_TRST_N_MMC4_CMD	MFP_CFG_DRV(PRI_TRST_N, AF7, FAST)
+#define MFP_EXT_WKUP_MMC4_CLK	MFP_CFG_DRV(EXT_WKUP, AF7, FAST)
+#define GPIO28_MMC4_CMD		MFP_CFG_DRV(GPIO28, AF1, FAST)
+#define GPIO29_MMC4_CLK		MFP_CFG_DRV(GPIO29, AF1, FAST)
+#define GPIO30_MMC4_DAT0	MFP_CFG_DRV(GPIO30, AF1, FAST)
+#define GPIO31_MMC4_DAT1	MFP_CFG_DRV(GPIO31, AF1, FAST)
+#define GPIO32_MMC4_DAT2	MFP_CFG_DRV(GPIO32, AF1, FAST)
+#define GPIO33_MMC4_DAT3	MFP_CFG_DRV(GPIO33, AF1, FAST)
+#define GPIO78_MMC4_DAT3	MFP_CFG_DRV(GPIO78, AF5, FAST)
+#define GPIO79_MMC4_DAT2	MFP_CFG_DRV(GPIO79, AF5, FAST)
+#define GPIO80_MMC4_DAT1	MFP_CFG_DRV(GPIO80, AF5, FAST)
+#define GPIO81_MMC4_DAT0	MFP_CFG_DRV(GPIO81, AF5, FAST)
+#define GPIO82_MMC4_CMD		MFP_CFG_DRV(GPIO82, AF5, FAST)
+#define GPIO83_MMC4_CLK		MFP_CFG_DRV(GPIO83, AF5, FAST)
+#define MFP_PWR_SCL_MMC4_CLK	MFP_CFG_DRV(PWR_SCL, AF7, FAST)
+
 /* LCD */
 #define GPIO84_LCD_CS		MFP_CFG(GPIO84, AF1)
 #define GPIO60_LCD_DD0		MFP_CFG(GPIO60, AF1)
@@ -285,6 +386,14 @@
 #define GPIO85_LCD_VSYNC	MFP_CFG(GPIO85, AF1)
 
 /* I2C */
+#define GPIO42_CI2C_SDA		MFP_CFG(GPIO42, AF1)
+#define GPIO50_CI2C_SDA		MFP_CFG(GPIO50, AF1)
+#define GPIO76_CI2C_SDA		MFP_CFG(GPIO76, AF3)
+#define GPIO77_CI2C_SDA		MFP_CFG(GPIO77, AF3)
+#define GPIO80_CI2C_SDA		MFP_CFG(GPIO80, AF3)
+#define GPIO81_CI2C_SDA		MFP_CFG(GPIO81, AF3)
+#define GPIO102_CI2C_SDA	MFP_CFG(GPIO102, AF1)
+#define GPIO103_CI2C_SCL	MFP_CFG(GPIO103, AF1)
 #define GPIO105_CI2C_SDA	MFP_CFG(GPIO105, AF1)
 #define GPIO106_CI2C_SCL	MFP_CFG(GPIO106, AF1)
 
@@ -319,6 +428,32 @@
 #define GPIO86_PWM1_OUT		MFP_CFG(GPIO86, AF2)
 #define GPIO86_PWM2_OUT		MFP_CFG(GPIO86, AF3)
 
+/* Ethernet */
+#define GPIO86_ETH_TX_CLK	MFP_CFG(GPIO86, AF5)
+#define GPIO87_ETH_TX_EN	MFP_CFG(GPIO87, AF5)
+#define GPIO88_ETH_TX_DQ3	MFP_CFG(GPIO88, AF5)
+#define GPIO89_ETH_TX_DQ2	MFP_CFG(GPIO89, AF5)
+#define GPIO90_ETH_TX_DQ1	MFP_CFG(GPIO90, AF5)
+#define GPIO91_ETH_TX_DQ0	MFP_CFG(GPIO91, AF5)
+#define GPIO92_ETH_CRS		MFP_CFG(GPIO92, AF5)
+#define GPIO93_ETH_COL		MFP_CFG(GPIO93, AF5)
+#define GPIO94_ETH_RX_CLK	MFP_CFG(GPIO94, AF5)
+#define GPIO95_ETH_RX_ER	MFP_CFG(GPIO95, AF5)
+#define GPIO96_ETH_RX_DQ3	MFP_CFG(GPIO96, AF5)
+#define GPIO97_ETH_RX_DQ2	MFP_CFG(GPIO97, AF5)
+#define GPIO98_ETH_RX_DQ1	MFP_CFG(GPIO98, AF5)
+#define GPIO99_ETH_RX_DQ0	MFP_CFG(GPIO99, AF5)
+#define GPIO100_ETH_MDC		MFP_CFG(GPIO100, AF5)
+#define GPIO101_ETH_MDIO	MFP_CFG(GPIO101, AF5)
+#define GPIO103_ETH_RX_DV	MFP_CFG(GPIO103, AF5)
+
+#define MFP_PWR_SCL_PWR_SCL	MFP_CFG(PWR_SCL, AF0)
+#define MFP_PWR_SCL_GPIO88	MFP_CFG(PWR_SCL, AF6)
+
+#define MFP_PWR_SDA_PWR_SDA	MFP_CFG(PWR_SDA, AF0)
+#define MFP_PWR_SDA_GPIO87	MFP_CFG(PWR_SDA, AF6)
+
+
 /* Keypad */
 #define GPIO109_KP_MKIN1        MFP_CFG(GPIO109, AF7)
 #define GPIO110_KP_MKIN0        MFP_CFG(GPIO110, AF7)
@@ -351,4 +486,46 @@
 #define GPIO111_SSP2_CLK	MFP_CFG(GPIO111, AF4)
 #define GPIO112_SSP2_FRM	MFP_CFG(GPIO112, AF4)
 
+/* SSP2 */
+#define GPIO107_SSP2_RXD	MFP_CFG(GPIO107, AF4)
+#define GPIO108_SSP2_TXD	MFP_CFG(GPIO108, AF4)
+#define GPIO111_SSP2_CLK	MFP_CFG(GPIO111, AF4)
+#define GPIO112_SSP2_FRM	MFP_CFG(GPIO112, AF4)
+
+/* SSP3 */
+#define MFP_PRI_TRST_N_SSP3_FRM	MFP_CFG(PRI_TRST_N, AF3)
+#define GPIO90_SSP3_CLK		MFP_CFG(GPIO90, AF3)
+#define GPIO91_SSP3_FRM		MFP_CFG(GPIO91, AF3)
+#define GPIO92_SSP3_RXD		MFP_CFG(GPIO92, AF3)
+#define GPIO92_SSP3_TXD		MFP_CFG(GPIO92, AF4)
+#define GPIO93_SSP3_TXD		MFP_CFG(GPIO93, AF3)
+#define GPIO93_SSP3_RXD		MFP_CFG(GPIO93, AF4)
+#define GPIO94_SSP3_FRM		MFP_CFG(GPIO94, AF2)
+#define GPIO111_SSP3_FRM	MFP_CFG(GPIO111, AF3)
+
+/* SSP5 */
+#define MFP_PRI_TDI_SSP5_CLK	MFP_CFG(PRI_TDI, AF4)
+#define MFP_PRI_TMS_SSP5_FRM	MFP_CFG(PRI_TMS, AF4)
+#define MFP_PRI_TCK_SSP5_RXD	MFP_CFG(PRI_TCK, AF4)
+#define MFP_PRI_TDO_SSP5_TXD	MFP_CFG(PRI_TDO, AF4)
+#define GPIO86_SSP5_TXD		MFP_CFG(GPIO86,  AF6)
+#define GPIO86_SSP5_RXD		MFP_CFG(GPIO86,  AF7)
+#define GPIO87_SSP5_RXD		MFP_CFG(GPIO87,  AF6)
+#define GPIO87_SSP5_TXD		MFP_CFG(GPIO87,  AF7)
+#define GPIO88_SSP5_CLK		MFP_CFG(GPIO88,  AF7)
+#define GPIO89_SSP5_FRM		MFP_CFG(GPIO89,  AF7)
+
+/* AC97 */
+#define GPIO94_AC97_SYNC	MFP_CFG(GPIO94, AF4)
+#define GPIO95_AC97_nACRESET	MFP_CFG(GPIO95, AF4)
+#define GPIO104_AC97_SYNC	MFP_CFG(GPIO104, AF5)
+#define GPIO105_AC97_SYNC	MFP_CFG(GPIO105, AF5)
+#define GPIO114_AC97_SDATA_IN_0	MFP_CFG(GPIO114, AF6)
+#define GPIO115_AC97_BITCLK	MFP_CFG(GPIO115, AF6)
+#define GPIO116_AC97_SDATA_IN_1	MFP_CFG(GPIO116, AF6)
+#define GPIO117_AC97_SDATA_OUT	MFP_CFG(GPIO117, AF6)
+#define GPIO118_AC97_SYNC	MFP_CFG(GPIO118, AF6)
+#define GPIO119_AC97_nACRESET	MFP_CFG(GPIO119, AF7)
+
+
 #endif /* __ASM_MACH_MFP_PXA168_H */
diff -Naur linux-3.4.11/arch/arm/mach-mmp/include/mach/pxa168.h linux-HEAD/arch/arm/mach-mmp/include/mach/pxa168.h
--- linux-3.4.11/arch/arm/mach-mmp/include/mach/pxa168.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/include/mach/pxa168.h	2015-11-18 09:04:24.000000000 +0000
@@ -12,10 +12,12 @@
 #include <linux/i2c/pxa-i2c.h>
 #include <mach/devices.h>
 #include <plat/pxa3xx_nand.h>
+#include <plat/audio.h>
 #include <video/pxa168fb.h>
 #include <plat/pxa27x_keypad.h>
 #include <mach/cputype.h>
 #include <linux/pxa168_eth.h>
+#include <linux/platform_data/pxa_sdhci.h>
 
 extern struct pxa_device_desc pxa168_device_uart1;
 extern struct pxa_device_desc pxa168_device_uart2;
@@ -35,13 +37,19 @@
 extern struct pxa_device_desc pxa168_device_fb;
 extern struct pxa_device_desc pxa168_device_keypad;
 extern struct pxa_device_desc pxa168_device_eth;
-
-struct pxa168_usb_pdata {
-	/* If NULL, default phy init routine for PXA168 would be called */
-	int (*phy_init)(void __iomem *usb_phy_reg_base);
-};
-/* pdata can be NULL */
-int __init pxa168_add_usb_host(struct pxa168_usb_pdata *pdata);
+extern struct pxa_device_desc pxa168_device_sdh0;
+extern struct pxa_device_desc pxa168_device_sdh1;
+extern struct pxa_device_desc pxa168_device_sdh2;
+extern struct pxa_device_desc pxa168_device_sdh3;
+extern struct pxa_device_desc pxa168_device_ac97;
+
+extern struct platform_device pxa_device_asoc_platform;
+extern struct platform_device pxa168_device_wdt;
+
+struct mv_usb_platform_data;
+int pxa168_add_usb_host(unsigned int idx, struct mv_usb_platform_data *pdata);
+int pxa168_add_usb_gadget(struct mv_usb_platform_data *pdata);
+int pxa168_add_usb_otg(struct mv_usb_platform_data *pdata);
 
 extern struct platform_device pxa168_device_gpio;
 
@@ -131,6 +139,34 @@
 	return pxa_register_device(&pxa168_device_keypad, data, sizeof(*data));
 }
 
+static inline int pxa168_add_sdh(int id, struct sdhci_pxa_platdata const *data)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 0: d = &pxa168_device_sdh0; break;
+	case 1: d = &pxa168_device_sdh1; break;
+	case 2: d = &pxa168_device_sdh2; break;
+	case 3: d = &pxa168_device_sdh3; break;
+	default:
+		return -EINVAL;
+	}
+
+	return pxa_register_device(d, data, sizeof(*data));
+}
+
+static inline int pxa168_add_asoc(void)
+{
+	return platform_device_register(&pxa_device_asoc_platform);
+}
+
+extern int __init pxa168_add_ac97(pxa2xx_audio_ops_t *ops);
+
+static inline int __init pxa168_add_wdt(void)
+{
+	return platform_device_register(&pxa168_device_wdt);
+}
+
 static inline int pxa168_add_eth(struct pxa168_eth_platform_data *data)
 {
 	return pxa_register_device(&pxa168_device_eth, data, sizeof(*data));
diff -Naur linux-3.4.11/arch/arm/mach-mmp/include/mach/regs-apmu.h linux-HEAD/arch/arm/mach-mmp/include/mach/regs-apmu.h
--- linux-3.4.11/arch/arm/mach-mmp/include/mach/regs-apmu.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/include/mach/regs-apmu.h	2015-11-18 09:04:24.000000000 +0000
@@ -27,8 +27,8 @@
 #define APMU_DMA	APMU_REG(0x064)
 #define APMU_GEU	APMU_REG(0x068)
 #define APMU_BUS	APMU_REG(0x06c)
-#define APMU_SDH2	APMU_REG(0x0e8)
-#define APMU_SDH3	APMU_REG(0x0ec)
+#define APMU_SDH2	APMU_REG(0x0e0)
+#define APMU_SDH3	APMU_REG(0x0e4)
 #define APMU_ETH	APMU_REG(0x0fc)
 
 #define APMU_FNCLK_EN	(1 << 4)
diff -Naur linux-3.4.11/arch/arm/mach-mmp/include/mach/uncompress.h linux-HEAD/arch/arm/mach-mmp/include/mach/uncompress.h
--- linux-3.4.11/arch/arm/mach-mmp/include/mach/uncompress.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/include/mach/uncompress.h	2015-11-18 09:04:24.000000000 +0000
@@ -35,6 +35,12 @@
 {
 }
 
+#ifdef CONFIG_LLUART_OFFSET
+static inline void arch_decomp_setup(void)
+{
+	UART = (unsigned long *)(APB_PHYS_BASE + CONFIG_LLUART_OFFSET);
+}
+#else
 static inline void arch_decomp_setup(void)
 {
 	/* default to UART2 */
@@ -43,6 +49,7 @@
 	if (machine_is_avengers_lite())
 		UART = (unsigned long *)UART3_BASE;
 }
+#endif
 
 /*
  * nothing to do
diff -Naur linux-3.4.11/arch/arm/mach-mmp/Kconfig linux-HEAD/arch/arm/mach-mmp/Kconfig
--- linux-3.4.11/arch/arm/mach-mmp/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -1,6 +1,6 @@
 if ARCH_MMP
 
-menu "Marvell PXA168/910/MMP2 Implmentations"
+menu "Marvell Development Boards"
 
 config MACH_MMP_DT
 	bool "Support MMP2 platforms from device tree"
@@ -14,43 +14,49 @@
 
 config MACH_ASPENITE
 	bool "Marvell's PXA168 Aspenite Development Board"
-	select CPU_PXA168
+	depends on CPU_PXA168
 	help
 	  Say 'Y' here if you want to support the Marvell PXA168-based
 	  Aspenite Development Board.
 
 config MACH_ZYLONITE2
 	bool "Marvell's PXA168 Zylonite2 Development Board"
-	select CPU_PXA168
+	depends on CPU_PXA168
 	help
 	  Say 'Y' here if you want to support the Marvell PXA168-based
 	  Zylonite2 Development Board.
 
 config MACH_AVENGERS_LITE
 	bool "Marvell's PXA168 Avengers Lite Development Board"
-	select CPU_PXA168
+	depends on CPU_PXA168
 	help
 	  Say 'Y' here if you want to support the Marvell PXA168-based
 	  Avengers Lite Development Board.
 
+config MACH_TETON_BGA
+	bool "Marvell's PXA168 Teton BGA Development Board"
+	depends on CPU_PXA168
+	help
+	  Say 'Y' here if you want to support the Marvell PXA168-based
+	  Teton BGA Development Board.
+
 config MACH_TAVOREVB
 	bool "Marvell's PXA910 TavorEVB Development Board"
-	select CPU_PXA910
+	depends on CPU_PXA910
 	help
 	  Say 'Y' here if you want to support the Marvell PXA910-based
 	  TavorEVB Development Board.
 
 config MACH_TTC_DKB
-	bool "Marvell's PXA910 TavorEVB Development Board"
-	select CPU_PXA910
+	bool "Marvell's PXA910 TavorTTC_DKB Development Board"
+	depends on CPU_PXA910
 	help
 	  Say 'Y' here if you want to support the Marvell PXA910-based
 	  TTC_DKB Development Board.
 
 config MACH_BROWNSTONE
 	bool "Marvell's Brownstone Development Platform"
-	depends on !CPU_MOHAWK
-	select CPU_MMP2
+	depends on CPU_MMP2
 	help
 	  Say 'Y' here if you want to support the Marvell MMP2-based
 	  Brown Development Platform.
@@ -80,12 +86,6 @@
 	  PXA910-based development board. Since MMP2 is compatible to
 	  ARMv7 architecture.
 
-config MACH_TETON_BGA
-	bool "Marvell's PXA168 Teton BGA Development Board"
-	select CPU_PXA168
-	help
-	  Say 'Y' here if you want to support the Marvell PXA168-based
-	  Teton BGA Development Board.
 
 config MACH_GPLUGD
 	bool "Marvell's PXA168 GuruPlug Display (gplugD) Board"
@@ -99,6 +99,8 @@
 config CPU_PXA168
 	bool
 	select CPU_MOHAWK
+	select USB_ARCH_HAS_EHCI
+	select RATIONAL
 	help
 	  Select code specific to PXA168
 
@@ -113,4 +115,26 @@
 	select CPU_PJ4
 	help
 	  Select code specific to MMP2. MMP2 is ARMv7 compatible.
+
+config LLUART_OFFSET
+       hex
+       depends on LLUART_UART0 || LLUART_UART1 || LLUART_UART2 || LLUART_HWUART
+       default 0x17000 if LLUART_UART0
+       default 0x18000 if LLUART_UART1
+       default 0x26000 if LLUART_UART2
+
+config LLUART_UART0
+       bool
+
+config LLUART_UART1
+       bool
+
+config LLUART_UART2
+       bool
+
+config PXA168_VARIABLE_SSP_RATE
+       bool
+       prompt "Allow variable SSP rate"
+       depends on EXPERIMENTAL
+
 endif
diff -Naur linux-3.4.11/arch/arm/mach-mmp/Makefile linux-HEAD/arch/arm/mach-mmp/Makefile
--- linux-3.4.11/arch/arm/mach-mmp/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -5,7 +5,7 @@
 obj-y				+= common.o clock.o devices.o time.o
 
 # SoC support
-obj-$(CONFIG_CPU_PXA168)	+= pxa168.o irq-pxa168.o
+obj-$(CONFIG_CPU_PXA168)	+= pxa168.o irq-pxa168.o clock-pxa168.o
 obj-$(CONFIG_CPU_PXA910)	+= pxa910.o irq-pxa168.o
 obj-$(CONFIG_CPU_MMP2)		+= mmp2.o irq-mmp2.o sram.o
 
diff -Naur linux-3.4.11/arch/arm/mach-mmp/pxa168.c linux-HEAD/arch/arm/mach-mmp/pxa168.c
--- linux-3.4.11/arch/arm/mach-mmp/pxa168.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/pxa168.c	2015-11-18 09:04:24.000000000 +0000
@@ -13,6 +13,8 @@
 #include <linux/list.h>
 #include <linux/io.h>
 #include <linux/clk.h>
+#include <linux/ioport.h>
+#include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
 
 #include <asm/mach/time.h>
@@ -28,6 +30,8 @@
 #include <linux/dma-mapping.h>
 #include <mach/pxa168.h>
 
+#include <plat/audio.h>
+
 #include "common.h"
 #include "clock.h"
 
@@ -37,8 +41,9 @@
 {
 	MFP_ADDR_X(GPIO0,   GPIO36,  0x04c),
 	MFP_ADDR_X(GPIO37,  GPIO55,  0x000),
-	MFP_ADDR_X(GPIO56,  GPIO123, 0x0e0),
-	MFP_ADDR_X(GPIO124, GPIO127, 0x0f4),
+	MFP_ADDR_X(GPIO56,  GPIO122, 0x0e0),
+	MFP_ADDR_X(PWR_SCL, PWR_SDA, 0x1ec),
+	MFP_ADDR_X(PRI_TDI, EXT_WKUP, 0x1f4),
 
 	MFP_ADDR_END,
 };
@@ -48,29 +53,169 @@
 	icu_init_irq();
 }
 
+static struct clkops sdh_clk_ops;
+static struct clkops usb_clk_ops;
+
 /* APB peripheral clocks */
 static APBC_CLK(uart1, PXA168_UART1, 1, 14745600);
 static APBC_CLK(uart2, PXA168_UART2, 1, 14745600);
 static APBC_CLK(uart3, PXA168_UART3, 1, 14745600);
+static APBC_CLK(kpc,   PXA168_KPC,   0,    32000);
 static APBC_CLK(twsi0, PXA168_TWSI0, 1, 33000000);
 static APBC_CLK(twsi1, PXA168_TWSI1, 1, 33000000);
 static APBC_CLK(pwm1, PXA168_PWM1, 1, 13000000);
 static APBC_CLK(pwm2, PXA168_PWM2, 1, 13000000);
 static APBC_CLK(pwm3, PXA168_PWM3, 1, 13000000);
 static APBC_CLK(pwm4, PXA168_PWM4, 1, 13000000);
-static APBC_CLK(ssp1, PXA168_SSP1, 4, 0);
-static APBC_CLK(ssp2, PXA168_SSP2, 4, 0);
-static APBC_CLK(ssp3, PXA168_SSP3, 4, 0);
-static APBC_CLK(ssp4, PXA168_SSP4, 4, 0);
-static APBC_CLK(ssp5, PXA168_SSP5, 4, 0);
+static APBC_CLK_OPS(ssp1, PXA168_SSP1, 0, 6500000, &ssp_clk_ops);
+static APBC_CLK_OPS(ssp2, PXA168_SSP2, 0, 6500000, &ssp_clk_ops);
+static APBC_CLK_OPS(ssp3, PXA168_SSP3, 0, 6500000, &ssp_clk_ops);
+static APBC_CLK_OPS(ssp4, PXA168_SSP4, 0, 6500000, &ssp_clk_ops);
+static APBC_CLK_OPS(ssp5, PXA168_SSP5, 0, 6500000, &ssp_clk_ops);
 static APBC_CLK(gpio, PXA168_GPIO, 0, 13000000);
 static APBC_CLK(keypad, PXA168_KPC, 0, 32000);
 static APBC_CLK(rtc, PXA168_RTC, 8, 32768);
+static APBC_CLK(ac97, PXA168_AC97, 0, 48000 * 256);
 
 static APMU_CLK(nand, NAND, 0x19b, 156000000);
 static APMU_CLK(lcd, LCD, 0x7f, 312000000);
 static APMU_CLK(eth, ETH, 0x09, 0);
-static APMU_CLK(usb, USB, 0x12, 0);
+static APMU_CLK_OPS(usb,  USB,  0x12, 48000000, &usb_clk_ops);
+static APMU_CLK_OPS(u2o,  USB,  0x09, 48000000, &usb_clk_ops); /* 48Mhz, USB OTG */
+static APMU_CLK_OPS(sdh0, SDH0, 0x1b, 48000000, &sdh_clk_ops); /* 48MHz, CLK, AXICLK */
+static APMU_CLK_OPS(sdh1, SDH1, 0x12, 48000000, &sdh_clk_ops); /* 48MHz, CLK, AXICLK */
+static APMU_CLK_OPS(sdh2, SDH2, 0x1b, 48000000, &sdh_clk_ops); /* 48MHz, CLK, AXICLK */
+static APMU_CLK_OPS(sdh3, SDH3, 0x12, 48000000, &sdh_clk_ops); /* 48MHz, CLK, AXICLK */
+
+static struct clk clk_wdt = {
+	.clk_rst	=  (void __iomem *)(APB_VIRT_BASE + 0x50000 + 0x0200),
+	.enable_val	=  1,
+	.rate		=  256,
+	.ops		=  &apmu_clk_ops,
+};
+
+static unsigned int	sdh_usage[2] = { 0, 0 };
+static DEFINE_SPINLOCK(sdh_lock);
+static DEFINE_SPINLOCK(usb_lock);
+
+static void usb_clk_enable(struct clk *clk)
+{
+	unsigned long	flags;
+
+	spin_lock_irqsave(&usb_lock, flags);
+	__raw_writel(clk->enable_val | __raw_readl(clk->clk_rst),
+		     clk->clk_rst);
+	spin_unlock_irqrestore(&usb_lock, flags);
+}
+
+static void usb_clk_disable(struct clk *clk)
+{
+	unsigned long	flags;
+
+	spin_lock_irqsave(&usb_lock, flags);
+	__raw_writel(~clk->enable_val & __raw_readl(clk->clk_rst),
+		     clk->clk_rst);
+	spin_unlock_irqrestore(&usb_lock, flags);
+}
+
+static struct clkops usb_clk_ops = {
+	.enable		= usb_clk_enable,
+	.disable	= usb_clk_disable,
+};
+
+static void sdh_clk_enable(struct clk *clk)
+{
+	size_t		idx;
+	bool		is_gate = 0;
+	void __iomem	*gate_ptr;
+	unsigned long	flags;
+
+	switch ((uintptr_t)clk->clk_rst) {
+	case (uintptr_t)APMU_SDH0:
+		is_gate = true;
+		/* fallthrough */
+	case (uintptr_t)APMU_SDH1:
+		idx = 0;
+		gate_ptr = (void __iomem *)APMU_SDH0;
+		break;
+
+	case (uintptr_t)APMU_SDH2:
+		is_gate = true;
+		/* fallthrough */
+	case (uintptr_t)APMU_SDH3:
+		idx = 1;
+		gate_ptr = (void __iomem *)APMU_SDH2;
+		break;
+
+	default:
+		BUG();
+	}
+
+	spin_lock_irqsave(&sdh_lock, flags);
+	if (!is_gate && sdh_usage[idx] == 0)
+		__raw_writel(0x09, gate_ptr);
+
+	__raw_writel(clk->enable_val, clk->clk_rst);
+
+	++sdh_usage[idx];
+	spin_unlock_irqrestore(&sdh_lock, flags);
+
+	if (1)
+		printk(KERN_DEBUG "%s(%p) %02x / [%p]=%02x\n", __func__,
+		       clk->clk_rst, __raw_readl(clk->clk_rst),
+		       gate_ptr, __raw_readl(gate_ptr));
+}
+
+static void sdh_clk_disable(struct clk *clk)
+{
+	size_t		idx;
+	bool		is_gate = 0;
+	void __iomem	*gate_ptr;
+	unsigned long	flags;
+
+	switch ((uintptr_t)clk->clk_rst) {
+	case (uintptr_t)APMU_SDH0:
+		is_gate = true;
+		/* fallthrough */
+	case (uintptr_t)APMU_SDH1:
+		idx = 0;
+		gate_ptr = (void __iomem *)APMU_SDH0;
+		break;
+
+	case (uintptr_t)APMU_SDH2:
+		is_gate = true;
+		/* fallthrough */
+	case (uintptr_t)APMU_SDH3:
+		idx = 1;
+		gate_ptr = (void __iomem *)APMU_SDH2;
+		break;
+
+	default:
+		BUG();
+	}
+
+	spin_lock_irqsave(&sdh_lock, flags);
+	WARN_ON(sdh_usage[idx] == 0);
+	--sdh_usage[idx];
+
+	if (!is_gate)
+		__raw_writel(0, clk->clk_rst);
+
+	if (sdh_usage[idx] == 0)
+		__raw_writel(0, gate_ptr);
+
+	spin_unlock_irqrestore(&sdh_lock, flags);
+
+	if (1)
+		printk(KERN_DEBUG "%s(%p) %02x / [%p]=%02x\n", __func__,
+		       clk->clk_rst, __raw_readl(clk->clk_rst),
+		       gate_ptr, __raw_readl(gate_ptr));
+}
+
+static struct clkops sdh_clk_ops = {
+	.enable		= sdh_clk_enable,
+	.disable	= sdh_clk_disable,
+};
 
 /* device and clock bindings */
 static struct clk_lookup pxa168_clkregs[] = {
@@ -88,13 +233,27 @@
 	INIT_CLKREG(&clk_ssp3, "pxa168-ssp.2", NULL),
 	INIT_CLKREG(&clk_ssp4, "pxa168-ssp.3", NULL),
 	INIT_CLKREG(&clk_ssp5, "pxa168-ssp.4", NULL),
+	INIT_CLKREG(&clk_kpc,  "pxa168-kpc", NULL),
 	INIT_CLKREG(&clk_nand, "pxa3xx-nand", NULL),
+	INIT_CLKREG(&clk_rtc,  "pxa2xx-rtc", NULL),
 	INIT_CLKREG(&clk_lcd, "pxa168-fb", NULL),
 	INIT_CLKREG(&clk_gpio, "pxa-gpio", NULL),
 	INIT_CLKREG(&clk_keypad, "pxa27x-keypad", NULL),
 	INIT_CLKREG(&clk_eth, "pxa168-eth", "MFUCLK"),
-	INIT_CLKREG(&clk_usb, "pxa168-ehci", "PXA168-USBCLK"),
 	INIT_CLKREG(&clk_rtc, "sa1100-rtc", NULL),
+	INIT_CLKREG(&clk_sdh0, "sdhci-pxav2.0", "PXA-SDHCLK"),
+	INIT_CLKREG(&clk_sdh1, "sdhci-pxav2.1", "PXA-SDHCLK"),
+	INIT_CLKREG(&clk_sdh2, "sdhci-pxav2.2", "PXA-SDHCLK"),
+	INIT_CLKREG(&clk_sdh3, "sdhci-pxav2.3", "PXA-SDHCLK"),
+	INIT_CLKREG(&clk_ac97, "pxa2xx-ac97", "AC97CLK"),
+	INIT_CLKREG(&clk_usb, NULL, "PXA168-USBCLK"),
+	INIT_CLKREG(&clk_u2o, NULL, "U2OCLK"),
+	INIT_CLKREG(&clk_wdt, "pxa168-wdt", "WDTCLK"),
+};
+
+static struct platform_device	pxa168_hwmon_device = {
+	.name	= "pxa168-hwmon",
+	.id	= -1,
 };
 
 static int __init pxa168_init(void)
@@ -104,6 +263,8 @@
 		mfp_init_addr(pxa168_mfp_addr_map);
 		pxa_init_dma(IRQ_PXA168_DMA_INT0, 32);
 		clkdev_add_table(ARRAY_AND_SIZE(pxa168_clkregs));
+
+		platform_device_register(&pxa168_hwmon_device);
 	}
 
 	return 0;
@@ -142,8 +303,8 @@
 }
 
 /* on-chip devices */
-PXA168_DEVICE(uart1, "pxa2xx-uart", 0, UART1, 0xd4017000, 0x30, 21, 22);
-PXA168_DEVICE(uart2, "pxa2xx-uart", 1, UART2, 0xd4018000, 0x30, 23, 24);
+PXA168_DEVICE(uart1, "pxa2xx-uart", 0, UART1, 0xd4017000, 0x30, 19, 20);
+PXA168_DEVICE(uart2, "pxa2xx-uart", 1, UART2, 0xd4018000, 0x30, 21, 22);
 PXA168_DEVICE(uart3, "pxa2xx-uart", 2, UART3, 0xd4026000, 0x30, 23, 24);
 PXA168_DEVICE(twsi0, "pxa2xx-i2c", 0, TWSI0, 0xd4011000, 0x28);
 PXA168_DEVICE(twsi1, "pxa2xx-i2c", 1, TWSI1, 0xd4025000, 0x28);
@@ -160,6 +321,10 @@
 PXA168_DEVICE(fb, "pxa168-fb", -1, LCD, 0xd420b000, 0x1c8);
 PXA168_DEVICE(keypad, "pxa27x-keypad", -1, KEYPAD, 0xd4012000, 0x4c);
 PXA168_DEVICE(eth, "pxa168-eth", -1, MFU, 0xc0800000, 0x0fff);
+PXA168_DEVICE(sdh0, "sdhci-pxav2", 0, SDH1, 0xd4280000, 0x100);
+PXA168_DEVICE(sdh1, "sdhci-pxav2", 1, SDH1, 0xd4281000, 0x100);
+PXA168_DEVICE(sdh2, "sdhci-pxav2", 2, SDH2, 0xd427e000, 0x100);
+PXA168_DEVICE(sdh3, "sdhci-pxav2", 3, SDH2, 0xd427f000, 0x100);
 
 struct resource pxa168_resource_gpio[] = {
 	{
@@ -181,20 +346,93 @@
 	.resource	= pxa168_resource_gpio,
 };
 
-struct resource pxa168_usb_host_resources[] = {
+static struct resource			pxa168_ac97_resources[] = {
+	{
+		.name	= "AC97",
+		.start	= 0xd402b000,
+		.end	= 0xd402b000 + 0x600 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.name	= "AC97",
+		.start	= IRQ_PXA168_AC97,
+		.end	= IRQ_PXA168_AC97,
+		.flags	= IORESOURCE_IRQ,
+	}, {
+		.name	= PXA_AC97_DMA_CH_PCM_TX,
+		.start	= 42,
+		.end	= 42,
+		.flags	= IORESOURCE_DMA,
+	}, {
+		.name	= PXA_AC97_DMA_CH_PCM_SURROUND_TX,
+		.start	= 43,
+		.end	= 43,
+		.flags	= IORESOURCE_DMA,
+	}, {
+		.name	= PXA_AC97_DMA_CH_PCM_CENTRE_TX,
+		.start	= 44,
+		.end	= 44,
+		.flags	= IORESOURCE_DMA,
+	}, {
+		.name	= PXA_AC97_DMA_CH_PCM_RX,
+		.start	= 45,
+		.end	= 45,
+		.flags	= IORESOURCE_DMA,
+	}, {
+		.name	= PXA_AC97_DMA_CH_PCM_MODEM_TX,
+		.start	= 46,
+		.end	= 46,
+		.flags	= IORESOURCE_DMA,
+	}, {
+		.name	= PXA_AC97_DMA_CH_PCM_MODEM_RX,
+		.start	= 47,
+		.end	= 47,
+		.flags	= IORESOURCE_DMA,
+	}, {
+		.name	= PXA_AC97_DMA_CH_PCM_MIC,
+		.start	= 48,
+		.end	= 48,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+#include <linux/platform_data/mv_usb.h>
+
+struct resource pxa168_usb_host0_resources[] = {
+	/* regbase */
+	[0] = {
+		.start	= 0xd4208000 + 0x100,
+		.end	= 0xd4208000 + 0x100 + 0x1ff,
+		.flags	= IORESOURCE_MEM,
+		.name	= "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start	= 0xd4207000,
+		.end	= 0xd4207000 + 0xff,
+		.flags	= IORESOURCE_MEM,
+		.name	= "phyregs",
+	},
+	[2] = {
+		.start	= IRQ_PXA168_USB1,
+		.end	= IRQ_PXA168_USB1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct resource pxa168_usb_host1_resources[] = {
 	/* USB Host conroller register base */
 	[0] = {
-		.start	= 0xd4209000,
-		.end	= 0xd4209000 + 0x200,
+		.start	= 0xd4209000 + 0x100,
+		.end	= 0xd4209000 + 0x100 + 0x1ff,
 		.flags	= IORESOURCE_MEM,
-		.name	= "pxa168-usb-host",
+		.name	= "capregs",
 	},
 	/* USB PHY register base */
 	[1] = {
 		.start	= 0xd4206000,
 		.end	= 0xd4206000 + 0xff,
 		.flags	= IORESOURCE_MEM,
-		.name	= "pxa168-usb-phy",
+		.name	= "phyregs",
 	},
 	[2] = {
 		.start	= IRQ_PXA168_USB2,
@@ -203,26 +441,151 @@
 	},
 };
 
+static struct resource
+pxa168_usb_gadget_resources[ARRAY_SIZE(pxa168_usb_host0_resources)];
+static struct resource
+pxa168_usb_otg_resources[ARRAY_SIZE(pxa168_usb_host0_resources)];
+
 static u64 pxa168_usb_host_dmamask = DMA_BIT_MASK(32);
-struct platform_device pxa168_device_usb_host = {
-	.name = "pxa168-ehci",
+static struct platform_device		pxa168_usb_host_devices[] = {
+	{
+		.name = "pxa-u2oehci",
+		.id   = 0,
+		.dev  = {
+			.dma_mask = &pxa168_usb_host_dmamask,
+			.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+
+		.num_resources = ARRAY_SIZE(pxa168_usb_host0_resources),
+		.resource      = pxa168_usb_host0_resources,
+	}, {
+		.name = "pxa-u2oehci",
+		.id   = 1,
+		.dev  = {
+			.dma_mask = &pxa168_usb_host_dmamask,
+			.coherent_dma_mask = DMA_BIT_MASK(32),
+		},
+
+		.num_resources = ARRAY_SIZE(pxa168_usb_host1_resources),
+		.resource      = pxa168_usb_host1_resources,
+	}
+};
+
+static struct platform_device	pxa168_usb_gadget_device = {
+	.name = "mv-udc",
 	.id   = -1,
 	.dev  = {
 		.dma_mask = &pxa168_usb_host_dmamask,
 		.coherent_dma_mask = DMA_BIT_MASK(32),
 	},
 
-	.num_resources = ARRAY_SIZE(pxa168_usb_host_resources),
-	.resource      = pxa168_usb_host_resources,
+	.num_resources = ARRAY_SIZE(pxa168_usb_gadget_resources),
+	.resource      = pxa168_usb_gadget_resources,
 };
 
-int __init pxa168_add_usb_host(struct pxa168_usb_pdata *pdata)
+static struct platform_device	pxa168_usb_otg_device = {
+	.name = "mv-otg",
+	.id   = -1,
+	.dev  = {
+		.dma_mask = &pxa168_usb_host_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+	},
+
+	.num_resources = ARRAY_SIZE(pxa168_usb_otg_resources),
+	.resource      = pxa168_usb_otg_resources,
+};
+
+static char const		*pxa168_usb_clks[] = {
+	[0] = "U2OCLK",
+	[1] = "PXA168-USBCLK",
+};
+
+static void pxa168_complete_usb_platform_data(unsigned int idx,
+					      struct mv_usb_platform_data *pdata)
 {
-	pxa168_device_usb_host.dev.platform_data = pdata;
-	return platform_device_register(&pxa168_device_usb_host);
+	if (!pdata)
+		return;
+
+	if (pdata->clknum == 0) {
+		pdata->clkname = (char **)&pxa168_usb_clks[idx];
+		pdata->clknum = 1;
+	}
+}
+
+int __init pxa168_add_usb_host(unsigned int idx,
+			       struct mv_usb_platform_data *pdata)
+{
+	struct platform_device		*pdev;
+	if (WARN_ON(idx >= ARRAY_SIZE(pxa168_usb_host_devices)))
+		return -EINVAL;
+
+	pxa168_complete_usb_platform_data(idx, pdata);
+	pdev = &pxa168_usb_host_devices[idx];
+
+	pdev->dev.platform_data = pdata;
+	return platform_device_register(pdev);
+}
+
+int __init pxa168_add_usb_gadget(struct mv_usb_platform_data *pdata)
+{
+	memcpy(pxa168_usb_gadget_resources, pxa168_usb_host0_resources,
+	       sizeof pxa168_usb_gadget_resources);
+
+	pxa168_complete_usb_platform_data(0, pdata);
+	pxa168_usb_gadget_device.dev.platform_data = pdata;
+	return platform_device_register(&pxa168_usb_gadget_device);
+}
+
+int __init pxa168_add_usb_otg(struct mv_usb_platform_data *pdata)
+{
+	memcpy(pxa168_usb_otg_resources, pxa168_usb_host0_resources,
+	       sizeof pxa168_usb_otg_resources);
+
+	pxa168_usb_host_devices[1].dev.parent = &pxa168_usb_otg_device.dev;
+	pxa168_usb_gadget_device.dev.parent = &pxa168_usb_otg_device.dev;
+
+	pxa168_complete_usb_platform_data(0, pdata);
+	pxa168_usb_otg_device.dev.platform_data = pdata;
+	return platform_device_register(&pxa168_usb_otg_device);
 }
 
 void pxa168_restart(char mode, const char *cmd)
 {
 	soft_restart(0xffff0000);
 }
+
+static u64 pxa_ac97_dmamask = DMA_BIT_MASK(32);
+static struct platform_device		pxa168_ac97_device = {
+	.name		= "pxa2xx-ac97",
+	.id		= -1,
+	.dev            = {
+		.dma_mask		= &pxa_ac97_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+	.resource	=  &(pxa168_ac97_resources[0]),
+	.num_resources	=  ARRAY_SIZE(pxa168_ac97_resources),
+};
+
+struct platform_device			pxa_device_asoc_platform = {
+	.name		= "pxa-pcm-audio",
+	.id		= -1,
+};
+
+int __init pxa168_add_ac97(pxa2xx_audio_ops_t *ops)
+{
+	int		rc = 0;
+
+	if (ops)
+		rc = platform_device_add_data(&pxa168_ac97_device, ops,
+					      sizeof *ops);
+
+	if (!rc)
+		rc = platform_device_register(&pxa168_ac97_device);
+
+	return rc;
+}
+
+struct platform_device pxa168_device_wdt = {
+	.name	= "pxa168-wdt",
+	.id	= -1,
+};
diff -Naur linux-3.4.11/arch/arm/mach-mmp/time.c linux-HEAD/arch/arm/mach-mmp/time.c
--- linux-3.4.11/arch/arm/mach-mmp/time.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mmp/time.c	2015-11-18 09:04:24.000000000 +0000
@@ -46,14 +46,31 @@
  */
 static inline uint32_t timer_read(void)
 {
-	int delay = 100;
+	unsigned long flags;
+	uint32_t a,b;
+	int32_t delta;
 
-	__raw_writel(1, TIMERS_VIRT_BASE + TMR_CVWR(1));
+	/* 10 clock cycles = 3us */
+	int32_t const max_delta = 10;
 
-	while (delay--)
-		cpu_relax();
+	/* read the raw clock counter and captured clock counter until both
+	 * are having nearly the same value. This is done accordingly notes in
+	 * the PXA168 manual because the the raw clock counter can not be read
+	 * in a stable way and the captured clock register needs some time to
+	 * synchronize. */
+	do {
+		local_irq_save(flags);
 
-	return __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(1));
+		__raw_writel(1, TIMERS_VIRT_BASE + TMR_CVWR(1));
+		a = __raw_readl(TIMERS_VIRT_BASE + TMR_CR(1));
+		b = __raw_readl(TIMERS_VIRT_BASE + TMR_CVWR(1));
+
+		local_irq_restore(flags);
+
+		delta = a-b;
+	} while (delta < -max_delta || delta > max_delta);
+
+	return b;
 }
 
 static u32 notrace mmp_read_sched_clock(void)
diff -Naur linux-3.4.11/arch/arm/mach-mxs/clock-mx28.c linux-HEAD/arch/arm/mach-mxs/clock-mx28.c
--- linux-3.4.11/arch/arm/mach-mxs/clock-mx28.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/clock-mx28.c	2015-11-18 09:04:24.000000000 +0000
@@ -127,6 +127,21 @@
 	return 50000000;
 }
 
+/*
+ * usb0_phy
+ */
+static unsigned long usb0_phy_clk_get_rate(struct clk *clk)
+{
+	return 480000000;
+}
+
+static unsigned long usb1_phy_clk_get_rate(struct clk *clk)
+{
+	return 480000000;
+}
+
+
+
 #define _CLK_ENABLE_PLL(name, r, g)					\
 static int name##_enable(struct clk *clk)				\
 {									\
@@ -482,6 +497,8 @@
 _CLK_SET_RATE_STUB(can0_clk)
 _CLK_SET_RATE_STUB(can1_clk)
 _CLK_SET_RATE_STUB(fec_clk)
+_CLK_SET_RATE_STUB(usb0_phy_clk)
+_CLK_SET_RATE_STUB(usb1_phy_clk)
 
 /*
  * clk_set_parent
@@ -525,6 +542,8 @@
 _CLK_SET_PARENT_STUB(fec_clk)
 _CLK_SET_PARENT_STUB(can0_clk)
 _CLK_SET_PARENT_STUB(can1_clk)
+_CLK_SET_PARENT_STUB(usb0_phy_clk)
+_CLK_SET_PARENT_STUB(usb1_phy_clk)
 
 /*
  * clk definition
@@ -603,6 +622,9 @@
 _DEFINE_CLOCK(spdif_clk, SPDIF, CLKGATE, &pll0_clk);
 _DEFINE_CLOCK(fec_clk, ENET, DISABLE, &hbus_clk);
 
+_DEFINE_CLOCK(usb0_phy_clk, PLL0CTRL0, EN_USB_CLKS, &pll0_clk);
+_DEFINE_CLOCK(usb1_phy_clk, PLL1CTRL0, EN_USB_CLKS, &pll1_clk);
+
 #define _REGISTER_CLOCK(d, n, c) \
 	{ \
 		.dev_id = d, \
@@ -635,6 +657,8 @@
 	_REGISTER_CLOCK("flexcan.1", NULL, can1_clk)
 	_REGISTER_CLOCK(NULL, "usb0", usb0_clk)
 	_REGISTER_CLOCK(NULL, "usb1", usb1_clk)
+	_REGISTER_CLOCK("mxs-usbphy.0", "usb0_phy", usb0_phy_clk)
+	_REGISTER_CLOCK("mxs-usbphy.1", "usb1_phy", usb1_phy_clk)
 	_REGISTER_CLOCK("mxs-pwm.0", NULL, pwm_clk)
 	_REGISTER_CLOCK("mxs-pwm.1", NULL, pwm_clk)
 	_REGISTER_CLOCK("mxs-pwm.2", NULL, pwm_clk)
@@ -786,6 +810,15 @@
 	clk_set_parent(&saif0_clk, &pll0_clk);
 	clk_set_parent(&saif1_clk, &pll0_clk);
 
+#if 0
+	clk_set_parent(&gpmi_clk, &ref_gpmi_clk);
+
+	/* \todo this should be probably done in a better way */
+	clk_prepare_enable(&gpmi_clk);
+	clk_set_rate(&gpmi_clk, 208000000);
+	clk_disable_unprepare(&gpmi_clk);
+#endif
+
 	/*
 	 * Set an initial clock rate for the saif internal logic to work
 	 * properly. This is important when working in EXTMASTER mode that
diff -Naur linux-3.4.11/arch/arm/mach-mxs/devices/Makefile linux-HEAD/arch/arm/mach-mxs/devices/Makefile
--- linux-3.4.11/arch/arm/mach-mxs/devices/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/devices/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -11,3 +11,5 @@
 obj-$(CONFIG_MXS_HAVE_PLATFORM_MXSFB) += platform-mxsfb.o
 obj-$(CONFIG_MXS_HAVE_PLATFORM_MXS_SAIF) += platform-mxs-saif.o
 obj-$(CONFIG_MXS_HAVE_PLATFORM_RTC_STMP3XXX) += platform-rtc-stmp3xxx.o
+
+obj-$(CONFIG_USB_SUPPORT) += usb-phy.o platform-usb.o
diff -Naur linux-3.4.11/arch/arm/mach-mxs/devices/platform-usb.c linux-HEAD/arch/arm/mach-mxs/devices/platform-usb.c
--- linux-3.4.11/arch/arm/mach-mxs/devices/platform-usb.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/devices/platform-usb.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,59 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/module.h>
+
+#include <mach/common.h>
+#include <mach/mx28.h>
+#include <mach/mxs_ehci.h>
+
+struct platform_device *__init mxs_add_usb_phy(unsigned int idx,
+					       resource_size_t iobase,
+					       int irq)
+{
+	struct resource const	 res[] = {
+		{
+			.start	= iobase,
+			.end	= iobase + 0x100 - 1,
+			.flags	= IORESOURCE_MEM
+		},
+		{
+			.start	= irq,
+			.end	= irq,
+			.flags	= (IORESOURCE_IRQ |
+				   IORESOURCE_IRQ_SHAREABLE),
+		},
+	};
+
+	return platform_device_register_simple("mxs-usbphy", idx,
+					       res, ARRAY_SIZE(res));
+}
+
+int __init mxs_add_mxs_usb_phy(void)
+{
+	int	rc = -ENOENT;
+
+	if (cpu_is_mx28()) {
+		mxs_add_usb_phy(0, MX28_USBPHY0_BASE_ADDR,
+				MX28_INT_USB0_WAKEUP);
+		mxs_add_usb_phy(1, MX28_USBPHY1_BASE_ADDR,
+				MX28_INT_USB1_WAKEUP);
+		rc = 0;
+	}
+
+	return 0;
+}
diff -Naur linux-3.4.11/arch/arm/mach-mxs/devices/usb-phy.c linux-HEAD/arch/arm/mach-mxs/devices/usb-phy.c
--- linux-3.4.11/arch/arm/mach-mxs/devices/usb-phy.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/devices/usb-phy.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,504 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define DEBUG
+
+#include "mach/mxs_ehci.h"
+
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/irqreturn.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+
+#include <mach/common.h>
+
+#define DRIVER_NAME	"mxs-usbphy"
+
+struct mxs_usb_phy_device;
+struct mxs_usb_phy_proxy {
+	struct mxs_usb_phy		ops;
+	struct mxs_usb_phy_user		*user;
+	struct mxs_usb_phy_device	*phy;
+
+	atomic_t			clk_enable_counter;
+
+	void		(*activate)(struct mxs_usb_phy_proxy *);
+	void		(*deactivate)(struct mxs_usb_phy_proxy *);
+};
+#define op_to_proxy(ops) container_of(ops, struct mxs_usb_phy_proxy, ops)
+
+enum {
+	MXS_USB_PHY_FLAG_ACTIVE,
+	MXS_USB_PHY_FLAG_IN_IRQ,
+};
+
+struct mxs_usb_phy_device {
+	struct device			*dev;
+	struct clk			*clk;
+	void __iomem			*addr;
+	struct resource			*res;
+	int				irq;
+
+	struct mutex			user_lock;
+	struct mxs_usb_phy_proxy	users[_mxs_usb_phy_mode_max];
+	struct mxs_usb_phy_proxy	*cur_user;
+
+	unsigned int			has_reset:1;
+	unsigned long			flags;
+};
+
+struct mxs_usb_phy *mxs_usb_phy_get(unsigned int idx,
+				    struct mxs_usb_phy_user *user)
+{
+	struct device			*dev = NULL;
+	struct mxs_usb_phy_device	*phy = NULL;
+	struct mxs_usb_phy_proxy	*proxy;
+	struct mxs_usb_phy		*res = res;
+	int		rc;
+	char		dev_name[sizeof DRIVER_NAME "." + sizeof(int) * 3];
+
+	BUG_ON(!user);
+
+	snprintf(dev_name, sizeof dev_name, DRIVER_NAME ".%u", idx);
+	dev = bus_find_device_by_name(&platform_bus_type, NULL, dev_name);
+	if (dev == NULL) {
+		printk(KERN_WARNING "no such device '%s'\n", dev_name);
+		rc = -ENOENT;
+		goto out;
+	}
+
+	phy = dev_get_drvdata(dev);
+	if (WARN_ON(!phy)) {
+		/* race between usb host/gadget driver and phy
+		 * initialization */
+		rc = -EAGAIN;
+		goto out;
+	}
+
+	if (user->mode >= _mxs_usb_phy_mode_max) {
+		printk(KERN_ERR "bad phy mode %u\n", user->mode);
+		rc = -EINVAL;
+		goto out;
+	}
+
+	mutex_lock(&phy->user_lock);
+
+	proxy = &phy->users[user->mode];
+
+	if (WARN_ON(proxy->user != NULL)) {
+		/* phy mode already requested */
+		rc = -EBUSY;
+		goto out;
+	}
+
+	WARN_ON(atomic_read(&proxy->clk_enable_counter) != 0);
+
+	proxy->user = user;
+	res = &proxy->ops;
+	rc = 0;
+
+out:
+	if (phy)
+		mutex_unlock(&phy->user_lock);
+
+	if (rc < 0) {
+		if (dev)
+			put_device(dev);
+
+		res = ERR_PTR(rc);
+	}
+
+	return res;
+}
+EXPORT_SYMBOL_GPL(mxs_usb_phy_get);
+
+static int mxs_usb_phy_ops_reset(struct mxs_usb_phy *ops, int force)
+{
+	struct mxs_usb_phy_proxy	*proxy = op_to_proxy(ops);
+	struct mxs_usb_phy_device	*phy = proxy->phy;
+	int				rc;
+
+	mutex_lock(&phy->user_lock);
+
+	if (phy->has_reset && !force) {
+		rc = 1;
+		goto out;
+	}
+
+	rc = mxs_reset_block(phy->addr + MXS_USBPHY_CTRL);
+	if (rc < 0) {
+		dev_warn(phy->dev, "failed to reset block: %d\n", rc);
+		goto out;
+	}
+
+	phy->has_reset = 1u;
+	rc = 0;
+
+out:
+	mutex_unlock(&phy->user_lock);
+	return rc;
+}
+
+static int mxs_usb_phy_ops_clk_enable(struct mxs_usb_phy *ops)
+{
+	struct mxs_usb_phy_proxy	*proxy = op_to_proxy(ops);
+	struct mxs_usb_phy_device	*phy = proxy->phy;
+	int				rc;
+
+	rc = clk_prepare_enable(phy->clk);
+	if (rc < 0) {
+		dev_warn(phy->dev, "failed to enable clk: %d\n", rc);
+		goto out;
+	}
+
+	atomic_inc(&proxy->clk_enable_counter);
+	rc = 0;
+
+out:
+	return rc;
+}
+
+static int mxs_usb_phy_ops_clk_disable(struct mxs_usb_phy *ops)
+{
+	struct mxs_usb_phy_proxy	*proxy = op_to_proxy(ops);
+	struct mxs_usb_phy_device	*phy = proxy->phy;
+
+	if (atomic_dec_return(&proxy->clk_enable_counter) < 0)
+		__WARN();
+
+	clk_disable_unprepare(phy->clk);
+	return 0;
+}
+
+static void mxs_usb_phy_client_activate(struct mxs_usb_phy_proxy *proxy)
+{
+	void __iomem	*io = proxy->phy->addr;
+
+	dev_dbg(proxy->phy->dev, "enabling gadget mode\n");
+
+	__raw_writel(0, io + MXS_USBPHY_PWD);
+
+	__raw_writel(MXS_USBPHY_CTRL_DEVPLUGIN_POLARITY |
+		     MXS_USBPHY_CTRL_WAKEUP_IRQ |
+		     MXS_USBPHY_CTRL_RESUME_IRQ,
+		     io + MXS_USBPHY_CTRL_clr);
+
+	__raw_writel(MXS_USBPHY_CTRL_ENAUTOSET_USBCLKS |
+		     MXS_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE |
+		     MXS_USBPHY_CTRL_ENAUTOCLR_PHY_PWD |
+		     MXS_USBPHY_CTRL_ENAUTOCLR_CLKGATE |
+		     MXS_USBPHY_CTRL_ENAUTO_PWRON_PLL |
+
+		     MXS_USBPHY_CTRL_ENIRQWAKEUP |
+		     MXS_USBPHY_CTRL_ENIDCHG_WKUP |
+		     MXS_USBPHY_CTRL_ENDPDMCHG_WKUP |
+		     MXS_USBPHY_CTRL_ENVBUSCHG_WKUP |
+		     MXS_USBPHY_CTRL_ENDEVPLUGINDETECT |
+		     MXS_USBPHY_CTRL_ENIRQWAKEUP,
+		     io + MXS_USBPHY_CTRL_set);
+}
+
+static void mxs_usb_phy_client_deactivate(struct mxs_usb_phy_proxy *proxy)
+{
+	dev_dbg(proxy->phy->dev, "disabling gadget mode\n");
+}
+
+static void mxs_usb_phy_host_activate(struct mxs_usb_phy_proxy *proxy)
+{
+	void __iomem	*io = proxy->phy->addr;
+
+	dev_dbg(proxy->phy->dev, "enabling host mode\n");
+
+	__raw_writel(0, io + MXS_USBPHY_PWD);
+	__raw_writel(MXS_USBPHY_CTRL_ENUTMILEVEL3 |
+		     MXS_USBPHY_CTRL_ENUTMILEVEL2,
+		     io + MXS_USBPHY_CTRL_set);
+}
+
+static void mxs_usb_phy_host_deactivate(struct mxs_usb_phy_proxy *proxy)
+{
+	dev_dbg(proxy->phy->dev, "disabling host mode\n");
+}
+
+static void mxs_usb_phy_deactivate_cur(struct mxs_usb_phy_device *phy)
+{
+	BUG_ON(!mutex_is_locked(&phy->user_lock));
+	WARN_ON(atomic_read(&phy->cur_user->clk_enable_counter) != 0);
+
+	phy->cur_user->deactivate(phy->cur_user);
+
+	clear_bit(MXS_USB_PHY_FLAG_ACTIVE, &phy->flags);
+	while (test_bit(MXS_USB_PHY_FLAG_IN_IRQ, &phy->flags))
+		schedule();
+
+	phy->cur_user = NULL;
+}
+
+static int mxs_usb_phy_ops_enable(struct mxs_usb_phy *ops)
+{
+	struct mxs_usb_phy_proxy	*proxy = op_to_proxy(ops);
+	struct mxs_usb_phy_device	*phy = proxy->phy;
+	int				rc;
+
+	BUG_ON(proxy->user == NULL);
+	BUG_ON(proxy != &phy->users[MXS_USB_PHY_MODE_HOST] &&
+	       proxy != &phy->users[MXS_USB_PHY_MODE_CLIENT]);
+
+	mutex_lock(&phy->user_lock);
+
+	if (phy->cur_user == proxy) {
+		/* noop; already active function requested */
+		rc = 0;
+		goto out;
+	}
+
+	if (phy->cur_user)
+		mxs_usb_phy_deactivate_cur(phy);
+
+	phy->cur_user = proxy;
+	set_bit(MXS_USB_PHY_FLAG_ACTIVE, &phy->flags);
+
+	proxy->activate(proxy);
+
+out:
+	mutex_unlock(&phy->user_lock);
+
+	return rc;
+};
+
+static void mxs_usb_phy_ops_put(struct mxs_usb_phy *ops)
+{
+	struct mxs_usb_phy_proxy	*proxy = op_to_proxy(ops);
+	struct mxs_usb_phy_device	*phy = proxy->phy;
+
+	WARN_ON(proxy->user == NULL);
+	BUG_ON(proxy != &phy->users[MXS_USB_PHY_MODE_HOST] &&
+	       proxy != &phy->users[MXS_USB_PHY_MODE_CLIENT]);
+
+	mutex_lock(&phy->user_lock);
+
+	if (proxy == phy->cur_user)
+		mxs_usb_phy_deactivate_cur(phy);
+
+	proxy->user = NULL;
+
+	WARN_ON(atomic_read(&proxy->clk_enable_counter) != 0);
+
+	mutex_unlock(&phy->user_lock);
+
+	put_device(phy->dev);
+}
+
+static void mxs_usb_init_proxy(struct mxs_usb_phy_proxy *proxy,
+			       struct mxs_usb_phy_device *phy)
+{
+	proxy->phy = phy;
+
+	proxy->ops.addr = phy->addr;
+
+	proxy->ops.put = mxs_usb_phy_ops_put;
+	proxy->ops.reset = mxs_usb_phy_ops_reset;
+	proxy->ops.clk_enable = mxs_usb_phy_ops_clk_enable;
+	proxy->ops.clk_disable = mxs_usb_phy_ops_clk_disable;
+	proxy->ops.enable = mxs_usb_phy_ops_enable;
+}
+
+static irqreturn_t mxs_usb_phy_irq(int irq, void *phy_v)
+{
+	struct mxs_usb_phy_device	*phy = phy_v;
+	irqreturn_t			rc = IRQ_NONE;
+	struct mxs_usb_phy_proxy	*user;
+
+	set_bit(MXS_USB_PHY_FLAG_IN_IRQ, &phy->flags);
+
+	if (!test_bit(MXS_USB_PHY_FLAG_ACTIVE, &phy->flags))
+		goto out;
+
+	user = phy->cur_user;
+	if (user == NULL)
+		goto out;
+
+	rc = IRQ_HANDLED;
+
+out:
+	clear_bit(MXS_USB_PHY_FLAG_IN_IRQ, &phy->flags);
+	return rc;
+}
+
+static int __init mxs_usb_phy_probe(struct platform_device *pdev)
+{
+	struct mxs_usb_phy_device	*phy = NULL;
+	struct resource			*res = NULL;
+	int				irq;
+	int				rc;
+	char				clk_name[sizeof("usb_phy") +
+						 sizeof(int) * 3];
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "missing memory resources\n");
+		rc = -ENXIO;
+		goto out;
+	}
+
+	rc = platform_get_irq(pdev, 0);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "missing wakeup irq: %d\n", rc);
+		goto out;
+	}
+	irq = rc;
+
+	phy = kzalloc(sizeof *phy, GFP_KERNEL);
+	if (!phy) {
+		dev_err(&pdev->dev, "failed to allocate device\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	phy->irq = -1;
+	phy->res = request_mem_region(res->start, resource_size(res),
+				      dev_name(&pdev->dev));
+	if (!phy->res) {
+		dev_err(&pdev->dev, "failed to request memory region\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	snprintf(clk_name, sizeof clk_name, "usb%u_phy", pdev->id);
+	phy->clk = clk_get(&pdev->dev, clk_name);
+	if (IS_ERR(phy->clk)) {
+		rc = PTR_ERR(phy->clk);
+		dev_err(&pdev->dev, "failed to get clock '%s': %d\n",
+			clk_name, rc);
+		phy->clk = NULL;
+		goto out;
+	}
+
+	phy->addr = ioremap(phy->res->start, resource_size(phy->res));
+	if (!phy->addr) {
+		dev_err(&pdev->dev, "failed to map memory\n");
+		rc = -EFAULT;
+		goto out;
+	}
+
+	rc = request_irq(irq, mxs_usb_phy_irq, IRQF_SHARED,
+			 dev_name(&pdev->dev), phy);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to request irq: %d\n", rc);
+		goto out;
+	}
+
+	phy->irq = irq;
+	phy->dev = &pdev->dev;
+
+	mutex_init(&phy->user_lock);
+
+	{
+		struct mxs_usb_phy_proxy	*host =
+			&phy->users[MXS_USB_PHY_MODE_HOST];
+		struct mxs_usb_phy_proxy	*client =
+			&phy->users[MXS_USB_PHY_MODE_CLIENT];
+
+		mxs_usb_init_proxy(host, phy);
+		mxs_usb_init_proxy(client, phy);
+
+		host->activate = mxs_usb_phy_host_activate;
+		host->deactivate = mxs_usb_phy_host_deactivate;
+
+		client->activate = mxs_usb_phy_client_activate;
+		client->deactivate = mxs_usb_phy_client_deactivate;
+	}
+
+	platform_set_drvdata(pdev, phy);
+
+	dev_info(&pdev->dev, "initialized usb phy\n");
+	rc = 0;
+
+out:
+	if (rc < 0 && phy) {
+		if (phy->irq >= 0)
+			free_irq(phy->irq, phy);
+
+		iounmap(phy->addr);
+
+		if (phy->clk)
+			clk_put(phy->clk);
+
+		if (phy->res) {
+			release_mem_region(phy->res->start,
+					   resource_size(phy->res));
+			kfree(phy->res);
+		}
+
+		kfree(phy);
+	}
+
+	return rc;
+}
+
+static int __devexit mxs_usb_phy_remove(struct platform_device *pdev)
+{
+	struct mxs_usb_phy_device	*phy = platform_get_drvdata(pdev);
+
+	mutex_lock(&phy->user_lock);
+
+	WARN_ON(phy->cur_user != NULL);
+
+	clear_bit(MXS_USB_PHY_FLAG_ACTIVE, &phy->flags);
+	free_irq(phy->irq, phy);
+
+	while (test_bit(MXS_USB_PHY_FLAG_IN_IRQ, &phy->flags))
+		schedule();
+
+	iounmap(phy->addr);
+	clk_put(phy->clk);
+	release_mem_region(phy->res->start, resource_size(phy->res));
+	kfree(phy->res);
+
+	mutex_unlock(&phy->user_lock);
+
+	kfree(phy);
+
+	return 0;
+}
+
+struct platform_driver	mxs_usb_phy_driver = {
+	.driver	= {
+		.name	= DRIVER_NAME,
+	},
+	.remove	= __exit_p(mxs_usb_phy_remove),
+};
+
+static int __init mxs_usb_phy_init(void)
+{
+	return platform_driver_probe(&mxs_usb_phy_driver,
+				     mxs_usb_phy_probe);
+}
+subsys_initcall(mxs_usb_phy_init);
+
+static void __exit mxs_usb_phy_exit(void)
+{
+	platform_driver_unregister(&mxs_usb_phy_driver);
+}
+module_exit(mxs_usb_phy_exit);
+
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff -Naur linux-3.4.11/arch/arm/mach-mxs/eq3-ccu2/ccu2-bootloader.c linux-HEAD/arch/arm/mach-mxs/eq3-ccu2/ccu2-bootloader.c
--- linux-3.4.11/arch/arm/mach-mxs/eq3-ccu2/ccu2-bootloader.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/eq3-ccu2/ccu2-bootloader.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,73 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/bug.h>
+#include <linux/moduleparam.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <mach/mx28.h>
+
+#define MX28_RTC_PERSISTENT1_ADDR	(MXS_IO_P2V(MX28_RTC_BASE_ADDR) + 0x70)
+
+#define BIT_ROM_RECOVERY_BOOT		(1u << 0)
+#define BIT_ROM_SECONDARY_BOOT		(1u << 1)
+
+#define BIT_BOOT_PENDING		(1u << 29) /* proprietary */
+
+#define streq(_v, _str) \
+	(strncmp((_v), (_str), sizeof (_str) - 1) == 0)
+
+static int ccu2_bootloader_boot_set(char const *val,
+				     struct kernel_param const *kp)
+{
+	unsigned int	bits_set = 0;
+	unsigned int	bits_clr = 0;
+
+	if (streq(val, "primary")) {
+		bits_clr = BIT_ROM_SECONDARY_BOOT | BIT_BOOT_PENDING;
+	} else if (streq(val, "secondary")) {
+		bits_clr = BIT_BOOT_PENDING;
+		bits_set = BIT_ROM_SECONDARY_BOOT;
+	} else if (streq(val, "recovery")) {
+		bits_clr = BIT_BOOT_PENDING | BIT_ROM_SECONDARY_BOOT;
+		bits_set = BIT_ROM_RECOVERY_BOOT;
+	} else if (streq(val, "finish")) {
+		bits_clr = BIT_BOOT_PENDING;
+	} else {
+		printk(KERN_WARNING "unsupported op '%s'\n", val);
+		return -EINVAL;
+	}
+
+	__raw_writel(bits_clr, MX28_RTC_PERSISTENT1_ADDR + MXS_CLR_ADDR);
+	__raw_writel(bits_set, MX28_RTC_PERSISTENT1_ADDR + MXS_SET_ADDR);
+
+	return 0;
+}
+
+static int ccu2_bootloader_boot_get(char *buf,
+				    struct kernel_param const *kp)
+{
+	unsigned int	v = readl(MX28_RTC_PERSISTENT1_ADDR);
+
+	return sprintf(buf, "%08x", v);
+}
+
+static struct kernel_param_ops	boot_ops = {
+	.set	=  ccu2_bootloader_boot_set,
+	.get	=  ccu2_bootloader_boot_get,
+};
+
+module_param_cb(boot, &boot_ops, NULL, 0644);
diff -Naur linux-3.4.11/arch/arm/mach-mxs/eq3-ccu2/ccu2.c linux-HEAD/arch/arm/mach-mxs/eq3-ccu2/ccu2.c
--- linux-3.4.11/arch/arm/mach-mxs/eq3-ccu2/ccu2.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/eq3-ccu2/ccu2.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,751 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/types.h>
+#include <linux/irq.h>
+#include <linux/dma-mapping.h>
+#include <linux/fsl_devices.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+
+#include <linux/regulator/fixed.h>
+#include <linux/regulator/machine.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+
+#include <mach/common.h>
+#include <mach/iomux-mx28.h>
+
+#include "../devices-mx28.h"
+
+
+#define CCU2_USB0_EN_GPIO	MXS_GPIO_NR(3,  3)
+#define CCU2_USB0_EN_IRQ	(CCU2_USB0_EN_GPIO + MXS_GPIO_IRQ_START)
+
+#define CCU2_USB1_EN_GPIO	MXS_GPIO_NR(1, 24)
+#define CCU2_SD_PWR_EN		MXS_GPIO_NR(3, 28)
+
+#define CCU2_LED0_GPIO		MXS_GPIO_NR(3, 20)
+#define CCU2_LED1_GPIO		MXS_GPIO_NR(3, 21)
+#define CCU2_LED2_GPIO		MXS_GPIO_NR(3, 23)
+#define CCU2_KEY_GPIO		MXS_GPIO_NR(3, 22)
+
+#define CCU2_ENET0_INT_GPIO	MXS_GPIO_NR(1, 25)
+#define CCU2_ENET0_INT_IRQ	(CCU2_ENET0_INT_GPIO + MXS_GPIO_IRQ_START)
+
+#define CCU2_ENET0_RST_GPIO	MXS_GPIO_NR(3,  2)
+
+#define CCU2_IC200_nRST_GPIO	MXS_GPIO_NR(2, 20)
+#define CCU2_IC200_PWR_GPIO	MXS_GPIO_NR(2, 21)
+
+#define CCU2_PAD8_PU		(MXS_PAD_8MA | MXS_PAD_3V3 | MXS_PAD_PULLUP)
+#define CCU2_PAD8_NOPU		(MXS_PAD_8MA | MXS_PAD_3V3 | MXS_PAD_NOPULL)
+#define CCU2_PAD8_BK		(MXS_PAD_8MA | MXS_PAD_3V3 | MXS_PAD_NOPULL)
+#define CCU2_PAD8_NOBK		(MXS_PAD_8MA | MXS_PAD_3V3 | MXS_PAD_PULLUP)
+
+static const iomux_cfg_t ccu2_pads[] __initconst = {
+	/* MMC0 */
+	MX28_PAD_SSP0_DETECT__SSP0_CARD_DETECT | MXS_PAD_4MA | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_SSP0_DATA0__SSP0_D0 | MXS_PAD_12MA | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_SSP0_DATA1__SSP0_D1 | MXS_PAD_12MA | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_SSP0_DATA2__SSP0_D2 | MXS_PAD_12MA | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_SSP0_DATA3__SSP0_D3 | MXS_PAD_12MA | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_SSP0_DATA4__GPIO_2_4 | MXS_PAD_12MA | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_SSP0_DATA5__GPIO_2_5 | MXS_PAD_12MA | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_SSP0_DATA6__GPIO_2_6 | MXS_PAD_12MA | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_SSP0_DATA7__GPIO_2_7 | MXS_PAD_12MA | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_SSP0_CMD__SSP0_CMD  | MXS_PAD_12MA | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_SSP0_SCK__SSP0_SCK  | MXS_PAD_12MA | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_PWM3__GPIO_3_28 | MXS_PAD_4MA | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+
+	/* SPI */
+#if defined(CONFIG_SPI_EQ3SPI) || defined(CONFIG_SPI_EQ3SPI_MODULE)
+	MX28_PAD_SSP2_SCK__GPIO_2_16 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_SSP2_MOSI__GPIO_2_17 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_SSP2_MISO__GPIO_2_18 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+#else
+	MX28_PAD_SSP2_SCK__SSP2_SCK | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_SSP2_MOSI__SSP2_CMD | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_SSP2_MISO__SSP2_D0 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+#endif
+
+	MX28_PAD_SSP2_SS0__GPIO_2_19 | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_SSP2_SS1__GPIO_2_20 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_SSP2_SS2__GPIO_2_21 | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+
+	/* I2C */
+	MX28_PAD_I2C0_SCL__I2C0_SCL | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_I2C0_SDA__I2C0_SDA | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+
+	/* AUART0 */
+	MX28_PAD_AUART0_RX__AUART0_RX | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_AUART0_TX__AUART0_TX | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+
+	/* AUART1 */
+	MX28_PAD_AUART1_RX__AUART1_RX | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_AUART1_TX__AUART1_TX | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+
+	/* DUART */
+	MX28_PAD_PWM0__DUART_RX | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_PWM1__DUART_TX | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+
+	/* KEY/LED */
+	MX28_PAD_SAIF0_BITCLK__GPIO_3_22 | MXS_PAD_3V3 | MXS_PAD_NOPULL, /* KEY */
+	MX28_PAD_SAIF0_LRCLK__GPIO_3_21 | MXS_PAD_3V3 | MXS_PAD_NOPULL, /* LED-1 */
+	MX28_PAD_SAIF0_MCLK__GPIO_3_20 | MXS_PAD_3V3 |  MXS_PAD_NOPULL, /* LED-0 */
+	MX28_PAD_SAIF0_SDATA0__GPIO_3_23 | MXS_PAD_3V3 | MXS_PAD_NOPULL, /* LED-2 */
+
+	/* USB */
+	MX28_PAD_LCD_RD_E__GPIO_1_24 | MXS_PAD_3V3 | MXS_PAD_NOPULL, /* USB1-EN */
+	MX28_PAD_AUART0_RTS__GPIO_3_3 | MXS_PAD_3V3 | MXS_PAD_NOPULL, /* USB0-EN */
+
+	/* FEC0 */
+	MX28_PAD_AUART0_CTS__GPIO_3_2     | CCU2_PAD8_BK, /* ENET0-nRST */
+	MX28_PAD_LCD_WR_RWN__GPIO_1_25    | CCU2_PAD8_BK,
+	MX28_PAD_ENET_CLK__CLKCTRL_ENET   | CCU2_PAD8_NOBK,
+	MX28_PAD_ENET0_TX_EN__ENET0_TX_EN | CCU2_PAD8_PU,
+	MX28_PAD_ENET0_MDC__ENET0_MDC     | CCU2_PAD8_PU,
+	MX28_PAD_ENET0_MDIO__ENET0_MDIO   | CCU2_PAD8_NOPU, /* external pullup */
+	MX28_PAD_ENET0_TXD0__ENET0_TXD0   | CCU2_PAD8_PU,
+	MX28_PAD_ENET0_TXD1__ENET0_TXD1   | CCU2_PAD8_PU,
+
+	/* drive them as gpios during initialization; phy might be
+	 * misconfigured else */
+	MX28_PAD_ENET0_RX_EN__GPIO_4_2    | CCU2_PAD8_PU,
+	MX28_PAD_ENET0_RXD0__GPIO_4_3     | CCU2_PAD8_PU,
+	MX28_PAD_ENET0_RXD1__GPIO_4_4     | CCU2_PAD8_PU,
+
+	/* GPMI NAND */
+	MX28_PAD_GPMI_ALE__GPMI_ALE | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_GPMI_CE0N__GPMI_CE0N | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_GPMI_CLE__GPMI_CLE | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_GPMI_RDN__GPMI_RDN | MXS_PAD_3V3 | MXS_PAD_NOPULL | MXS_PAD_12MA,
+	MX28_PAD_GPMI_RDY0__GPMI_READY0 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_GPMI_WRN__GPMI_WRN | MXS_PAD_3V3 | MXS_PAD_NOPULL | MXS_PAD_12MA,
+	MX28_PAD_GPMI_D00__GPMI_D0 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_GPMI_D01__GPMI_D1 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_GPMI_D02__GPMI_D2 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_GPMI_D03__GPMI_D3 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_GPMI_D04__GPMI_D4 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_GPMI_D05__GPMI_D5 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_GPMI_D06__GPMI_D6 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_GPMI_D07__GPMI_D7 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+
+	MX28_PAD_GPMI_RESETN__GPMI_RESETN | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+
+	/* unused */
+	MX28_PAD_PWM2__USB0_ID | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+
+	MX28_PAD_SAIF1_SDATA0__GPIO_3_26 | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_PWM4__GPIO_3_29  | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_LCD_RS__GPIO_1_26 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_LCD_D00__GPIO_1_0 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_LCD_D01__GPIO_1_1 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_LCD_D02__GPIO_1_2 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_LCD_D03__GPIO_1_3 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_LCD_D04__GPIO_1_4 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_LCD_D05__GPIO_1_5 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_LCD_D06__GPIO_1_6 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+	MX28_PAD_LCD_D07__GPIO_1_7 | MXS_PAD_3V3 | MXS_PAD_NOPULL,
+
+	MX28_PAD_GPMI_CE1N__GPIO_0_17 | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+	MX28_PAD_GPMI_RDY1__GPIO_0_21 | MXS_PAD_3V3 | MXS_PAD_PULLUP,
+};
+
+static struct gpio const	ccu2_gpios[] __initconst = {
+	{ CCU2_ENET0_INT_GPIO, GPIOF_IN, "ENET0-nINT*" },
+	{ CCU2_ENET0_RST_GPIO, GPIOF_OUT_INIT_HIGH, "ENET0-nRST"  },
+	{ MXS_GPIO_NR(4,2),    GPIOF_IN, "ENET0-RX_EN*"  },
+	{ MXS_GPIO_NR(4,3),    GPIOF_IN, "ENET0-RXD0*"  },
+	{ MXS_GPIO_NR(4,4),    GPIOF_IN, "ENET0-RXD1*"  },
+};
+
+static struct fec_platform_data mx28_fec_pdata[] __initdata = {
+	{
+		/* fec0 */
+		.phy = PHY_INTERFACE_MODE_RMII,
+		.phy_addr = 0,
+		.phy_irq = CCU2_ENET0_INT_IRQ,
+	},
+};
+
+static struct mxs_mmc_platform_data ccu2_mmc0_pdata __initdata = {
+       .wp_gpio = -EINVAL,
+       .flags = SLOTF_4_BIT_CAPABLE,
+};
+
+#include <mach/mxs_ehci.h>
+static struct resource		ccu2_ehci0_resources[] = {
+	{
+		.start = MX28_USBCTRL0_BASE_ADDR,
+		.end   = MX28_USBCTRL0_BASE_ADDR + 0x200 - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MX28_INT_USB0,
+		.end   = MX28_INT_USB0,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		.start = MX28_INT_USB0_WAKEUP,
+		.end   = MX28_INT_USB0_WAKEUP,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct resource const	ccu2_ehci1_resources[] __initconst = {
+	{
+		.start = MX28_USBCTRL1_BASE_ADDR,
+		.end   = MX28_USBCTRL1_BASE_ADDR + 0x200 - 1,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MX28_INT_USB1,
+		.end   = MX28_INT_USB1,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		.start = MX28_INT_USB1_WAKEUP,
+		.end   = MX28_INT_USB1_WAKEUP,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/* LM26400Y */
+
+static struct regulator_consumer_supply	ccu2_lm26400_3v3_pwr_consumers[] = {
+	REGULATOR_SUPPLY("REG-3V3", "leds-gpio")
+};
+
+static struct regulator_init_data	ccu2_lm26400_pwr_regulator[] = {
+	[0] = {
+		.constraints	=  {
+			.name		= "REG-3V3",
+			.min_uV		= 3300000,
+			.max_uV		= 3300000,
+			.always_on	= 1u,
+			.valid_ops_mask = 0,
+			.valid_modes_mask	=  REGULATOR_MODE_NORMAL,
+		},
+		.consumer_supplies	= ccu2_lm26400_3v3_pwr_consumers,
+		.num_consumer_supplies	= ARRAY_SIZE(ccu2_lm26400_3v3_pwr_consumers)
+	},
+	[1] = {
+		.constraints		=  {
+			.name		= "REG-1V8",
+			.min_uV		= 1800000,
+			.max_uV		= 1800000,
+			.always_on	= 1u,
+			.valid_ops_mask = 0,
+			.valid_modes_mask	=  REGULATOR_MODE_NORMAL,
+		},
+	}
+};
+
+static struct fixed_voltage_config	ccu2_lm26400_pwr_data[] = {
+	{
+		.supply_name		= "REG-3V3",
+		.microvolts		= 3300000,
+		.gpio			= -1,
+		.init_data		= &ccu2_lm26400_pwr_regulator[0],
+	}, {
+		.supply_name		= "REG-1V8",
+		.microvolts		= 1800000,
+		.gpio			= -1,
+		.init_data		= &ccu2_lm26400_pwr_regulator[1],
+	}
+};
+
+/* VDDIO-SD */
+
+static struct regulator_consumer_supply	ccu2_ssp0_pwr_consumers[] = {
+	REGULATOR_SUPPLY("VDDIO-SD", "mxs-mmc.0")
+};
+
+static struct regulator_init_data	ccu2_ssp0_pwr_regulator = {
+	.constraints		=  {
+		.name		=  "VDDIO-SD",
+		.min_uV		=  3300000,
+		.max_uV		=  3300000,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask	=  REGULATOR_MODE_NORMAL,
+	},
+	.consumer_supplies	=  ccu2_ssp0_pwr_consumers,
+	.num_consumer_supplies	=  ARRAY_SIZE(ccu2_ssp0_pwr_consumers),
+};
+
+static struct fixed_voltage_config	ccu2_ssp0_pwr_data = {
+	.supply_name		= "VDDIO-SD",
+	.microvolts		= 3300000,
+	.gpio			= CCU2_SD_PWR_EN,
+	.enable_high		= 0u,
+	.init_data		= &ccu2_ssp0_pwr_regulator,
+	.startup_delay		= 100000, /* 100ms */
+};
+
+
+/* USB 5V */
+
+static struct regulator_consumer_supply	ccu2_usb1_pwr_consumers[] = {
+	REGULATOR_SUPPLY("USB_5V", "mxs-ehci.1")
+};
+
+static struct regulator_init_data	ccu2_usb1_pwr_regulator = {
+	.constraints		=  {
+		.name		=  "USB 5V",
+		.min_uV		=  5000000,
+		.max_uV		=  5000000,
+		.valid_ops_mask = REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask	=  REGULATOR_MODE_NORMAL,
+	},
+	.consumer_supplies	=  ccu2_usb1_pwr_consumers,
+	.num_consumer_supplies	=  ARRAY_SIZE(ccu2_usb1_pwr_consumers),
+};
+
+static struct fixed_voltage_config	ccu2_usb1_pwr_data = {
+	.supply_name		= "USB1_5V",
+	.microvolts		= 5000000,
+	.gpio			= CCU2_USB1_EN_GPIO,
+	.enable_high		= 1u,
+	.init_data		= &ccu2_usb1_pwr_regulator,
+};
+
+static int ccu2_ehci1_init(struct platform_device *pdev,
+			     void __iomem *regs, void __iomem *phy)
+{
+	return 0;
+}
+
+static int ccu2_ehci1_exit(struct platform_device *pdev,
+			     void __iomem *regs, void __iomem *phy	)
+{
+	return 0;
+}
+
+struct mxs_usbh_platform_data const	ccu2_ehci1_pdata __initconst = {
+	.portsc = (MXS_EHCI_MODE_UTMI | MXS_EHCI_UTMI_16BIT |
+		   MXS_EHCI_PSPD_HIGH | (1u << 24)),
+	.init	= ccu2_ehci1_init,
+	.exit	= ccu2_ehci1_exit,
+};
+
+static struct fsl_usb2_platform_data	ccu2_otg0_pdata = {
+        .operating_mode = FSL_USB2_DR_DEVICE,
+        .phy_mode       = FSL_USB2_PHY_UTMI_WIDE,
+};
+
+#include <linux/usb/gpio_vbus.h>
+static struct resource			ccu2_otg_vbus_resources[] = {
+	{
+		.start	= CCU2_USB0_EN_IRQ,
+		.end	= CCU2_USB0_EN_IRQ,
+		.flags	= (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING |
+			   IRQF_SAMPLE_RANDOM | IRQF_SHARED |
+			   IORESOURCE_IRQ)
+	},
+};
+
+static struct gpio_vbus_mach_info	ccu2_otg_vbus_data = {
+	.gpio_vbus	= CCU2_USB0_EN_GPIO,
+};
+
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_gpio.h>
+static struct spi_board_info ccu2_spi_board_info[] = {
+	{
+		.modalias = "spidev",
+		.max_speed_hz = 11059200 / 6 / 10,
+		.bus_num = 0,
+		.chip_select = 0,
+		.controller_data = (void *)SPI_GPIO_NO_CHIPSELECT,
+		.mode = SPI_MODE_0,
+	},
+};
+
+#include <linux/i2c.h>
+static struct i2c_board_info	ccu2_i2c_boardinfo[] __initdata = {
+	{
+		I2C_BOARD_INFO("rs5c372a", 0x32),
+	},
+};
+
+#include <linux/leds.h>
+static struct gpio_led const	ccu2_leds[] __initconst = {
+	{
+		.name = "power",
+		.gpio = CCU2_LED2_GPIO,
+		.default_trigger = "timer",
+	}, {
+		.name = "internet",
+		.gpio = CCU2_LED1_GPIO,
+#ifdef CONFIG_PLAT_EQ3_RESCUE_MODE
+		.default_trigger = "timer",
+#endif
+	}, {
+		.name = "info",
+		.gpio = CCU2_LED0_GPIO,
+#ifdef CONFIG_PLAT_EQ3_RESCUE_MODE
+		.default_trigger = "timer",
+#endif
+	},
+};
+
+static struct gpio_led_platform_data	ccu2_led_data = {
+	.leds = ccu2_leds,
+	.num_leds = ARRAY_SIZE(ccu2_leds),
+};
+
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+static struct gpio_keys_button	ccu2_keys[] = {
+	{
+		.code		=  BTN_A,
+		.gpio		=  CCU2_KEY_GPIO,
+		.active_low	=  1,
+		.desc		=  "KEY",
+		.type		=  EV_KEY,
+	},
+};
+
+static struct gpio_keys_platform_data	ccu2_keys_data = {
+	.buttons	=  ccu2_keys,
+	.nbuttons	=  ARRAY_SIZE(ccu2_keys),
+	.poll_interval	=  10,
+};
+
+static struct resource		mx28_rtc_resources[] = {
+	{
+		.start		=  MX28_RTC_BASE_ADDR,
+		.end		=  MX28_RTC_BASE_ADDR + 0x100 - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= MX28_INT_RTC_ALARM,
+		.end		= MX28_INT_RTC_ALARM,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+static struct resource		mxs_raw_auart0_resources[] = {
+	{
+		.start		=  MX28_AUART0_BASE_ADDR,
+		.end		=  MX28_AUART0_BASE_ADDR + 0x100 - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= MX28_INT_AUART0,
+		.end		= MX28_INT_AUART0,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+static struct resource		mxs_raw_auart1_resources[] = {
+	{
+		.start		=  MX28_AUART1_BASE_ADDR,
+		.end		=  MX28_AUART1_BASE_ADDR + 0x100 - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= MX28_INT_AUART1,
+		.end		= MX28_INT_AUART1,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+static const
+struct gpmi_nand_platform_data	ccu2_gpmi_nand_data __initconst = {
+	.min_prop_delay_in_ns	= 5,
+	.max_prop_delay_in_ns	= 9,
+	.max_chip_count		= 1,
+};
+
+static struct platform_device		ccu2_devices[] = {
+	{
+		.name		= "gpio-vbus",
+		.id		= -1,
+		.dev		= {
+			.platform_data	= &ccu2_otg_vbus_data,
+		},
+		.resource	= ccu2_otg_vbus_resources,
+		.num_resources	= ARRAY_SIZE(ccu2_otg_vbus_resources),
+	},
+	{
+		.name           = "reg-fixed-voltage",
+		.id             = 0,
+		.dev            = {
+			.platform_data  = &ccu2_lm26400_pwr_data[0],
+		},
+	}, {
+		.name           = "reg-fixed-voltage",
+		.id             = 1,
+		.dev            = {
+			.platform_data  = &ccu2_lm26400_pwr_data[1],
+		},
+	}, {
+		.name           = "reg-fixed-voltage",
+		.id             = 3,
+		.dev            = {
+			.platform_data  = &ccu2_usb1_pwr_data,
+		},
+	}, {
+		.name           = "reg-fixed-voltage",
+		.id             = 4,
+		.dev            = {
+			.platform_data  = &ccu2_ssp0_pwr_data,
+		},
+	}, {
+		.name		= "leds-gpio",
+		.id		= -1,
+		.dev		= {
+			.platform_data = &ccu2_led_data,
+		}
+	}, {
+		.name		= "gpio-keys",
+		.id		= -1,
+		.dev		= {
+			.platform_data = &ccu2_keys_data,
+		}
+	}, {
+		.name		=  "stmp3xxx-rtc",
+		.id		= -1,
+		.resource	= mx28_rtc_resources,
+		.num_resources	= ARRAY_SIZE(mx28_rtc_resources),
+	}, {
+		.name		= "fsl-usb2-otg",
+		.id		= -1,
+		.resource	= ccu2_ehci0_resources,
+		.num_resources	= ARRAY_SIZE(ccu2_ehci0_resources),
+		.dev		= {
+			.platform_data	= &ccu2_otg0_pdata,
+		}
+	},
+#if defined(CONFIG_SPI_EQ3SPI) || defined(CONFIG_SPI_EQ3SPI_MODULE)
+	{
+		.name		= "eq3spi",
+		.id		= 0,
+	},
+#endif
+#if defined(CONFIG_MXS_RAW_AUART) || defined(CONFIG_MXS_RAW_AUART_MODULE)
+    #if defined(CONFIG_MXS_RAW_AUART_PORT0)
+	{
+		.name		= "mxs-raw-auart",
+		.id		= 0,
+        .resource = mxs_raw_auart0_resources,
+		.num_resources	= ARRAY_SIZE(mxs_raw_auart0_resources),
+	},
+    #endif
+    #if defined(CONFIG_MXS_RAW_AUART_PORT1)
+	{
+		.name		= "mxs-raw-auart",
+		.id		= 1,
+        .resource = mxs_raw_auart1_resources,
+		.num_resources	= ARRAY_SIZE(mxs_raw_auart1_resources),
+	},
+    #endif
+#endif
+};
+
+static int __init ccu2_gpio_reserve(void)
+{
+	int	rc;
+
+	rc = gpio_request_array(ccu2_gpios, ARRAY_SIZE(ccu2_gpios));
+	WARN_ON(rc < 0);
+
+	return rc;
+}
+arch_initcall(ccu2_gpio_reserve);
+
+static struct platform_device		ccu2_ic200_device = {
+	.name		= "ccu2-ic200",
+	.id		= -1,
+};
+
+static int __init ccu2_create_ic200_device(void)
+{
+	dev_t			devt;
+	int			rc;
+
+	rc = alloc_chrdev_region(&devt, 0, 1, "ic200");
+	if (rc < 0) {
+		printk(KERN_ERR
+			"failed to allocate semaphore device: %d\n", rc);
+		devt = 0;
+		goto out;
+	}
+
+	ccu2_ic200_device.dev.devt = devt;
+	rc = platform_device_register(&ccu2_ic200_device);
+
+out:
+	return rc;
+}
+
+static struct clk	*fec_clk = NULL;
+
+static const iomux_cfg_t		ccu2_pads_fec_gpio[] = {
+	MX28_PAD_ENET0_RX_EN__GPIO_4_2    | CCU2_PAD8_PU,
+	MX28_PAD_ENET0_RXD0__GPIO_4_3     | CCU2_PAD8_PU,
+	MX28_PAD_ENET0_RXD1__GPIO_4_4     | CCU2_PAD8_PU,
+};
+
+static const iomux_cfg_t		ccu2_pads_fec_af[] = {
+	MX28_PAD_ENET0_RX_EN__ENET0_RX_EN | CCU2_PAD8_NOPU,
+	MX28_PAD_ENET0_RXD0__ENET0_RXD0   | CCU2_PAD8_NOPU,
+	MX28_PAD_ENET0_RXD1__ENET0_RXD1   | CCU2_PAD8_NOPU,
+};
+
+int fec_reset_phy(struct platform_device *pdev)
+{
+	int			rc;
+
+	if (fec_clk == NULL) {
+		fec_clk = clk_get_sys("pll2", NULL);
+		if (WARN_ON(IS_ERR(fec_clk)))
+			rc = PTR_ERR(fec_clk);
+		else
+			rc = clk_prepare_enable(fec_clk);
+
+		if (rc < 0)
+			goto out;
+	}
+
+	rc  = mxs_iomux_setup_multiple_pads(ccu2_pads_fec_gpio,
+					    ARRAY_SIZE(ccu2_pads_fec_gpio));
+	if (WARN_ON(rc < 0))
+		goto out;
+
+	gpio_direction_input(MXS_GPIO_NR(4,2));
+	gpio_direction_input(MXS_GPIO_NR(4,3));
+	gpio_direction_input(MXS_GPIO_NR(4,4));
+
+	gpio_direction_output(CCU2_ENET0_RST_GPIO, 0);
+	mdelay(10);
+	gpio_direction_output(CCU2_ENET0_RST_GPIO, 1);
+	mdelay(10);
+	gpio_direction_output(CCU2_ENET0_RST_GPIO, 0);
+
+	ndelay(50);			/* t_otaa */
+
+	gpio_direction_input(MXS_GPIO_NR(4,2));
+	gpio_direction_input(MXS_GPIO_NR(4,3));
+	gpio_direction_input(MXS_GPIO_NR(4,4));
+
+	mdelay(1);			/* t_rstia */
+
+	/* \todo: ensure that pins are driven for t_csh = 1ns but not more
+	 * than t_odad = 800ns */
+	gpio_direction_output(CCU2_ENET0_RST_GPIO, 1);
+
+	udelay(1);
+
+	rc  = mxs_iomux_setup_multiple_pads(ccu2_pads_fec_af,
+					    ARRAY_SIZE(ccu2_pads_fec_af));
+	if (WARN_ON(rc < 0))
+		goto out;
+
+	rc = 0;
+
+out:
+	return rc;
+}
+EXPORT_SYMBOL(fec_reset_phy);
+
+static void __init ccu2_init_gpmi(void)
+{
+	struct clk	*clk = clk_get_sys("imx28-gpmi-nand", NULL);
+
+	if (!WARN_ON(IS_ERR(clk))) {
+		WARN_ON(clk_set_rate(clk, 60000000) < 0);
+		clk_put(clk);
+	}
+
+	mx28_add_gpmi_nand(&ccu2_gpmi_nand_data);
+}
+
+static void __init ccu2_init(void)
+{
+	size_t			i;
+
+	mxs_iomux_setup_multiple_pads(ccu2_pads, ARRAY_SIZE(ccu2_pads));
+
+
+	for (i = 0; i < ARRAY_SIZE(ccu2_devices); ++i)
+		platform_device_register(&ccu2_devices[i]);
+
+	ccu2_create_ic200_device();
+
+	mx28_add_duart();
+#if (defined(CONFIG_MXS_RAW_AUART) || defined(CONFIG_MXS_RAW_AUART_MODULE))
+    #if !defined(CONFIG_MXS_RAW_AUART_PORT0)
+        mx28_add_auart0();
+    #endif
+    #if !defined(CONFIG_MXS_RAW_AUART_PORT1)
+        mx28_add_auart1();
+    #endif
+#else
+    mx28_add_auart0();
+    mx28_add_auart1();
+#endif
+    
+	ccu2_init_gpmi();
+	mx28_add_fec(0, &mx28_fec_pdata[0]);
+
+	mx28_add_mxs_mmc(0, &ccu2_mmc0_pdata);
+
+	mxs_add_mxs_usb_phy();
+
+	mxs_add_platform_device_dmamask("fsl-usb2-udc", 0,
+					ccu2_ehci0_resources,
+					ARRAY_SIZE(ccu2_ehci0_resources),
+					&ccu2_otg0_pdata,
+					sizeof ccu2_otg0_pdata,
+					DMA_BIT_MASK(32));
+
+	mxs_add_platform_device_dmamask("mxs-ehci", 1,
+					ccu2_ehci1_resources,
+					ARRAY_SIZE(ccu2_ehci1_resources),
+					&ccu2_ehci1_pdata,
+					sizeof ccu2_ehci1_pdata,
+					DMA_BIT_MASK(32));
+
+	mx28_add_mxs_i2c(0);
+	i2c_register_board_info(0, ccu2_i2c_boardinfo,
+				ARRAY_SIZE(ccu2_i2c_boardinfo));
+
+	spi_register_board_info(ccu2_spi_board_info,
+				ARRAY_SIZE(ccu2_spi_board_info));
+}
+
+static void __init ccu2_init_irq(void)
+{
+	mx28_init_irq();
+	irq_set_irq_type(CCU2_ENET0_INT_IRQ, IRQ_TYPE_LEVEL_LOW);
+}
+
+static void __init ccu2_timer_init(void)
+{
+	mx28_clocks_init();
+}
+
+static struct sys_timer ccu2_timer = {
+	.init	= ccu2_timer_init,
+};
+
+MACHINE_START(EQ3_CCU2, "eQ-3 HomeMatic CCU2")
+	.map_io		= mx28_map_io,
+	.init_irq	= ccu2_init_irq,
+	.init_machine	= ccu2_init,
+	.timer		= &ccu2_timer,
+	.restart	= mxs_restart,
+MACHINE_END
diff -Naur linux-3.4.11/arch/arm/mach-mxs/eq3-ccu2/ccu2-ocotp.c linux-HEAD/arch/arm/mach-mxs/eq3-ccu2/ccu2-ocotp.c
--- linux-3.4.11/arch/arm/mach-mxs/eq3-ccu2/ccu2-ocotp.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/eq3-ccu2/ccu2-ocotp.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,75 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/init.h>
+#include <linux/bug.h>
+#include <linux/moduleparam.h>
+#include <linux/errno.h>
+#include <mach/common.h>
+
+static char g_board_serial[11];
+static char g_ether_mac[6*3];
+static char g_radio_mac[4*3];
+
+module_param_string(board_serial, g_board_serial, sizeof g_board_serial, 0444);
+module_param_string(ether_mac,    g_ether_mac,    sizeof g_ether_mac,    0444);
+module_param_string(radio_mac,    g_radio_mac,    sizeof g_radio_mac,    0444);
+
+static int __init ccu2_read_ocotp(void)
+{
+	uint32_t const	*ocotp = mxs_get_ocotp();
+	size_t		i;
+
+	if (WARN_ON(!ocotp))
+		return -ETIMEDOUT;
+
+	sprintf(g_ether_mac, "%02x:%02x:%02x:%02x:%02x:%02x",
+		(ocotp[0] >> 24) & 0xff,	
+		(ocotp[0] >> 16) & 0xff,
+		(ocotp[0] >>  8) & 0xff,
+		(ocotp[0] >>  0) & 0xff,
+		(ocotp[1] >> 24) & 0xff,
+		(ocotp[1] >> 16) & 0xff);
+
+	g_board_serial[ 0] = (ocotp[1] >>  8) & 0xff;	
+	g_board_serial[ 1] = (ocotp[1] >>  0) & 0xff;
+	g_board_serial[ 2] = (ocotp[2] >> 24) & 0xff;
+	g_board_serial[ 3] = (ocotp[2] >> 16) & 0xff;
+	g_board_serial[ 4] = (ocotp[2] >>  8) & 0xff;
+	g_board_serial[ 5] = (ocotp[2] >>  0) & 0xff;
+	g_board_serial[ 6] = (ocotp[3] >> 24) & 0xff;
+	g_board_serial[ 7] = (ocotp[3] >> 16) & 0xff;
+	g_board_serial[ 8] = (ocotp[3] >>  8) & 0xff;
+	g_board_serial[ 9] = (ocotp[3] >>  0) & 0xff;
+	g_board_serial[10] = '\0';
+
+	for (i = 0; i+1 < ARRAY_SIZE(g_board_serial); ++i) {
+		/* when non-printable character, the board serial is
+		 * invalid */
+		if (g_board_serial[i] < ' ' || g_board_serial[i] > 127) {
+			g_board_serial[0] = '\0';
+			break;
+		}
+	}
+
+	sprintf(g_radio_mac, "0x%06x\n",
+		(((ocotp[0x15] >> 24) << 16) |
+		 ((ocotp[0x15] >> 16) <<  8) |
+		 ((ocotp[0x15] >>  8) <<  0)));
+
+	return 0;
+}
+late_initcall(ccu2_read_ocotp);
diff -Naur linux-3.4.11/arch/arm/mach-mxs/eq3-ccu2/ic200-spi.c linux-HEAD/arch/arm/mach-mxs/eq3-ccu2/ic200-spi.c
--- linux-3.4.11/arch/arm/mach-mxs/eq3-ccu2/ic200-spi.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/eq3-ccu2/ic200-spi.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,220 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/err.h>
+#include <linux/pm_runtime.h>
+
+#include <mach/mxs.h>
+#include <mach/eq3-ccu2.h>
+
+
+enum {
+	IC200_RST_ASSERT = 1,
+	IC200_RST_DEASSERT = 0,
+};
+
+enum {
+	IC200_FLAG_SPI,
+};
+
+struct ic200_device {
+	struct device		*dev;
+	unsigned long		flags;
+	int			cs_gpio;
+	struct cdev		sem_cdev;
+};
+
+static int ic200_open(struct inode *ino, struct file *filp)
+{
+	struct ic200_device	*ic =
+		container_of(ino->i_cdev, struct ic200_device, sem_cdev);
+	int			rc;
+
+	if (test_and_set_bit(IC200_FLAG_SPI, &ic->flags))
+		return -EBUSY;
+
+	/* step 1: assert reset; this state might not be stable because SCK
+	 * level is unknown at this point */
+	gpio_set_value(IC200_nRESET_GPIO, IC200_RST_ASSERT);
+	udelay(1);
+
+	/* step 2: configure SPI gpios */
+	if ((rc = gpio_direction_input(IC200_MISO_GPIO)) < 0 ||
+	    (rc = gpio_direction_output(IC200_MOSI_GPIO, 0)) < 0 ||
+	    (rc = gpio_direction_output(IC200_SCK_GPIO, 0)) < 0) {
+		dev_err(ic->dev, "failed to configure some spi gpio: %d\n",
+			rc);
+		goto err_gpio;
+	}
+	udelay(1);
+
+	/* step 3: leave reset for a short time */
+	gpio_set_value(IC200_nRESET_GPIO, IC200_RST_DEASSERT);
+	udelay(1);
+
+	/* step 4: enter reset again; SCK has a defined state now */
+	gpio_set_value(IC200_nRESET_GPIO, IC200_RST_ASSERT);
+
+	filp->private_data = ic;
+
+	return 0;
+
+err_gpio:
+	gpio_direction_input(IC200_SCK_GPIO);
+	gpio_direction_input(IC200_MOSI_GPIO);
+	gpio_direction_input(IC200_MISO_GPIO);
+
+	gpio_set_value(IC200_nRESET_GPIO, IC200_RST_DEASSERT);
+
+
+	clear_bit(IC200_FLAG_SPI, &ic->flags);
+	return rc;
+}
+
+static int ic200_release(struct inode *ino, struct file *filp)
+{
+	struct ic200_device	*ic =
+		container_of(ino->i_cdev, struct ic200_device, sem_cdev);
+
+	WARN_ON(!test_bit(IC200_FLAG_SPI, &ic->flags));
+
+	gpio_direction_input(IC200_SCK_GPIO);
+	gpio_direction_input(IC200_MOSI_GPIO);
+	gpio_direction_input(IC200_MISO_GPIO);
+
+	gpio_set_value(IC200_nRESET_GPIO, IC200_RST_DEASSERT);
+
+	clear_bit(IC200_FLAG_SPI, &ic->flags);
+
+	return 0;
+}
+
+static long ic200_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct ic200_device	*ic = filp->private_data;
+
+	switch (cmd) {
+	case 0:
+		gpio_set_value(IC200_nRESET_GPIO, IC200_RST_DEASSERT);
+		udelay(1);
+		gpio_set_value(IC200_nRESET_GPIO, IC200_RST_ASSERT);
+		break;
+	}
+
+	return 0;
+}
+
+static struct file_operations	ic200_semcdev_fops = {
+	.open		=  ic200_open,
+	.release	=  ic200_release,
+	.unlocked_ioctl	=  ic200_ioctl,
+};
+
+static int __devinit ic200_probe(struct platform_device *pdev)
+{
+	struct ic200_device	*ic;
+	int			rc;
+
+	ic = kzalloc(sizeof *ic, GFP_KERNEL);
+	if (!ic)
+		return -ENOMEM;
+
+	ic->cs_gpio = -1;
+	ic->dev = &pdev->dev;
+
+	platform_set_drvdata(pdev, ic);
+
+	cdev_init(&ic->sem_cdev, &ic200_semcdev_fops);
+	ic->sem_cdev.dev = ic->dev->devt;
+	ic->sem_cdev.owner = THIS_MODULE;
+
+	rc = gpio_request(IC200_nRESET_GPIO, "IC200-nRST");
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to request cs gpio: %d\n", rc);
+		goto err;
+	}
+
+	ic->cs_gpio = IC200_nRESET_GPIO;
+	rc = gpio_direction_output(ic->cs_gpio, IC200_RST_DEASSERT);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to configure cs as output: %d\n",
+			rc);
+		goto err;
+	}
+
+	rc = cdev_add(&ic->sem_cdev, ic->sem_cdev.dev, 1);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to add semaphore device: %d\n",
+			rc);
+		goto err;
+	}
+
+	gpio_export(IC200_nRESET_GPIO, false);
+	gpio_export(IC200_MISO_GPIO, true);
+	gpio_export(IC200_MOSI_GPIO, true);
+	gpio_export(IC200_SCK_GPIO, true);
+	gpio_export(85, false);
+
+	pm_runtime_enable(&pdev->dev);
+
+	return 0;
+
+err:
+	if (ic->cs_gpio >= 0) {
+		gpio_set_value(ic->cs_gpio, 1);
+		gpio_free(ic->cs_gpio);
+	}
+
+	return rc;
+}
+
+static int __devexit ic200_remove(struct platform_device *pdev)
+{
+	struct ic200_device	*ic = platform_get_drvdata(pdev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	WARN_ON(test_bit(IC200_FLAG_SPI, &ic->flags));
+
+	cdev_del(&ic->sem_cdev);
+	gpio_set_value(ic->cs_gpio, 1);
+	gpio_free(ic->cs_gpio);
+
+	kfree(ic);
+
+	return 0;
+}
+
+static struct platform_driver	ic200_driver = {
+	.driver		=  {
+		.name	=  "ccu2-ic200",
+		.owner	=  THIS_MODULE,
+	},
+	.probe		=  ic200_probe,
+	.remove		=  __devexit_p(ic200_remove),
+};
+
+module_platform_driver(ic200_driver);
+MODULE_ALIAS("platform:ccu2-ic200");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.4.11/arch/arm/mach-mxs/eq3-ccu2/Kconfig linux-HEAD/arch/arm/mach-mxs/eq3-ccu2/Kconfig
--- linux-3.4.11/arch/arm/mach-mxs/eq3-ccu2/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/eq3-ccu2/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,30 @@
+choice
+       prompt "Select variant of EQ3 CCU2"
+
+config MACH_EQ3_CCU2_DEFAULT
+       bool "default"
+       select MXS_HAVE_AMBA_DUART
+       select MXS_HAVE_PLATFORM_FEC
+       select MXS_HAVE_PLATFORM_AUART
+       select MXS_HAVE_PLATFORM_MXS_MMC
+       select MXS_HAVE_PLATFORM_MXS_I2C
+       select MXS_HAVE_PLATFORM_GPMI_NAND
+       select MXS_OCOTP
+
+endchoice
+
+choice
+       prompt "Select SPI implementation"
+
+config SPI_EQ3SPI
+       tristate "GPIO bitbang"
+       depends on SPI
+       select SPI_BITBANG
+
+endchoice
+
+config PLAT_EQ3_IC200_DEVICE
+       tristate "IC200 semaphore device"
+
+config PLAT_EQ3_RESCUE_MODE
+       bool "rescue mode"
diff -Naur linux-3.4.11/arch/arm/mach-mxs/eq3-ccu2/Makefile linux-HEAD/arch/arm/mach-mxs/eq3-ccu2/Makefile
--- linux-3.4.11/arch/arm/mach-mxs/eq3-ccu2/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/eq3-ccu2/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,4 @@
+obj-y += plat_eq3ccu2.o
+obj-$(CONFIG_PLAT_EQ3_IC200_DEVICE) += ic200-spi.o
+
+plat_eq3ccu2-objs = ccu2.o ccu2-bootloader.o ccu2-ocotp.o
diff -Naur linux-3.4.11/arch/arm/mach-mxs/include/mach/eq3-ccu2.h linux-HEAD/arch/arm/mach-mxs/include/mach/eq3-ccu2.h
--- linux-3.4.11/arch/arm/mach-mxs/include/mach/eq3-ccu2.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/include/mach/eq3-ccu2.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,25 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_LINUX_ARCH_ARM_MACH_MXS_MACH_EQ3_CCU2_H
+#define H_LINUX_ARCH_ARM_MACH_MXS_MACH_EQ3_CCU2_H
+
+#define IC200_nRESET_GPIO	MXS_GPIO_NR(2, 20)
+#define	IC200_MOSI_GPIO		MXS_GPIO_NR(2, 17)
+#define IC200_MISO_GPIO		MXS_GPIO_NR(2, 18)
+#define IC200_SCK_GPIO		MXS_GPIO_NR(2, 16)
+
+#endif	/* H_LINUX_ARCH_ARM_MACH_MXS_MACH_EQ3_CCU2_H */
diff -Naur linux-3.4.11/arch/arm/mach-mxs/include/mach/mxs_ehci.h linux-HEAD/arch/arm/mach-mxs/include/mach/mxs_ehci.h
--- linux-3.4.11/arch/arm/mach-mxs/include/mach/mxs_ehci.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/include/mach/mxs_ehci.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,144 @@
+#ifndef __INCLUDE_ASM_ARCH_MXS_EHCI_H
+#define __INCLUDE_ASM_ARCH_MXS_EHCI_H
+
+#include <mach/mxs.h>
+
+/* values for portsc field */
+#define MXS_EHCI_PHY_LOW_POWER_SUSPEND	(1 << 23)
+#define MXS_EHCI_FORCE_FS		(1 << 24)
+#define MXS_EHCI_UTMI_8BIT		(0 << 28)
+#define MXS_EHCI_UTMI_16BIT		(1 << 28)
+#define MXS_EHCI_MODE_UTMI		((0 << 25) | (0 << 30))
+#define MXS_EHCI_MODE_PHILIPS		((0 << 25) | (1 << 30))
+#define MXS_EHCI_MODE_ULPI		((0 << 25) | (2 << 30))
+#define MXS_EHCI_MODE_SERIAL		((0 << 25) | (3 << 30))
+#define MXS_EHCI_MODE_HSIC		((1 << 25) | (0 << 30))
+
+#define MXS_EHCI_PSPD_FULL		((0 << 26) | (0 << 9))
+#define MXS_EHCI_PSPD_LOW		((1 << 26) | (0 << 9))
+#define MXS_EHCI_PSPD_HIGH		((2 << 26) | (1 << 9))
+
+/* values for flags field */
+#define MXS_EHCI_INTERFACE_DIFF_UNI	(0 << 0)
+#define MXS_EHCI_INTERFACE_DIFF_BI	(1 << 0)
+#define MXS_EHCI_INTERFACE_SINGLE_UNI	(2 << 0)
+#define MXS_EHCI_INTERFACE_SINGLE_BI	(3 << 0)
+#define MXS_EHCI_INTERFACE_MASK		(0xf)
+
+#define MXS_EHCI_POWER_PINS_ENABLED	(1 << 5)
+#define MXS_EHCI_TTL_ENABLED		(1 << 6)
+
+#define MXS_EHCI_INTERNAL_PHY		(1 << 7)
+#define MXS_EHCI_IPPUE_DOWN		(1 << 8)
+#define MXS_EHCI_IPPUE_UP		(1 << 9)
+#define MXS_EHCI_WAKEUP_ENABLED	(1 << 10)
+#define MXS_EHCI_ITC_NO_THRESHOLD	(1 << 11)
+
+#define MXS_USBCTRL_OFFSET		0
+#define MXS_USB_PHY_CTR_FUNC_OFFSET	0x8
+#define MXS_USB_PHY_CTR_FUNC2_OFFSET	0xc
+#define MXS_USBH2CTRL_OFFSET		0x14
+
+#define MXS_USBPHY_PWD			0x00
+
+
+#define MXS_USBPHY_CTRL			0x30
+#define MXS_USBPHY_CTRL_set		0x34
+#define MXS_USBPHY_CTRL_clr		0x38
+#define MXS_USBPHY_CTRL_tog		0x3c
+
+#define MXS_USBPHY_CTRL_SFTRST			(1u << 31)
+#define MXS_USBPHY_CTRL_CLKGATE			(1u << 30)
+#define MXS_USBPHY_CTRL_UTMI_SUSPENDM		(1u << 29)
+#define MXS_USBPHY_CTRL_ENAUTOSET_USBCLKS	(1u << 26)
+#define MXS_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE	(1u << 25)
+#define MXS_USBPHY_CTRL_ENVBUSCHG_WKUP		(1u << 23)
+#define MXS_USBPHY_CTRL_ENIDCHG_WKUP		(1u << 22)
+#define MXS_USBPHY_CTRL_ENDPDMCHG_WKUP		(1u << 21)
+#define MXS_USBPHY_CTRL_ENAUTOCLR_PHY_PWD	(1u << 20)
+#define MXS_USBPHY_CTRL_ENAUTOCLR_CLKGATE	(1u << 19)
+#define MXS_USBPHY_CTRL_ENAUTO_PWRON_PLL	(1u << 18)
+#define MXS_USBPHY_CTRL_ENIRQWAKEUP		(1u << 16)
+#define MXS_USBPHY_CTRL_ENUTMILEVEL3		(1u << 15)
+#define MXS_USBPHY_CTRL_ENUTMILEVEL2		(1u << 14)
+#define MXS_USBPHY_CTRL_WAKEUP_IRQ		(1u << 17)
+#define MXS_USBPHY_CTRL_RESUME_IRQ		(1u << 10)
+#define MXS_USBPHY_CTRL_DEVPLUGIN_POLARITY	(1u <<  5)
+#define MXS_USBPHY_CTRL_ENDEVPLUGINDETECT	(1u <<  4)
+
+struct regulator;
+struct platform_device;
+
+struct mxs_usbh_platform_data {
+	int (*init)(struct platform_device *pdev,
+		    void __iomem *io_ctrl, void __iomem *io_phy);
+	int (*exit)(struct platform_device *pdev,
+		    void __iomem *io_ctrl, void __iomem *io_phy);
+
+	unsigned int		 portsc;
+	struct usb_phy		*otg;
+	struct regulator	*supply;
+};
+
+enum mxs_usb_phy_mode {
+	MXS_USB_PHY_MODE_HOST,
+	MXS_USB_PHY_MODE_CLIENT,
+
+	_mxs_usb_phy_mode_max
+};
+
+struct mxs_usb_phy_user {
+	enum mxs_usb_phy_mode	mode;
+};
+
+struct mxs_usb_phy {
+	void __iomem	*addr;
+
+	void	(*put)(struct mxs_usb_phy *);
+	int	(*reset)(struct mxs_usb_phy *, int force);
+	int	(*clk_enable)(struct mxs_usb_phy *);
+	int	(*clk_disable)(struct mxs_usb_phy *);
+	int	(*enable)(struct mxs_usb_phy *);
+};
+
+struct mxs_usb_phy *mxs_usb_phy_get(unsigned int idx,
+				    struct mxs_usb_phy_user *);
+
+int mxs_add_mxs_usb_phy(void);
+
+inline static void mxs_usb_phy_put(struct mxs_usb_phy *phy)
+{
+	phy->put(phy);
+}
+
+inline static int mxs_usb_phy_reset(struct mxs_usb_phy *phy, int force)
+{
+	return phy->reset(phy, force);
+}
+
+inline static int mxs_usb_phy_enable(struct mxs_usb_phy *phy)
+{
+	return phy->enable(phy);
+}
+
+inline static int mxs_usb_phy_clk_enable(struct mxs_usb_phy *phy)
+{
+	return phy->clk_enable(phy);
+}
+
+inline static int mxs_usb_phy_clk_disable(struct mxs_usb_phy *phy)
+{
+	return phy->clk_disable(phy);
+}
+
+inline static void mxs_ehci_writel(unsigned int val, void __iomem *regs)
+{
+#if defined(CONFIG_USB_WORKAROUND_MX28)
+	__asm__ __volatile__("swp	%0, %0, [%1]"
+			     : "+r" (val) : "r" (regs));
+#else
+	writel(val, regs);
+#endif
+}
+
+#endif /* __INCLUDE_ASM_ARCH_MXS_EHCI_H */
diff -Naur linux-3.4.11/arch/arm/mach-mxs/include/mach/mxs.h linux-HEAD/arch/arm/mach-mxs/include/mach/mxs.h
--- linux-3.4.11/arch/arm/mach-mxs/include/mach/mxs.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/include/mach/mxs.h	2015-11-18 09:04:24.000000000 +0000
@@ -27,6 +27,7 @@
 #include <mach/hardware.h>
 
 /*
+		machine_is_elv_ccu2() ||				\
  * IO addresses common to MXS-based
  */
 #define MXS_IO_BASE_ADDR		0x80000000
diff -Naur linux-3.4.11/arch/arm/mach-mxs/Kconfig linux-HEAD/arch/arm/mach-mxs/Kconfig
--- linux-3.4.11/arch/arm/mach-mxs/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -107,4 +107,16 @@
 	bool "Support Bluegiga APX4 Development Kit"
 	select MODULE_APX4
 
+config MACH_EQ3_CCU2
+	bool "EQ3 CCU2 platform"
+	select SOC_IMX28
+
+config USB_WORKAROUND_MX28
+       bool
+       default y if SOC_IMX28
+
+if MACH_EQ3_CCU2
+source "arch/arm/mach-mxs/eq3-ccu2/Kconfig"
+endif
+
 endif
diff -Naur linux-3.4.11/arch/arm/mach-mxs/Makefile linux-HEAD/arch/arm/mach-mxs/Makefile
--- linux-3.4.11/arch/arm/mach-mxs/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -14,5 +14,6 @@
 obj-$(CONFIG_MACH_APX4DEVKIT) += mach-apx4devkit.o
 obj-$(CONFIG_MODULE_TX28) += module-tx28.o
 obj-$(CONFIG_MACH_TX28)    += mach-tx28.o
+obj-$(CONFIG_MACH_EQ3_CCU2) += eq3-ccu2/
 
 obj-y += devices/
diff -Naur linux-3.4.11/arch/arm/mach-mxs/regs-clkctrl-mx28.h linux-HEAD/arch/arm/mach-mxs/regs-clkctrl-mx28.h
--- linux-3.4.11/arch/arm/mach-mxs/regs-clkctrl-mx28.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-mxs/regs-clkctrl-mx28.h	2015-11-18 09:04:24.000000000 +0000
@@ -55,6 +55,8 @@
 #define BV_CLKCTRL_PLL0CTRL0_DIV_SEL__LOWER     0x1
 #define BV_CLKCTRL_PLL0CTRL0_DIV_SEL__LOWEST    0x2
 #define BV_CLKCTRL_PLL0CTRL0_DIV_SEL__UNDEFINED 0x3
+
+#define BP_CLKCTRL_PLL0CTRL0_EN_USB_CLKS	18
 #define BM_CLKCTRL_PLL0CTRL0_EN_USB_CLKS	0x00040000
 #define BM_CLKCTRL_PLL0CTRL0_POWER	0x00020000
 
@@ -97,6 +99,8 @@
 #define BV_CLKCTRL_PLL1CTRL0_DIV_SEL__LOWER     0x1
 #define BV_CLKCTRL_PLL1CTRL0_DIV_SEL__LOWEST    0x2
 #define BV_CLKCTRL_PLL1CTRL0_DIV_SEL__UNDEFINED 0x3
+
+#define BP_CLKCTRL_PLL1CTRL0_EN_USB_CLKS	18
 #define BM_CLKCTRL_PLL1CTRL0_EN_USB_CLKS	0x00040000
 #define BM_CLKCTRL_PLL1CTRL0_POWER	0x00020000
 
diff -Naur linux-3.4.11/arch/arm/mach-pxa/cpufreq-pxa2xx.c linux-HEAD/arch/arm/mach-pxa/cpufreq-pxa2xx.c
--- linux-3.4.11/arch/arm/mach-pxa/cpufreq-pxa2xx.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/cpufreq-pxa2xx.c	2015-11-18 09:04:24.000000000 +0000
@@ -158,7 +158,7 @@
 static pxa_freqs_t pxa27x_freqs[] = {
 	{104000, 104000, PXA27x_CCCR(1,	 8, 2), 0, CCLKCFG2(1, 0, 1),  900000, 1705000 },
 	{156000, 104000, PXA27x_CCCR(1,	 8, 3), 0, CCLKCFG2(1, 0, 1), 1000000, 1705000 },
-	{208000, 208000, PXA27x_CCCR(0, 16, 2), 1, CCLKCFG2(0, 0, 1), 1180000, 1705000 },
+	{208000, 208000, PXA27x_CCCR(1, 16, 2), 1, CCLKCFG2(0, 0, 1), 1180000, 1705000 },
 	{312000, 208000, PXA27x_CCCR(1, 16, 3), 1, CCLKCFG2(1, 0, 1), 1250000, 1705000 },
 	{416000, 208000, PXA27x_CCCR(1, 16, 4), 1, CCLKCFG2(1, 0, 1), 1350000, 1705000 },
 	{520000, 208000, PXA27x_CCCR(1, 16, 5), 1, CCLKCFG2(1, 0, 1), 1450000, 1705000 },
@@ -233,7 +233,7 @@
 static void pxa27x_guess_max_freq(void)
 {
 	if (!pxa27x_maxfreq) {
-		pxa27x_maxfreq = 416000;
+		pxa27x_maxfreq = get_clk_frequency_khz(0);
 		printk(KERN_INFO "PXA CPU 27x max frequency not defined "
 		       "(pxa27x_maxfreq), assuming pxa271 with %dkHz maxfreq\n",
 		       pxa27x_maxfreq);
diff -Naur linux-3.4.11/arch/arm/mach-pxa/devices.c linux-HEAD/arch/arm/mach-pxa/devices.c
--- linux-3.4.11/arch/arm/mach-pxa/devices.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/devices.c	2015-11-18 09:04:24.000000000 +0000
@@ -16,7 +16,7 @@
 #include <mach/ohci.h>
 #include <plat/pxa27x_keypad.h>
 #include <mach/camera.h>
-#include <mach/audio.h>
+#include <plat/audio.h>
 #include <mach/hardware.h>
 #include <plat/pxa3xx_nand.h>
 
@@ -447,15 +447,39 @@
 };
 
 static struct resource pxa_ac97_resources[] = {
-	[0] = {
+	{
 		.start  = 0x40500000,
 		.end	= 0x40500000 + 0xfff,
 		.flags  = IORESOURCE_MEM,
-	},
-	[1] = {
+	}, {
 		.start  = IRQ_AC97,
 		.end    = IRQ_AC97,
 		.flags  = IORESOURCE_IRQ,
+	}, {
+		.name	= PXA_AC97_DMA_CH_PCM_TX,
+		.start	= 12,
+		.end	= 12,
+		.flags	= IORESOURCE_DMA,
+	}, {
+		.name	= PXA_AC97_DMA_CH_PCM_RX,
+		.start	= 11,
+		.end	= 11,
+		.flags	= IORESOURCE_DMA,
+	}, {
+		.name	= PXA_AC97_DMA_CH_PCM_MODEM_TX,
+		.start	= 10,
+		.end	= 10,
+		.flags	= IORESOURCE_DMA,
+	}, {
+		.name	= PXA_AC97_DMA_CH_PCM_MODEM_RX,
+		.start	= 9,
+		.end	= 9,
+		.flags	= IORESOURCE_DMA,
+	}, {
+		.name	= PXA_AC97_DMA_CH_PCM_MIC,
+		.start	= 8,
+		.end	= 8,
+		.flags	= IORESOURCE_DMA,
 	},
 };
 
diff -Naur linux-3.4.11/arch/arm/mach-pxa/include/mach/debug-macro.S linux-HEAD/arch/arm/mach-pxa/include/mach/debug-macro.S
--- linux-3.4.11/arch/arm/mach-pxa/include/mach/debug-macro.S	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/include/mach/debug-macro.S	2015-11-18 09:04:24.000000000 +0000
@@ -14,7 +14,11 @@
 #include "hardware.h"
 
 		.macro	addruart, rp, rv, tmp
+#ifdef CONFIG_LLUART_OFFSET
+		mov	\rp, #CONFIG_LLUART_OFFSET
+#else
 		mov	\rp, #0x00100000
+#endif
 		orr	\rv, \rp, #io_p2v(0x40000000)	@ virtual
 		orr	\rp, \rp, #0x40000000		@ physical
 		.endm
diff -Naur linux-3.4.11/arch/arm/mach-pxa/include/mach/mfp-pxa2xx.h linux-HEAD/arch/arm/mach-pxa/include/mach/mfp-pxa2xx.h
--- linux-3.4.11/arch/arm/mach-pxa/include/mach/mfp-pxa2xx.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/include/mach/mfp-pxa2xx.h	2015-11-18 09:04:24.000000000 +0000
@@ -136,7 +136,8 @@
 #define GPIO83_GPIO	MFP_CFG_IN(GPIO83, AF0)
 #define GPIO84_GPIO	MFP_CFG_IN(GPIO84, AF0)
 
-extern void pxa2xx_mfp_config(unsigned long *mfp_cfgs, int num);
+extern void pxa2xx_mfp_config(unsigned long const mfp_cfgs[], int num);
 extern void pxa2xx_mfp_set_lpm(int mfp, unsigned long lpm);
+extern void pxa2xx_mfp_cfg_wake(int mfp, unsigned long wake);
 extern int gpio_set_wake(unsigned int gpio, unsigned int on);
 #endif /* __ASM_ARCH_MFP_PXA2XX_H */
diff -Naur linux-3.4.11/arch/arm/mach-pxa/include/mach/mfp-pxa320.h linux-HEAD/arch/arm/mach-pxa/include/mach/mfp-pxa320.h
--- linux-3.4.11/arch/arm/mach-pxa/include/mach/mfp-pxa320.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/include/mach/mfp-pxa320.h	2015-11-18 09:04:24.000000000 +0000
@@ -448,7 +448,6 @@
 #define GPIO14_CHOUT1		MFP_CFG(GPIO14, AF6)
 
 #define GPIO2_RDY		MFP_CFG(GPIO2, AF1)
-#define GPIO5_NPIOR		MFP_CFG(GPIO5, AF3)
 #define GPIO6_NPIOW		MFP_CFG(GPIO6, AF3)
 #define GPIO7_NPIOS16		MFP_CFG(GPIO7, AF3)
 #define GPIO8_NPWAIT		MFP_CFG(GPIO8, AF3)
@@ -458,4 +457,42 @@
 #define GPIO13_PWM2_OUT		MFP_CFG(GPIO13, AF1)
 #define GPIO14_PWM3_OUT		MFP_CFG(GPIO14, AF1)
 
+/* DFI - NAND */
+#define DF_CLE_nOE_ND_CLE	MFP_CFG_LPM(DF_CLE_nOE, AF0, PULL_HIGH)
+#define DF_INT_RnB_ND_INT_RnB	MFP_CFG_LPM(DF_INT_RnB, AF0, PULL_LOW)
+#define DF_IO0_ND_IO0		MFP_CFG_LPM(DF_IO0, AF1, PULL_LOW)
+#define DF_IO1_ND_IO1		MFP_CFG_LPM(DF_IO1, AF1, PULL_LOW)
+#define DF_IO2_ND_IO2		MFP_CFG_LPM(DF_IO2, AF1, PULL_LOW)
+#define DF_IO3_ND_IO3		MFP_CFG_LPM(DF_IO3, AF1, PULL_LOW)
+#define DF_IO4_ND_IO4		MFP_CFG_LPM(DF_IO4, AF1, PULL_LOW)
+#define DF_IO5_ND_IO5		MFP_CFG_LPM(DF_IO5, AF1, PULL_LOW)
+#define DF_IO6_ND_IO6		MFP_CFG_LPM(DF_IO6, AF1, PULL_LOW)
+#define DF_IO7_ND_IO7		MFP_CFG_LPM(DF_IO7, AF1, PULL_LOW)
+#define DF_IO8_ND_IO8		MFP_CFG_LPM(DF_IO8, AF1, PULL_LOW)
+#define DF_IO9_ND_IO9		MFP_CFG_LPM(DF_IO9, AF1, PULL_LOW)
+#define DF_IO10_ND_IO10		MFP_CFG_LPM(DF_IO10, AF1, PULL_LOW)
+#define DF_IO11_ND_IO11		MFP_CFG_LPM(DF_IO11, AF1, PULL_LOW)
+#define DF_IO12_ND_IO12		MFP_CFG_LPM(DF_IO12, AF1, PULL_LOW)
+#define DF_IO13_ND_IO13		MFP_CFG_LPM(DF_IO13, AF1, PULL_LOW)
+#define DF_IO14_ND_IO14		MFP_CFG_LPM(DF_IO14, AF1, PULL_LOW)
+#define DF_IO15_ND_IO15		MFP_CFG_LPM(DF_IO15, AF1, PULL_LOW)
+#define DF_nADV1_ALE_CD_ADV1	MFP_CFG_LPM(DF_nADV1_ALE, AF0, PULL_HIGH)
+#define DF_nADV1_ALE_ND_ALE	MFP_CFG_LPM(DF_nADV1_ALE, AF1, PULL_HIGH)
+#define DF_nADV2_ALE_CD_ADV1	MFP_CFG_LPM(DF_nADV2_ALE, AF0, PULL_HIGH)
+#define DF_nADV2_ALE_ND_ALE	MFP_CFG_LPM(DF_nADV2_ALE, AF1, PULL_HIGH)
+#define DF_nCS0_DF_nCS0		MFP_CFG_LPM(DF_nCS0, AF0, PULL_HIGH)
+#define DF_nCS0_ND_nCS0		MFP_CFG_LPM(DF_nCS0, AF1, PULL_HIGH)
+#define DF_nCS1_DF_nCS1		MFP_CFG_LPM(DF_nCS1, AF0, PULL_HIGH)
+#define DF_nCS1_ND_nCS1		MFP_CFG_LPM(DF_nCS1, AF1, PULL_HIGH)
+#define DF_nRE_nOE_CD_nOE	MFP_CFG_LPM(DF_nRE_nOE, AF0, PULL_HIGH)
+#define DF_nRE_nOE_ND_nRE	MFP_CFG_LPM(DF_nRE_nOE, AF1, PULL_HIGH)
+#define DF_nWE_CD_nWE		MFP_CFG_LPM(DF_nWE, AF0, PULL_HIGH)
+#define DF_nWE_ND_nWE		MFP_CFG_LPM(DF_nWE, AF1, PULL_HIGH)
+
+/* PCCard */
+#define GPIO5_nPIOR		MFP_CFG(GPIO5, AF3)
+#define GPIO6_nPIOW		MFP_CFG(GPIO6, AF3)
+#define GPIO7_nIOIS16		MFP_CFG(GPIO7, AF3)
+#define GPIO8_nPWAIT		MFP_CFG(GPIO8, AF3)
+
 #endif /* __ASM_ARCH_MFP_PXA320_H */
diff -Naur linux-3.4.11/arch/arm/mach-pxa/include/mach/mfp-pxa3xx.h linux-HEAD/arch/arm/mach-pxa/include/mach/mfp-pxa3xx.h
--- linux-3.4.11/arch/arm/mach-pxa/include/mach/mfp-pxa3xx.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/include/mach/mfp-pxa3xx.h	2015-11-18 09:04:24.000000000 +0000
@@ -63,6 +63,7 @@
 #define GPIO55_GPIO		MFP_CFG(GPIO55, AF0)
 
 #define GPIO57_GPIO		MFP_CFG(GPIO57, AF0)
+#define GPIO58_GPIO		MFP_CFG(GPIO58, AF0)
 
 #define GPIO63_GPIO		MFP_CFG(GPIO63, AF0)
 #define GPIO64_GPIO		MFP_CFG(GPIO64, AF0)
@@ -151,7 +152,7 @@
 	mfp_write(mfp, val);
 }
 
-static inline void pxa3xx_mfp_config(unsigned long *mfp_cfg, int num)
+static inline void pxa3xx_mfp_config(unsigned long const *mfp_cfg, int num)
 {
 	mfp_config(mfp_cfg, num);
 }
diff -Naur linux-3.4.11/arch/arm/mach-pxa/include/mach/pxa27x.h linux-HEAD/arch/arm/mach-pxa/include/mach/pxa27x.h
--- linux-3.4.11/arch/arm/mach-pxa/include/mach/pxa27x.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/include/mach/pxa27x.h	2015-11-18 09:04:24.000000000 +0000
@@ -7,6 +7,12 @@
 #include <mach/mfp-pxa27x.h>
 #include <mach/irqs.h>
 
+#define ICMR		__REG(0x40d00004) /* Interrupt Controller Mask Register */
+#define ICLR		__REG(0x40d00008) /* Interrupt Controller Level Register */
+#define ICCR		__REG(0x40d00014) /* Interrupt Controller Control Register */
+#define ICMR2		__REG(0x40d000a0) /* Interrupt Controller Mask Register 2 */
+#define ICLR2		__REG(0x40d000a4) /* Interrupt Controller Level Register 2 */
+
 #define ARB_CNTRL	__REG(0x48000048)  /* Arbiter Control Register */
 
 #define ARB_DMA_SLV_PARK	(1<<31)	   /* Be parked with DMA slave when idle */
diff -Naur linux-3.4.11/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h linux-HEAD/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h
--- linux-3.4.11/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/include/mach/pxa2xx-regs.h	2015-11-18 09:04:24.000000000 +0000
@@ -38,6 +38,7 @@
 #define PSTR		__REG(0x40F00038)	/* Power Manager Standby Config Register */
 #define PSNR		__REG(0x40F0003C)	/* Power Manager Sense Config Register */
 #define PVCR		__REG(0x40F00040)	/* Power Manager VoltageControl Register */
+#define PUCR		__REG(0x40F0004C)	/* Power Manager VoltageControl Register */
 #define PKWR		__REG(0x40F00050)	/* Power Manager KB Wake-up Enable Reg */
 #define PKSR		__REG(0x40F00054)	/* Power Manager KB Level-Detect Register */
 #define PCMD(x)	__REG2(0x40F00080, (x)<<2)
@@ -92,6 +93,7 @@
 #define PSSR_BFS	(1 << 1)	/* Battery Fault Status */
 #define PSSR_SSS	(1 << 0)	/* Software Sleep Status */
 
+#define PSLR_IVF	(1 << 22)	/* Ignore nVDD_FAULT in Sleep Mode and Deep-Sleep Mode */
 #define PSLR_SL_ROD	(1 << 20)	/* Sleep-Mode/Depp-Sleep Mode nRESET_OUT Disable */
 
 #define PCFR_RO		(1 << 15)	/* RDH Override */
diff -Naur linux-3.4.11/arch/arm/mach-pxa/include/mach/pxa3xx-regs.h linux-HEAD/arch/arm/mach-pxa/include/mach/pxa3xx-regs.h
--- linux-3.4.11/arch/arm/mach-pxa/include/mach/pxa3xx-regs.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/include/mach/pxa3xx-regs.h	2015-11-18 09:04:24.000000000 +0000
@@ -202,4 +202,8 @@
 #define CKEN_PXA300_GCU		42	/* Graphics controller clock enable */
 #define CKEN_PXA320_GCU		7	/* Graphics controller clock enable */
 
+#define GSDR(x)		__REG2(0x40E00400, ((x) & 0x60) >> 3)
+#define GCDR(x)		__REG2(0x40E00440, ((x) & 0x60) >> 3)
+
+
 #endif /* __ASM_ARCH_PXA3XX_REGS_H */
diff -Naur linux-3.4.11/arch/arm/mach-pxa/include/mach/regs-lcd.h linux-HEAD/arch/arm/mach-pxa/include/mach/regs-lcd.h
--- linux-3.4.11/arch/arm/mach-pxa/include/mach/regs-lcd.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/include/mach/regs-lcd.h	2015-11-18 09:04:24.000000000 +0000
@@ -41,6 +41,7 @@
 #define LCCR3_PDFOR_2	(2 << 30)
 #define LCCR3_PDFOR_3	(3 << 30)
 
+#define LCCR4_PCDDIV	(1 << 31)	/* PCD Divisor Selection */
 #define LCCR4_PAL_FOR_0	(0 << 15)
 #define LCCR4_PAL_FOR_1	(1 << 15)
 #define LCCR4_PAL_FOR_2	(2 << 15)
@@ -152,6 +153,8 @@
 #define LCSR_SINT	(1 << 10)	/* subsequent interrupt */
 #define LCSR_RD_ST	(1 << 11)	/* read status */
 #define LCSR_CMD_INT	(1 << 12)	/* command interrupt */
+#define LCSR_BER_CH_S		28
+#define LCSR_BER_CH_MASK	(7 << LCSR_BER_CH_S)
 
 #define LCSR1_IU(x)	(1 << ((x) + 23)) /* Input FIFO underrun */
 #define LCSR1_BS(x)	(1 << ((x) + 15)) /* Branch Status */
diff -Naur linux-3.4.11/arch/arm/mach-pxa/include/mach/uncompress.h linux-HEAD/arch/arm/mach-pxa/include/mach/uncompress.h
--- linux-3.4.11/arch/arm/mach-pxa/include/mach/uncompress.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/include/mach/uncompress.h	2015-11-18 09:04:24.000000000 +0000
@@ -54,6 +54,14 @@
 {
 }
 
+#ifdef CONFIG_LLUART_OFFSET
+static inline void arch_decomp_setup(void)
+{
+	uart_base = 0x40000000 + CONFIG_LLUART_OFFSET;
+	uart_shift = 2;
+	uart_is_pxa = 1;
+}
+#else
 static inline void arch_decomp_setup(void)
 {
 	/* initialize to default */
@@ -72,6 +80,7 @@
 		uart_is_pxa = 0;
 	}
 }
+#endif
 
 /*
  * nothing to do
diff -Naur linux-3.4.11/arch/arm/mach-pxa/irq.c linux-HEAD/arch/arm/mach-pxa/irq.c
--- linux-3.4.11/arch/arm/mach-pxa/irq.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/irq.c	2015-11-18 09:04:24.000000000 +0000
@@ -17,6 +17,7 @@
 #include <linux/syscore_ops.h>
 #include <linux/io.h>
 #include <linux/irq.h>
+#include <linux/ftrace.h>
 
 #include <asm/exception.h>
 
diff -Naur linux-3.4.11/arch/arm/mach-pxa/Kconfig linux-HEAD/arch/arm/mach-pxa/Kconfig
--- linux-3.4.11/arch/arm/mach-pxa/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -718,4 +718,26 @@
 config PXA310_ULPI
 	bool
 
+
+config LLUART_OFFSET
+       hex
+       depends on LLUART_UART0 || LLUART_UART1 || LLUART_UART2 || LLUART_HWUART
+       default 0x00100000 if LLUART_UART0
+       default 0x00200000 if LLUART_UART1
+       default 0x00700000 if LLUART_UART2
+       default 0x01600000 if LLUART_HWUART
+
+config LLUART_UART0
+       bool
+
+config LLUART_UART1
+       bool
+
+config LLUART_UART2
+       bool
+
+config LLUART_HWUART
+       bool
+       depends on PXA255
+
 endif
diff -Naur linux-3.4.11/arch/arm/mach-pxa/Makefile.boot linux-HEAD/arch/arm/mach-pxa/Makefile.boot
--- linux-3.4.11/arch/arm/mach-pxa/Makefile.boot	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/Makefile.boot	2015-11-18 09:04:24.000000000 +0000
@@ -1,2 +1,6 @@
+ifeq ($(CONFIG_PXA3xx),y)
+   zreladdr-y	:= 0x80008000
+else
    zreladdr-y	+= 0xa0008000
+endif
 
diff -Naur linux-3.4.11/arch/arm/mach-pxa/mfp-pxa2xx.c linux-HEAD/arch/arm/mach-pxa/mfp-pxa2xx.c
--- linux-3.4.11/arch/arm/mach-pxa/mfp-pxa2xx.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/mfp-pxa2xx.c	2015-11-18 09:04:24.000000000 +0000
@@ -133,10 +133,10 @@
 	return gpio;
 }
 
-void pxa2xx_mfp_config(unsigned long *mfp_cfgs, int num)
+void pxa2xx_mfp_config(unsigned long const mfp_cfgs[], int num)
 {
 	unsigned long flags;
-	unsigned long *c;
+	unsigned long const *c;
 	int i, gpio;
 
 	for (i = 0, c = mfp_cfgs; i < num; i++, c++) {
@@ -171,6 +171,24 @@
 
 	local_irq_restore(flags);
 }
+
+void pxa2xx_mfp_cfg_wake(int mfp, unsigned long wake)
+{
+	unsigned long flags, c;
+	int gpio;
+
+	gpio = __mfp_validate(mfp);
+	if (gpio < 0)
+		return;
+
+	local_irq_save(flags);
+
+	c = gpio_desc[gpio].config;
+	c = (c & ~(WAKEUP_ON_EDGE_RISE|WAKEUP_ON_EDGE_FALL)) | wake;
+	gpio_desc[gpio].config = c;
+
+	local_irq_restore(flags);
+}
 
 int gpio_set_wake(unsigned int gpio, unsigned int on)
 {
diff -Naur linux-3.4.11/arch/arm/mach-pxa/pxa27x.c linux-HEAD/arch/arm/mach-pxa/pxa27x.c
--- linux-3.4.11/arch/arm/mach-pxa/pxa27x.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mach-pxa/pxa27x.c	2015-11-18 09:04:24.000000000 +0000
@@ -62,6 +62,8 @@
 	if (reset_gpio == 95)
 		pxa2xx_mfp_config(on ? &ac97_reset_config[2] :
 				       &ac97_reset_config[3], 1);
+
+	gpio_set_value(reset_gpio, !on);
 }
 EXPORT_SYMBOL_GPL(pxa27x_assert_ac97reset);
 
@@ -98,6 +100,16 @@
 	S  = (b) ? L : (L/2);
 
 	if (info) {
+		uint32_t	mdrefr = MDREFR;
+		int		sd_div[] =
+			{
+				((mdrefr & MDREFR_K0DB4) ? 4 :
+				 (mdrefr & MDREFR_K0DB2) ? 2 : 1),
+
+				((mdrefr & MDREFR_K1DB2) ? 2 : 1),
+				((mdrefr & MDREFR_K2DB2) ? 2 : 1)
+			};
+
 		printk( KERN_INFO "Run Mode clock: %d.%02dMHz (*%d)\n",
 			L / 1000000, (L % 1000000) / 10000, l );
 		printk( KERN_INFO "Turbo Mode clock: %d.%02dMHz (*%d.%d, %sactive)\n",
@@ -107,6 +119,11 @@
 			M / 1000000, (M % 1000000) / 10000, m );
 		printk( KERN_INFO "System bus clock: %d.%02dMHz \n",
 			S / 1000000, (S % 1000000) / 10000 );
+
+		printk( KERN_INFO "SD clock: %dMHz (/%d), %dMHz (/%d), %dMHz (/%d)\n",
+			M/sd_div[0] / 1000000, sd_div[0],
+			M/sd_div[1] / 1000000, sd_div[1],
+			M/sd_div[2] / 1000000, sd_div[2]);
 	}
 
 	return (t) ? (N/1000) : (L/1000);
@@ -261,26 +278,43 @@
  */
 enum {
 	SLEEP_SAVE_PSTR,
+	SLEEP_SAVE_ICMR,
+	SLEEP_SAVE_ICMR2,
 	SLEEP_SAVE_MDREFR,
 	SLEEP_SAVE_PCFR,
+	SLEEP_SAVE_MSC0, SLEEP_SAVE_MSC1, SLEEP_SAVE_MSC2,
 	SLEEP_SAVE_COUNT
 };
 
 void pxa27x_cpu_pm_save(unsigned long *sleep_save)
 {
 	sleep_save[SLEEP_SAVE_MDREFR] = __raw_readl(MDREFR);
+	sleep_save[SLEEP_SAVE_MSC0] = __raw_readl(MSC0);
+	sleep_save[SLEEP_SAVE_MSC1] = __raw_readl(MSC1);
+	sleep_save[SLEEP_SAVE_MSC1] = __raw_readl(MSC2);
+
 	SAVE(PCFR);
 
+	SAVE(ICMR2); ICMR2 = 0;
+	SAVE(ICMR); ICMR = 0;
 	SAVE(PSTR);
 }
 
 void pxa27x_cpu_pm_restore(unsigned long *sleep_save)
 {
 	__raw_writel(sleep_save[SLEEP_SAVE_MDREFR], MDREFR);
+	__raw_writel(sleep_save[SLEEP_SAVE_MSC2], MSC2);
+	__raw_writel(sleep_save[SLEEP_SAVE_MSC1], MSC1);
+	__raw_writel(sleep_save[SLEEP_SAVE_MSC0], MSC0);
+
 	RESTORE(PCFR);
 
 	PSSR = PSSR_RDH | PSSR_PH;
 
+	ICLR = 0;
+	ICCR = 1;
+	RESTORE(ICMR);
+	RESTORE(ICMR2);
 	RESTORE(PSTR);
 }
 
diff -Naur linux-3.4.11/arch/arm/Makefile linux-HEAD/arch/arm/Makefile
--- linux-3.4.11/arch/arm/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -277,7 +277,7 @@
 # Convert bzImage to zImage
 bzImage: zImage
 
-zImage Image xipImage bootpImage uImage: vmlinux
+zImage Image xipImage bootpImage uImage ceImage: vmlinux
 	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/$@
 
 zinstall uinstall install: vmlinux
diff -Naur linux-3.4.11/arch/arm/mm/proc-xsc3.S linux-HEAD/arch/arm/mm/proc-xsc3.S
--- linux-3.4.11/arch/arm/mm/proc-xsc3.S	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/mm/proc-xsc3.S	2015-11-18 09:04:24.000000000 +0000
@@ -483,7 +483,11 @@
 
 	.type	xsc3_crval, #object
 xsc3_crval:
+#ifdef CONFIG_CACHE_XSC3L2
+	crval	clear=0x00002202, mmuset=0x04003905, ucset=0x04001900
+#else
 	crval	clear=0x04002202, mmuset=0x00003905, ucset=0x00001900
+#endif
 
 	__INITDATA
 
diff -Naur linux-3.4.11/arch/arm/plat-pxa/include/plat/ac97.h linux-HEAD/arch/arm/plat-pxa/include/plat/ac97.h
--- linux-3.4.11/arch/arm/plat-pxa/include/plat/ac97.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/plat-pxa/include/plat/ac97.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,99 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_LINUX_SOUND_ARM_PXA_AC97_H
+#define H_LINUX_SOUND_ARM_PXA_AC97_H
+
+#define CAR		0x20
+#define CAR_CAIP	(1 << 0)	/* CODEC Access In Progress */
+
+#define GCR		0x0c
+
+#if defined(CONFIG_PXA3xx) || defined(CONFIG_CPU_PXA168)
+#define GCR_CLKBPB	(1 << 31)	/* Internal clock enable */
+#endif
+#define GCR_nDMAEN	(1 << 24)	/* non DMA Enable */
+#define GCR_CDONE_IE	(1 << 19)	/* Command Done Interrupt Enable */
+#define GCR_SDONE_IE	(1 << 18)	/* Status Done Interrupt Enable */
+#define GCR_SECRDY_IEN	(1 << 9)	/* Secondary Ready Interrupt Enable */
+#define GCR_PRIRDY_IEN	(1 << 8)	/* Primary Ready Interrupt Enable */
+#define GCR_SECRES_IEN	(1 << 5)	/* Secondary Resume Interrupt Enable */
+#define GCR_PRIRES_IEN	(1 << 4)	/* Primary Resume Interrupt Enable */
+#define GCR_ACLINK_OFF	(1 << 3)	/* AC-link Shut Off */
+#define GCR_WARM_RST	(1 << 2)	/* AC97 Warm Reset */
+#define GCR_nCOLD_RST	(1 << 1)	/* AC'97 nCold Reset (0 = active) */
+#define GCR_GIE		(1 << 0)	/* Codec GPI Interrupt Enable */
+
+
+#define GSR		0x1c
+#ifdef CONFIG_CPU_PXA168
+#define GSR_PSOINT	(1 << 21)	/* PCM-Sorround-Out Interrupt */
+#define GSR_PCLINT	(1 << 20)	/* PCM-Center/LFE Interrupt */
+#endif
+#define GSR_CDONE	(1 << 19)	/* Command Done */
+#define GSR_SDONE	(1 << 18)	/* Status Done */
+#define GSR_RDCS	(1 << 15)	/* Read Completion Status */
+#define GSR_BIT3SLT12	(1 << 14)	/* Bit 3 of slot 12 */
+#define GSR_BIT2SLT12	(1 << 13)	/* Bit 2 of slot 12 */
+#define GSR_BIT1SLT12	(1 << 12)	/* Bit 1 of slot 12 */
+#define GSR_SECRES	(1 << 11)	/* Secondary Resume Interrupt */
+#define GSR_PRIRES	(1 << 10)	/* Primary Resume Interrupt */
+#define GSR_SCR		(1 << 9)	/* Secondary Codec Ready */
+#define GSR_PCR		(1 << 8)	/* Primary Codec Ready */
+#define GSR_MCINT	(1 << 7)	/* Mic In Interrupt */
+#define GSR_POINT	(1 << 6)	/* PCM Out Interrupt */
+#define GSR_PIINT	(1 << 5)	/* PCM In Interrupt */
+#define GSR_ACOFFD	(1 << 3)	/* AC-link Shut Off Done */
+#define GSR_MOINT	(1 << 2)	/* Modem Out Interrupt */
+#define GSR_MIINT	(1 << 1)	/* Modem In Interrupt */
+#define GSR_GSCI	(1 << 0)	/* Codec GPI Status Change Interrupt */
+
+#if !(defined(CONFIG_CPU_PXA27x) || defined(CONFIG_CPU_PXA25x))
+#define PCSDR		0x02c		/* PCM Surround Out Data Register */
+#define PCCLDR		0x038		/* PCM Center/LFE Data Register */
+#endif
+
+#define PCMISR		0x014		/* PCM-In Status Register */
+#define PCMISR_FSR	(1 << 2)	/* FIFO Service Register */
+#define PCMISR_EOC	(1 << 3)	/* DMA End Of Chain Interrupt */
+#define PCMISR_FIFOE	(1 << 4)	/* FIFO Error */
+
+#define MCSR		0x018		/* Mic-IN Status */
+#define MCSR_FSR	(1 << 2)	/* FIFO Service Register */
+#define MCSR_EOC	(1 << 3)	/* DMA End Of Chain Interrupt */
+#define MCSR_FIFOE	(1 << 4)	/* FIFO Error */
+
+#define PCDR		0x040		/* PCM Data Register */
+
+#define MCDR		0x060		/* Mic-in FIFO Data Register */
+
+#define MOSR		0x110		/* MODEM-Out Status Register */
+#define MOSR_FSR	(1 << 2)	/* FIFO Service Request */
+#define MOSR_FIFOE	(1 << 4)	/* FIFO Error */
+
+#define MISR		0x118		/* Modem In Status Register */
+#define MISR_FSR	(1 << 2)	/* FIFO Service Request */
+#define MISR_EOC	(1 << 3)	/* DMA End Of Chain Interrupt */
+#define MISR_FIFOE	(1 << 4)	/* FIFO Error */
+
+#define MODR		0x140		/* Modem FIFO Data Register */
+
+#define PAC_REG_BASE	0x200
+#define SAC_REG_BASE	0x300
+#define PMC_REG_BASE	0x400
+#define SMC_REG_BASE	0x500
+
+#endif	/* H_LINUX_SOUND_ARM_PXA_AC97_H */
diff -Naur linux-3.4.11/arch/arm/plat-pxa/include/plat/audio.h linux-HEAD/arch/arm/plat-pxa/include/plat/audio.h
--- linux-3.4.11/arch/arm/plat-pxa/include/plat/audio.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/arch/arm/plat-pxa/include/plat/audio.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,39 @@
+#ifndef __ASM_ARCH_AUDIO_H__
+#define __ASM_ARCH_AUDIO_H__
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+
+/*
+ * @reset_gpio: AC97 reset gpio (normally gpio113 or gpio95)
+ *              a -1 value means no gpio will be used for reset
+ * @codec_pdata: AC97 codec platform_data
+
+ * reset_gpio should only be specified for pxa27x CPUs where a silicon
+ * bug prevents correct operation of the reset line. If not specified,
+ * the default behaviour on these CPUs is to consider gpio 113 as the
+ * AC97 reset line, which is the default on most boards.
+ */
+typedef struct {
+	int (*startup)(struct snd_pcm_substream *, void *);
+	void (*shutdown)(struct snd_pcm_substream *, void *);
+	void (*suspend)(void *);
+	void (*resume)(void *);
+	void (*reset_codec)(void *, int);
+	void *priv;
+	int reset_gpio;
+	void *codec_pdata[AC97_BUS_MAX_DEVICES];
+} pxa2xx_audio_ops_t;
+
+#define PXA_AC97_DMA_CH_PCM_TX		"AC97 PCM Stereo out"
+#define PXA_AC97_DMA_CH_PCM_SURROUND_TX	"PCM audio surround TX"
+#define PXA_AC97_DMA_CH_PCM_CENTRE_TX	"PCM audio centre TX"
+#define PXA_AC97_DMA_CH_PCM_RX		"AC97 PCM Stereo in"
+#define PXA_AC97_DMA_CH_PCM_MODEM_TX	"AC97 Aux PCM (Slot 5) Mono out"
+#define PXA_AC97_DMA_CH_PCM_MODEM_RX	"AC97 Aux PCM (Slot 5) Mono in"
+#define PXA_AC97_DMA_CH_PCM_MIC		"AC97 Mic PCM (Slot 6) Mono in"
+
+extern void pxa_set_ac97_info(pxa2xx_audio_ops_t *ops);
+
+#endif
diff -Naur linux-3.4.11/arch/arm/plat-pxa/include/plat/mfp.h linux-HEAD/arch/arm/plat-pxa/include/plat/mfp.h
--- linux-3.4.11/arch/arm/plat-pxa/include/plat/mfp.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/plat-pxa/include/plat/mfp.h	2015-11-18 09:04:24.000000000 +0000
@@ -323,6 +323,17 @@
 	MFP_PIN_TWSI4_SDA,
 	MFP_PIN_CLK_REQ,
 
+	/* additional pins on PXA168 */
+	MFP_PIN_PWR_SCL,
+	MFP_PIN_PWR_SDA,
+
+	MFP_PIN_PRI_TDI,
+	MFP_PIN_PRI_TMS,
+	MFP_PIN_PRI_TCK,
+	MFP_PIN_PRI_TDO,
+	MFP_PIN_PRI_TRST_N,
+	MFP_PIN_EXT_WKUP,
+
 	MFP_PIN_MAX,
 };
 
@@ -467,7 +478,7 @@
  */
 unsigned long mfp_read(int mfp);
 void mfp_write(int mfp, unsigned long mfpr_val);
-void mfp_config(unsigned long *mfp_cfgs, int num);
+void mfp_config(unsigned long const *mfp_cfgs, int num);
 void mfp_config_run(void);
 void mfp_config_lpm(void);
 #endif /* CONFIG_PXA3xx || CONFIG_PXA95x || CONFIG_ARCH_MMP */
diff -Naur linux-3.4.11/arch/arm/plat-pxa/include/plat/pxa27x_keypad.h linux-HEAD/arch/arm/plat-pxa/include/plat/pxa27x_keypad.h
--- linux-3.4.11/arch/arm/plat-pxa/include/plat/pxa27x_keypad.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/plat-pxa/include/plat/pxa27x_keypad.h	2015-11-18 09:04:24.000000000 +0000
@@ -36,8 +36,8 @@
 struct pxa27x_keypad_platform_data {
 
 	/* code map for the matrix keys */
-	unsigned int	matrix_key_rows;
-	unsigned int	matrix_key_cols;
+	uint8_t		mask_rows;
+	uint8_t		mask_cols;
 	unsigned int	*matrix_key_map;
 	int		matrix_key_map_size;
 
diff -Naur linux-3.4.11/arch/arm/plat-pxa/include/plat/pxa3xx_nand.h linux-HEAD/arch/arm/plat-pxa/include/plat/pxa3xx_nand.h
--- linux-3.4.11/arch/arm/plat-pxa/include/plat/pxa3xx_nand.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/plat-pxa/include/plat/pxa3xx_nand.h	2015-11-18 09:04:24.000000000 +0000
@@ -38,7 +38,7 @@
 	unsigned int	dfc_width;	/* Width of flash controller(DWIDTH_C) */
 	unsigned int	num_blocks;	/* Number of physical blocks in Flash */
 
-	struct pxa3xx_nand_timing *timing;	/* NAND Flash timing */
+	struct pxa3xx_nand_timing const *timing;	/* NAND Flash timing */
 };
 
 /*
diff -Naur linux-3.4.11/arch/arm/plat-pxa/mfp.c linux-HEAD/arch/arm/plat-pxa/mfp.c
--- linux-3.4.11/arch/arm/plat-pxa/mfp.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/plat-pxa/mfp.c	2015-11-18 09:04:24.000000000 +0000
@@ -144,13 +144,13 @@
 static unsigned long mfpr_off_readback;
 #define mfpr_sync()	(void)__raw_readl(mfpr_mmio_base + mfpr_off_readback)
 
-static inline void __mfp_config_run(struct mfp_pin *p)
+static inline void __mfp_config_run(struct mfp_pin const *p)
 {
 	if (mfp_configured(p))
 		mfpr_writel(p->mfpr_off, p->mfpr_run);
 }
 
-static inline void __mfp_config_lpm(struct mfp_pin *p)
+static inline void __mfp_config_lpm(struct mfp_pin const *p)
 {
 	if (mfp_configured(p)) {
 		unsigned long mfpr_clr = (p->mfpr_run & ~MFPR_EDGE_BOTH) | MFPR_EDGE_CLEAR;
@@ -161,11 +161,13 @@
 	}
 }
 
-void mfp_config(unsigned long *mfp_cfgs, int num)
+void mfp_config(unsigned long const *mfp_cfgs, int num)
 {
 	unsigned long flags;
 	int i;
+	unsigned long set_pins[DIV_ROUND_UP(MFP_PIN_MAX, sizeof(unsigned long))];
 
+	memset(set_pins, 0, sizeof set_pins);
 	spin_lock_irqsave(&mfp_spin_lock, flags);
 
 	for (i = 0; i < num; i++, mfp_cfgs++) {
@@ -175,6 +177,13 @@
 
 		pin = MFP_PIN(c);
 		BUG_ON(pin >= MFP_PIN_MAX);
+
+		if (test_and_set_bit(pin, set_pins)) {
+			printk(KERN_ERR "mfp pin %d (#%d) set twice\n",
+			       pin, i);
+			WARN_ON(1);
+		}
+
 		p = &mfp_table[pin];
 
 		af  = MFP_AF(c);
diff -Naur linux-3.4.11/arch/arm/plat-pxa/ssp.c linux-HEAD/arch/arm/plat-pxa/ssp.c
--- linux-3.4.11/arch/arm/plat-pxa/ssp.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/plat-pxa/ssp.c	2015-11-18 09:04:24.000000000 +0000
@@ -195,6 +195,7 @@
 	{ "pxa168-ssp",		PXA168_SSP },
 	{ },
 };
+MODULE_DEVICE_TABLE(platform, ssp_id_table);
 
 static struct platform_driver pxa_ssp_driver = {
 	.probe		= pxa_ssp_probe,
diff -Naur linux-3.4.11/arch/arm/tools/mach-types linux-HEAD/arch/arm/tools/mach-types
--- linux-3.4.11/arch/arm/tools/mach-types	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/arch/arm/tools/mach-types	2015-11-18 09:04:24.000000000 +0000
@@ -1169,3 +1169,5 @@
 pov2			MACH_POV2		POV2			3889
 ipod_touch_2g		MACH_IPOD_TOUCH_2G	IPOD_TOUCH_2G		3890
 da850_pqab		MACH_DA850_PQAB		DA850_PQAB		3891
+
+eq3_ccu2		MACH_EQ3_CCU2		EQ3_CCU2		3957
diff -Naur linux-3.4.11/drivers/base/platform.c linux-HEAD/drivers/base/platform.c
--- linux-3.4.11/drivers/base/platform.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/base/platform.c	2015-11-18 09:04:24.000000000 +0000
@@ -125,7 +125,7 @@
  * @devs: array of platform devices to add
  * @num: number of platform devices in array
  */
-int platform_add_devices(struct platform_device **devs, int num)
+int platform_add_devices(struct platform_device * const *devs, int num)
 {
 	int i, ret = 0;
 
diff -Naur linux-3.4.11/drivers/char/eq3_char_loop.c linux-HEAD/drivers/char/eq3_char_loop.c
--- linux-3.4.11/drivers/char/eq3_char_loop.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/char/eq3_char_loop.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,982 @@
+/*
+* eQ-3 char loopback driver for HomeMatic / HomeMatic IP dual stack implementations
+*
+* Copyright (c) 2015 by eQ-3 Entwicklung GmbH
+* Author: Lars Reemts, lars.reemts@finalbit.de
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+* General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*
+*/
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/circ_buf.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <asm/termbits.h>
+#include <asm/termios.h>
+#include <asm/ioctls.h>
+#include <linux/version.h>
+
+#define EQ3LOOP_NUMBER_OF_CHANNELS 4
+#define EQ3LOOP_DRIVER_NAME "eq3loop"
+
+/* Use 'L' as magic number */
+#define EQ3LOOP_IOC_MAGIC  'L'
+
+#define EQ3LOOP_IOCSCREATESLAVE _IOW(EQ3LOOP_IOC_MAGIC,  1, unsigned long)
+#define EQ3LOOP_IOCGEVENTS _IOR(EQ3LOOP_IOC_MAGIC,  2, unsigned long)
+
+#define EVENT_BIT_SLAVE_OPENED 0
+#define EVENT_BIT_SLAVE_CLOSED 1
+#define STATE_BIT_SLAVE_OPENED 15
+
+#define CONNECTION_TYPE_MASTER 0
+#define CONNECTION_TYPE_SLAVE 1
+
+#define BUFSIZE 1024  //just use buffer size power of 2. otherwise the size and index calculation dosn't work
+
+#define DUMP_READWRITE 0
+
+struct eq3loop_channel_data
+{
+	struct circ_buf master2slave_buf;
+	struct circ_buf slave2master_buf;
+	unsigned char _master2slave_buf[BUFSIZE];
+	unsigned char _slave2master_buf[BUFSIZE];
+	
+	wait_queue_head_t master2slaveq;
+	wait_queue_head_t slave2masterq;
+	struct semaphore sem;                              //semaphore for accessing this struct. 
+	volatile long unsigned int pending_events;
+	volatile long unsigned int slave_open_count;
+	volatile long unsigned int created;
+	dev_t devnode;
+	char name[32];
+	struct termios termios;
+};
+
+struct eq3loop_control_data {
+	dev_t devnode;
+	struct cdev cdev;
+	struct class * class;
+	struct eq3loop_channel_data channels[EQ3LOOP_NUMBER_OF_CHANNELS];
+	struct semaphore sem;                              //semaphore for accessing this struct. 
+};
+
+struct eq3loop_connection_data
+{
+	int connection_type;
+	struct eq3loop_channel_data* channel;
+	ssize_t (*read) (struct eq3loop_channel_data *, struct file *, char __user *, size_t, loff_t *);
+	ssize_t (*write) (struct eq3loop_channel_data *, struct file *, const char __user *, size_t, loff_t *);    
+	long (*ioctl) (struct eq3loop_channel_data *, struct file *, unsigned int cmd, unsigned long arg);
+	int (*close) (struct eq3loop_channel_data *, struct file *);
+	unsigned int (*poll) (struct eq3loop_channel_data *, struct file*, poll_table* wait);
+};
+
+static struct eq3loop_control_data* control_data;
+
+static ssize_t eq3loop_read_slave(struct eq3loop_channel_data* channel, struct file *filp, char *buf, size_t count, loff_t *offset)
+{
+	ssize_t ret = 0;
+	int count_to_end,tail;
+	if (down_interruptible(&channel->sem)){
+		return -ERESTARTSYS;
+	}
+
+	
+	if( !channel->created )
+	{
+		ret = -ENODEV;
+		goto out;
+	}
+	while( channel->created && !CIRC_CNT( channel->master2slave_buf.head, channel->master2slave_buf.tail, BUFSIZE)) { /* nothing to read */
+		up(&channel->sem); /* release the lock */
+		if (filp->f_flags & O_NONBLOCK)	{
+			return -EAGAIN;
+		}
+		if (wait_event_interruptible(channel->master2slaveq, (!channel->created) || CIRC_CNT( channel->master2slave_buf.head, channel->master2slave_buf.tail, BUFSIZE))){
+			return -ERESTARTSYS; /* signal: tell the fs layer to handle it */
+		}
+		/* otherwise loop, but first reacquire the lock */
+		if (down_interruptible(&channel->sem)){
+			return -ERESTARTSYS;
+		}
+	}
+	
+	if( !channel->created )
+	{
+		ret = -ENODEV;
+		goto out;
+	}
+	tail = channel->master2slave_buf.tail;
+	/* ok, data is there, return something */
+	count = min((int)count, CIRC_CNT( channel->master2slave_buf.head, tail, BUFSIZE));
+	count_to_end = min((int)count,CIRC_CNT_TO_END(channel->master2slave_buf.head,tail,BUFSIZE));
+	
+	#if DUMP_READWRITE
+	{
+		int i;
+		printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": eq3loop_read_slave() %s:", channel->name );
+		for( i=0; i<count; i++ )
+		{
+			printk( " %02X", channel->master2slave_buf.buf[(tail + i) & (BUFSIZE - 1)] );
+		}
+	}
+	#endif
+	
+	
+	if (copy_to_user(buf, channel->master2slave_buf.buf + tail, count_to_end)) {
+		ret = -EFAULT;
+		goto out;
+	}
+	tail = (tail + count_to_end) & (BUFSIZE - 1);
+
+	if (copy_to_user(buf + count_to_end, channel->master2slave_buf.buf + tail, count - count_to_end)) {
+		ret = -EFAULT;
+		goto out;
+	}
+	tail = (tail + (count - count_to_end)) & (BUFSIZE - 1);
+	smp_mb();
+	channel->master2slave_buf.tail = tail;
+	ret = count;
+	
+out:
+	up (&channel->sem);
+
+	if( ret > 0 )
+	{
+		wake_up_interruptible( &channel->master2slaveq );
+	}
+	else
+	{
+		printk( KERN_ERR EQ3LOOP_DRIVER_NAME ": eq3loop_read_slave() %s: error while reading from slave", channel->name );
+	}
+	return ret;
+}
+
+static ssize_t eq3loop_read_master(struct eq3loop_channel_data* channel, struct file *filp, char *buf, size_t count, loff_t *offset)
+{
+	ssize_t ret = 0;
+	int count_to_end,tail;
+	if (down_interruptible(&channel->sem))
+		return -ERESTARTSYS;
+	
+	while( channel->slave_open_count && (!CIRC_CNT( channel->slave2master_buf.head, channel->slave2master_buf.tail, BUFSIZE))) { /* slave open but nothing to read */
+		up(&channel->sem); /* release the lock */
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		if (wait_event_interruptible(channel->slave2masterq, (!channel->slave_open_count) || CIRC_CNT( channel->slave2master_buf.head, channel->slave2master_buf.tail, BUFSIZE)))
+			return -ERESTARTSYS; /* signal: tell the fs layer to handle it */
+		/* otherwise loop, but first reacquire the lock */
+		if (down_interruptible(&channel->sem))
+			return -ERESTARTSYS;
+	}
+	if( channel->slave_open_count )
+	{
+		tail = channel->slave2master_buf.tail;
+		/* ok, data is there, return something */
+		count = min((int)count, CIRC_CNT( channel->slave2master_buf.head, tail, BUFSIZE));
+		count_to_end = min((int)count,CIRC_CNT_TO_END(channel->slave2master_buf.head, tail, BUFSIZE));
+		
+		#if DUMP_READWRITE
+		{
+			int i;
+			printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": eq3loop_read_master() %s:", channel->name );
+			for( i=0; i<count; i++ )
+			{
+				printk( " %02X", channel->slave2master_buf.buf[(tail + i) & (BUFSIZE - 1)] );
+			}
+		}
+		#endif
+		
+		
+		if (copy_to_user(buf, channel->slave2master_buf.buf + tail, count_to_end)) {
+			ret = -EFAULT;
+			goto out;
+		}
+		tail = (tail + count_to_end) & (BUFSIZE - 1);
+		if (copy_to_user(buf + count_to_end, channel->slave2master_buf.buf + tail, count - count_to_end)) {
+			ret = -EFAULT;
+			goto out;
+		}
+		tail = (tail + (count - count_to_end)) & (BUFSIZE - 1);
+		smp_mb();
+		channel->slave2master_buf.tail = tail;
+		ret = count;
+	}
+	
+	
+out:
+	up (&channel->sem);
+	
+	if( ret > 0 )
+	{
+		wake_up_interruptible( &channel->slave2masterq );
+	}
+
+	return ret;
+}
+
+static ssize_t eq3loop_read(struct file *filp, char *buf, size_t count, loff_t *offset)
+{
+	struct eq3loop_connection_data *conn = filp->private_data;
+	if( conn && conn->read )
+	{
+		return conn->read( conn->channel, filp, buf, count, offset );
+	}
+	return -EFAULT;
+}
+
+static ssize_t eq3loop_write_slave(struct eq3loop_channel_data* channel, struct file *filp, const char *buf, size_t count, loff_t *offset)
+{
+	int head;
+	ssize_t ret=0;
+        ssize_t count_to_end;
+	if (down_interruptible(&channel->sem))
+		return -ERESTARTSYS;
+
+	while(!CIRC_SPACE( channel->slave2master_buf.head, channel->slave2master_buf.tail, BUFSIZE)) { /* no space to write */
+		up(&channel->sem); /* release the lock */
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		if (wait_event_interruptible(channel->slave2masterq, (!channel->created) || CIRC_SPACE( channel->slave2master_buf.head, channel->slave2master_buf.tail, BUFSIZE)))
+			return -ERESTARTSYS; /* signal: tell the fs layer to handle it */
+		/* otherwise loop, but first reacquire the lock */
+		if (down_interruptible(&channel->sem))
+			return -ERESTARTSYS;
+	}
+	
+	if( !channel->created )
+	{
+		ret = -ENODEV;
+		goto out;
+	}
+	head = channel->slave2master_buf.head;
+	if(CIRC_SPACE( head, channel->slave2master_buf.tail, BUFSIZE) < count)
+	{
+		ret=-EFAULT;
+		goto out;
+	}
+	
+	/* ok, space is free, write something */
+	count_to_end = min((int)count, CIRC_SPACE_TO_END( head, channel->slave2master_buf.tail, BUFSIZE));
+	
+	if(copy_from_user(channel->slave2master_buf.buf + head, buf, count_to_end)){
+		ret=-EFAULT;
+		goto out;
+	}
+    head = (head + count_to_end) & (BUFSIZE - 1);
+
+	if(copy_from_user(channel->slave2master_buf.buf + head, buf+count_to_end, count - count_to_end)){
+		ret=-EFAULT;
+		goto out;
+	}
+ 	head = (head + (count - count_to_end)) & (BUFSIZE - 1);
+	#if DUMP_READWRITE
+	{
+		int i;
+        if(head < channel->slave2master_buf.head)
+        {
+        	printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": eq3loop_write_slave() reach end of circular buffer" );
+        }
+		printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": eq3loop_write_slave() %s:", channel->name );
+		for( i=0; i<count; i++ )
+		{
+			printk( " %02X", channel->slave2master_buf.buf[(channel->slave2master_buf.head + i)& (BUFSIZE - 1)] );
+		}
+	}
+	#endif
+	
+	
+	smp_mb();
+	channel->slave2master_buf.head = head;
+	
+	ret = count;
+	
+out:
+	up (&channel->sem);
+
+	if( ret > 0 )
+	{
+		wake_up_interruptible( &channel->slave2masterq );
+	}
+	
+	return ret;
+}
+
+static ssize_t eq3loop_write_master(struct eq3loop_channel_data* channel, struct file *filp, const char *buf, size_t count, loff_t *offset)
+{
+	ssize_t ret=0;
+	int head;
+	ssize_t count_to_end;
+	if (down_interruptible(&channel->sem))
+		return -ERESTARTSYS;
+
+	while(!CIRC_SPACE( channel->master2slave_buf.head, channel->master2slave_buf.tail, BUFSIZE)) { /* no space to write */
+		up(&channel->sem); /* release the lock */
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		if (wait_event_interruptible(channel->master2slaveq, (!channel->slave_open_count) || CIRC_SPACE( channel->master2slave_buf.head, channel->master2slave_buf.tail, BUFSIZE)))
+			return -ERESTARTSYS; /* signal: tell the fs layer to handle it */
+		/* otherwise loop, but first reacquire the lock */
+		if (down_interruptible(&channel->sem))
+			return -ERESTARTSYS;
+	}
+	head = channel->master2slave_buf.head;
+	if(CIRC_SPACE( head, channel->master2slave_buf.tail, BUFSIZE) < count)
+	{
+		ret=-EFAULT;
+		count_to_end = CIRC_SPACE( head, channel->master2slave_buf.tail, BUFSIZE);
+		printk( KERN_ERR EQ3LOOP_DRIVER_NAME ": eq3loop_write_master() %s: not enought space in the buffers. free space = %i, required space = %i", channel->name,count_to_end,count );
+		goto out;
+	}
+	/* ok, space is free, write something */
+	count_to_end = min((int)count, CIRC_SPACE_TO_END( head, channel->master2slave_buf.tail, BUFSIZE));
+
+	if(copy_from_user(channel->master2slave_buf.buf + head, buf, count_to_end)){
+		ret=-EFAULT;
+		printk( KERN_ERR EQ3LOOP_DRIVER_NAME ": eq3loop_write_master() %s: unable to copy buffer",channel->name );
+		goto out;
+	}
+	head = (head + count_to_end) & (BUFSIZE - 1);
+	if(copy_from_user(channel->master2slave_buf.buf + head, buf+count_to_end,count - count_to_end)){
+		ret=-EFAULT;
+		printk( KERN_ERR EQ3LOOP_DRIVER_NAME ": eq3loop_write_master() %s: unable to copy buffer",channel->name );
+		goto out;
+	}
+	head = (head + (count - count_to_end)) & (BUFSIZE - 1);
+	#if DUMP_READWRITE
+	{
+		int i;
+		printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": eq3loop_write_master() %s:", channel->name );
+		for( i=0; i<count; i++ )
+		{
+			printk( " %02X", channel->master2slave_buf.buf[(channel->master2slave_buf.head + i)&(BUFSIZE - 1)] );
+		}
+	}
+	#endif
+	smp_mb();
+	channel->master2slave_buf.head = head;
+	ret = count;
+
+out:
+	up (&channel->sem);
+	if(ret < 0)
+	{
+		printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": eq3loop_write_master() retrun error:");
+	}
+	if( ret > 0 || CIRC_CNT(channel->master2slave_buf.head,channel->master2slave_buf.tail,BUFSIZE) )
+	{
+		//send a signal to reading procces if return is ok or data in the buffer
+		wake_up_interruptible( &channel->master2slaveq );
+	}
+	
+	return ret;
+}
+
+static ssize_t eq3loop_write(struct file *filp, const char *buf, size_t count, loff_t *offset)
+{
+	struct eq3loop_connection_data *conn = filp->private_data;
+	if( conn && conn->write )
+	{
+		return conn->write( conn->channel, filp, buf, count, offset );
+	}
+	return -EFAULT;
+}
+
+static long eq3loop_create_slave_dev( struct file *filp, const char* name );
+
+static long eq3loop_ioctl_ctrl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	char buffer[64];
+	long ret = 0;
+	
+	/*
+	* extract the type and number bitfields, and don't decode
+	* wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
+	*/
+	if (_IOC_TYPE(cmd) != EQ3LOOP_IOC_MAGIC) return -ENOTTY;
+
+
+	switch(cmd) {
+
+	case EQ3LOOP_IOCSCREATESLAVE:
+		ret = strncpy_from_user( buffer, (char*)arg, sizeof(buffer) );
+		if( ret <= 0 )
+		{
+			return -EFAULT;
+		}
+		return eq3loop_create_slave_dev( filp, buffer );
+	default:
+		return -ENOTTY;
+	}
+}
+
+static long eq3loop_ioctl_master(struct eq3loop_channel_data* channel, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	long ret = 0;
+	unsigned long temp = 0;
+	
+	/*
+	* extract the type and number bitfields, and don't decode
+	* wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
+	*/
+	if (_IOC_TYPE(cmd) != EQ3LOOP_IOC_MAGIC) return -ENOTTY;
+
+	/*
+	* the direction is a bitmask, and VERIFY_WRITE catches R/W
+	* transfers. `Type' is user-oriented, while
+	* access_ok is kernel-oriented, so the concept of "read" and
+	* "write" is reversed
+	*/
+	if (_IOC_DIR(cmd) & _IOC_READ)
+	ret = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+	ret =  !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+	if (ret) return -EFAULT;
+
+	switch(cmd) {
+
+	case EQ3LOOP_IOCGEVENTS:
+		if( test_and_clear_bit( EVENT_BIT_SLAVE_OPENED, &channel->pending_events ) )
+		{
+			temp |= (1<<EVENT_BIT_SLAVE_OPENED);
+		}
+		if( test_and_clear_bit( EVENT_BIT_SLAVE_CLOSED, &channel->pending_events ) )
+		{
+			temp |= (1<<EVENT_BIT_SLAVE_CLOSED);
+		}
+		if( test_bit( STATE_BIT_SLAVE_OPENED, &channel->pending_events ) )
+		{
+			temp |= (1<<STATE_BIT_SLAVE_OPENED);
+		}
+		ret = __put_user(temp, (unsigned long *)arg);
+		if( ret )
+		{
+			channel->pending_events = temp;
+			smp_mb();
+		}
+		break;
+	default:
+		return -ENOTTY;
+	}
+	return ret;
+}
+
+static long eq3loop_ioctl_slave(struct eq3loop_channel_data* channel, struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	long ret = 0;
+	int temp;
+	
+	if (down_interruptible(&channel->sem))
+		return -ERESTARTSYS;
+	
+	switch(cmd) {
+
+	case TCGETS:
+		if( access_ok(VERIFY_READ, (void *)arg, sizeof(struct termios) ) )
+		{
+			ret = copy_to_user( (void*)arg, &channel->termios, sizeof(struct termios) );
+		} else {
+			ret = -EFAULT;
+		}
+		break;
+	case TCSETS:
+		if( access_ok(VERIFY_WRITE, (void *)arg, sizeof(struct termios) ) )
+		{
+			ret = copy_from_user( &channel->termios, (void*)arg, sizeof(struct termios) );
+		} else {
+			ret = -EFAULT;
+		}
+		break;
+	case TIOCINQ:
+		temp = CIRC_CNT( channel->master2slave_buf.head, channel->master2slave_buf.tail, BUFSIZE);
+		ret = __put_user( temp, (int*)arg );
+		break;
+	case TIOCOUTQ:
+		temp = CIRC_CNT( channel->slave2master_buf.head, channel->slave2master_buf.tail, BUFSIZE);
+		ret = __put_user( temp, (int*)arg );
+		break;
+	case TIOCEXCL:
+		break;
+	case TCFLSH:
+		break;
+	case TIOCMGET:
+		temp = TIOCM_DSR | TIOCM_CD | TIOCM_CTS;
+		ret = __put_user( temp, (int*)arg );
+		break;
+	case TIOCMSET:
+		break;
+	default:
+		ret = -ENOTTY;
+		break;
+	}
+	up (&channel->sem );
+	if( ret == -ENOTTY )
+	{
+		printk( KERN_NOTICE EQ3LOOP_DRIVER_NAME ": eq3loop_ioctl_slave() %s: unhandled ioctl 0x%04X\n", channel->name, cmd );
+	}
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11))
+static int eq3loop_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+#else
+static long eq3loop_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+#endif
+{
+	struct eq3loop_connection_data *conn = filp->private_data;
+	if( !conn )
+	{
+		return eq3loop_ioctl_ctrl( filp, cmd, arg );
+	}
+	if( conn->ioctl )
+	{
+		return conn->ioctl( conn->channel, filp, cmd, arg );
+	}
+	
+	return -EFAULT;   
+}
+
+
+static int eq3loop_close_slave(struct eq3loop_channel_data* channel, struct file *filp)
+{
+	int ret = 0;
+	
+	printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": eq3loop_close_slave() %s\n", channel->name );
+	
+	if (down_interruptible(&channel->sem))
+	return -ERESTARTSYS;
+	
+	if( channel->slave_open_count )
+	{
+		channel->slave_open_count--;
+	}
+	
+	kfree( filp->private_data );
+
+	set_bit( EVENT_BIT_SLAVE_CLOSED, &channel->pending_events );
+	clear_bit( STATE_BIT_SLAVE_OPENED, &channel->pending_events );
+
+	if( !channel->created )
+	{
+		printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": eq3loop_close_slave() %s destroy device\n", channel->name );
+		device_destroy(control_data->class, channel->devnode);
+	}
+	
+	up( &channel->sem );
+	smp_mb();
+	wake_up_interruptible( &channel->slave2masterq );
+	return ret;
+}
+
+static int eq3loop_close_master(struct eq3loop_channel_data* channel, struct file *filp)
+{
+	int ret = 0;
+	
+	printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": eq3loop_close_master() %s\n", channel->name );
+	
+	if (down_interruptible(&channel->sem))
+	return -ERESTARTSYS;
+	
+	if (down_interruptible(&control_data->sem))
+	{
+		ret = -ERESTARTSYS;
+		goto out;
+	}
+	
+	channel->created = 0;
+
+	up( &control_data->sem );
+	
+	kfree( filp->private_data );
+	
+	if( !channel->slave_open_count )
+	{
+		printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": eq3loop_close_master() %s destroy device\n", channel->name );
+		device_destroy(control_data->class, channel->devnode);
+	}
+	
+out:
+	up( &channel->sem );
+	wake_up_interruptible( &channel->master2slaveq );
+	return ret;
+}
+
+static int eq3loop_close(struct inode *inode, struct file *filp)
+{
+	struct eq3loop_connection_data *conn = filp->private_data;
+	if( !conn )
+	{
+		return 0;
+	}
+	if( conn->close )
+	{
+		return conn->close( conn->channel, filp );
+	}
+	
+	return -ENODEV;   
+}
+
+static unsigned int eq3loop_poll_master(struct eq3loop_channel_data* channel, struct file* filp, poll_table* wait)
+{
+	unsigned int mask=0;
+	unsigned long requested_events = poll_requested_events( wait );
+	
+	//printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": eq3loop_poll_master() %s requested=0x%lX\n", channel->name, requested_events );
+	
+	if( requested_events & ( POLLIN | POLLPRI | POLLERR ) )
+	{
+		poll_wait(filp, &channel->slave2masterq, wait);
+	}
+	if( requested_events & POLLOUT )
+	{
+		poll_wait(filp, &channel->master2slaveq, wait);
+	}
+	
+	if (down_interruptible(&channel->sem))
+	return -ERESTARTSYS;    
+	
+	if( channel->slave_open_count )
+	{
+		if( CIRC_SPACE( channel->master2slave_buf.head, channel->master2slave_buf.tail, BUFSIZE) )
+		{
+			mask |= POLLOUT | POLLWRNORM;
+		}
+		
+		if( CIRC_CNT( channel->slave2master_buf.head, channel->slave2master_buf.tail, BUFSIZE) )
+		{
+			mask |= POLLIN | POLLRDNORM;
+		}
+	}
+	
+	if( test_bit( EVENT_BIT_SLAVE_OPENED, &channel->pending_events ) || test_bit( EVENT_BIT_SLAVE_CLOSED, &channel->pending_events ) )
+	{
+		mask |= POLLPRI;
+	}
+	
+	
+	
+	up( &channel->sem );
+
+	return mask;
+}
+
+static unsigned int eq3loop_poll_slave(struct eq3loop_channel_data* channel, struct file* filp, poll_table* wait)
+{
+	unsigned int mask=0;
+	unsigned long requested_events = poll_requested_events( wait );
+	
+	if( requested_events & POLLIN )
+	{
+		poll_wait(filp, &channel->master2slaveq, wait);
+	}
+	if( requested_events & POLLOUT )
+	{
+		poll_wait(filp, &channel->slave2masterq, wait);
+	}
+	
+	if (down_interruptible(&channel->sem))
+	return -ERESTARTSYS;    
+	
+	if( CIRC_CNT( channel->master2slave_buf.head, channel->master2slave_buf.tail, BUFSIZE) )
+	{
+		mask |= POLLIN | POLLRDNORM;
+	}
+	
+	if( CIRC_SPACE( channel->slave2master_buf.head, channel->slave2master_buf.tail, BUFSIZE) )
+	{
+		mask |= POLLOUT | POLLWRNORM;
+	}
+	
+	if( !channel->created )
+	{
+		mask |= POLLERR;
+	}
+	
+	up( &channel->sem );
+	
+	return mask;
+}
+
+static unsigned int eq3loop_poll(struct file* filp, poll_table* wait)
+{
+	struct eq3loop_connection_data *conn = filp->private_data;
+	if( !conn )
+	{
+		return -EINVAL;
+	}
+	if( conn->poll )
+	{
+		return conn->poll( conn->channel, filp, wait );
+	}
+	
+	return -EINVAL;
+}
+
+
+static long eq3loop_create_slave_dev( struct file *filp, const char* name )
+{
+	int channel_index = 0;
+	long ret = 0;
+	struct eq3loop_channel_data* channel;
+	struct eq3loop_connection_data* conn;
+	
+	if (down_interruptible(&control_data->sem))
+	return -ERESTARTSYS;
+	
+	while( (channel_index < EQ3LOOP_NUMBER_OF_CHANNELS) &&  (control_data->channels[channel_index].created) )
+	{
+		channel_index++;
+	}
+	if( channel_index >= EQ3LOOP_NUMBER_OF_CHANNELS )
+	{
+		ret = -EINVAL;
+		goto out;
+	}
+	
+	channel = control_data->channels + channel_index;
+	memset( channel, 0, sizeof( struct eq3loop_channel_data ) );
+	channel->devnode = MKDEV(MAJOR(control_data->devnode), MINOR(control_data->devnode) + channel_index + 1);
+	strncpy( channel->name, name, sizeof(channel->name)-1 );
+	
+	if( !device_create(control_data->class, NULL, channel->devnode, "%s", name) )
+	{
+		ret = -EBUSY;
+		goto out;
+	}
+	
+	printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": created slave %s\n", name );
+
+	conn = kzalloc( sizeof(struct eq3loop_connection_data), GFP_KERNEL );
+	if( !conn )
+	{
+		ret = -ENOMEM;
+		goto out;
+	}
+	
+	sema_init(&channel->sem, 1);
+	init_waitqueue_head(&channel->master2slaveq);
+	init_waitqueue_head(&channel->slave2masterq);
+	
+	
+	channel->master2slave_buf.buf = channel->_master2slave_buf;
+	channel->slave2master_buf.buf = channel->_slave2master_buf;
+	
+	smp_mb();
+	
+	channel->created = 1;
+	
+	
+out:
+	up(&control_data->sem);
+	
+	if( !ret )
+	{ 
+		conn->connection_type = CONNECTION_TYPE_MASTER;
+		conn->channel = channel;
+		conn->read = eq3loop_read_master;
+		conn->write = eq3loop_write_master;
+		conn->ioctl = eq3loop_ioctl_master;
+		conn->close = eq3loop_close_master;
+		conn->poll = eq3loop_poll_master;
+		filp->private_data = conn;
+	}
+	return ret;
+}
+
+static int eq3loop_open_ctrl(struct file *filp)
+{
+	return 0;
+}
+
+static int eq3loop_open_slave(struct eq3loop_channel_data* channel, struct file *filp)
+{
+	int ret = 0;
+	struct eq3loop_connection_data* conn;
+	
+	printk( KERN_INFO EQ3LOOP_DRIVER_NAME ": eq3loop_open_slave() %s\n", channel->name );
+	
+	if (down_interruptible(&channel->sem))
+	return -ERESTARTSYS;
+	
+	if( !channel->created )
+	{
+		ret = -ENODEV;
+		goto out;
+	}
+	
+	if( channel->slave_open_count )
+	{
+		ret = -EBUSY;
+		goto out;
+	}
+	
+	conn = kzalloc( sizeof(struct eq3loop_connection_data), GFP_KERNEL );
+	if( !conn )
+	{
+		ret = -ENOMEM;
+		goto out;
+	}
+	
+	channel->slave_open_count++;
+	
+	set_bit( EVENT_BIT_SLAVE_OPENED, &channel->pending_events );
+	set_bit( STATE_BIT_SLAVE_OPENED, &channel->pending_events );
+	
+	channel->master2slave_buf.head = 0;
+	channel->master2slave_buf.tail = 0;
+	
+	smp_mb();
+	
+out:
+	up( &channel->sem );
+	
+	if( !ret )
+	{ 
+		conn->connection_type = CONNECTION_TYPE_SLAVE;
+		conn->channel = channel;
+		conn->read = eq3loop_read_slave;
+		conn->write = eq3loop_write_slave;
+		conn->ioctl = eq3loop_ioctl_slave;
+		conn->close = eq3loop_close_slave;
+		conn->poll = eq3loop_poll_slave;
+		filp->private_data = conn;
+		wake_up_interruptible( &channel->slave2masterq );
+	}
+	return ret;
+}
+
+
+static int eq3loop_open(struct inode *inode, struct file *filp)
+{
+	if( !control_data )
+	{
+		return -ENODEV;
+	}
+	
+	if( inode->i_rdev == MKDEV(MAJOR(control_data->devnode), MINOR(control_data->devnode)) )
+	{
+		return eq3loop_open_ctrl( filp );
+	}else{
+		unsigned int channel_index = MINOR( inode->i_rdev ) - MINOR(control_data->devnode) - 1;
+		if( channel_index >= EQ3LOOP_NUMBER_OF_CHANNELS )
+		{
+			return -ENODEV;
+		}
+		return eq3loop_open_slave( &control_data->channels[channel_index], filp );
+	}
+	
+	return -ENODEV;
+}
+
+static struct file_operations eq3loop_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= eq3loop_read,
+	.write		= eq3loop_write,
+	.open		= eq3loop_open,
+	.release	= eq3loop_close,
+	.poll       = eq3loop_poll,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11))
+	.ioctl      = eq3loop_ioctl,
+#else
+	.unlocked_ioctl = eq3loop_ioctl,
+#endif
+};
+
+static int __init eq3loop_init(void)
+{
+	int ret = 0;
+
+	control_data = kzalloc(sizeof(struct eq3loop_control_data), GFP_KERNEL);
+	if (!control_data) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	ret = alloc_chrdev_region(&control_data->devnode, 0, EQ3LOOP_NUMBER_OF_CHANNELS + 1, EQ3LOOP_DRIVER_NAME);
+	if( ret )
+	{
+		printk(KERN_ERR EQ3LOOP_DRIVER_NAME ": Unable to get device number region\n");
+		goto out_free;
+	}
+	
+	cdev_init(&control_data->cdev, &eq3loop_fops);
+	control_data->cdev.owner=THIS_MODULE;
+	control_data->cdev.ops=&eq3loop_fops;
+	ret=cdev_add(&control_data->cdev, control_data->devnode, EQ3LOOP_NUMBER_OF_CHANNELS + 1);
+	if(ret){
+		printk(KERN_ERR EQ3LOOP_DRIVER_NAME ": Unable to add driver\n");
+		goto out_unregister_chrdev_region;
+	}
+	control_data->class=class_create(THIS_MODULE, EQ3LOOP_DRIVER_NAME);
+	if(IS_ERR(control_data->class)){
+		ret = -EIO;
+		printk(KERN_ERR EQ3LOOP_DRIVER_NAME ": Unable to register driver class\n");
+		goto out_cdev_del;
+	}
+	
+	sema_init(&control_data->sem, 1);
+	
+	device_create(control_data->class, NULL, MKDEV(MAJOR(control_data->devnode), MINOR(control_data->devnode)), "%s", EQ3LOOP_DRIVER_NAME);
+	
+	goto out;
+	
+	out_cdev_del:
+	cdev_del(&control_data->cdev);
+	
+	out_unregister_chrdev_region:
+	unregister_chrdev_region(control_data->devnode, EQ3LOOP_NUMBER_OF_CHANNELS + 1);
+	
+	out_free:
+	kfree(control_data);
+out:
+	return ret;
+}
+
+static void __exit eq3loop_exit(void)
+{
+
+	unregister_chrdev_region(control_data->devnode, EQ3LOOP_NUMBER_OF_CHANNELS + 1);
+	device_destroy(control_data->class, MKDEV(MAJOR(control_data->devnode), MINOR(control_data->devnode)));
+	class_destroy(control_data->class);
+	cdev_del(&control_data->cdev);
+	
+	kfree(control_data);
+	
+	control_data = NULL;
+
+}
+
+module_init(eq3loop_init);
+module_exit(eq3loop_exit);
+MODULE_DESCRIPTION("eQ-3 IPC loopback char driver");
+MODULE_LICENSE("GPL");
+
diff -Naur linux-3.4.11/drivers/char/Kconfig linux-HEAD/drivers/char/Kconfig
--- linux-3.4.11/drivers/char/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/char/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -49,6 +49,32 @@
          If you have an SGI Altix with an attached SABrick
          say Y or M here, otherwise say N.
 
+config MXS_RAW_AUART
+       tristate "iMX28 AUART raw driver"
+       depends on ARCH_MXS
+       help
+	     This driver supports the MXS Application UART (AUART) port as raw character device.
+
+config MXS_RAW_AUART_PORT0
+       bool "Use iMX28 AUART raw driver for AUART0"
+       depends on MXS_RAW_AUART
+	  default n
+       help
+	     Attach the MXS Application UART raw character device to AUART0
+
+config MXS_RAW_AUART_PORT1
+       bool "Use iMX28 AUART raw driver for AUART1"
+       depends on MXS_RAW_AUART
+	  default y
+       help
+	     Attach the MXS Application UART raw character device to AUART1
+
+config EQ3_CHAR_LOOPBACK
+       tristate "eQ3 char loopback device"
+       help
+	     This driver provides a char loopback device used by eQ-3 daemons.
+
+
 source "drivers/tty/serial/Kconfig"
 
 config TTY_PRINTK
@@ -496,6 +522,10 @@
 	  pc8736x_gpio drivers.  If those drivers are built as
 	  modules, this one will be too, named nsc_gpio
 
+config LEVELED_GPIO
+        tristate "GPIO level polling driver"
+	depends on GPIOLIB
+
 config RAW_DRIVER
 	tristate "RAW driver (/dev/raw/rawN)"
 	depends on BLOCK
diff -Naur linux-3.4.11/drivers/char/lvl_gpio.c linux-HEAD/drivers/char/lvl_gpio.c
--- linux-3.4.11/drivers/char/lvl_gpio.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/char/lvl_gpio.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,323 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+
+#include <linux/platform_data/lvl-gpio.h>
+
+enum {
+	LVL_GPIO_ENTRY_FLAG_OPENED,
+	LVL_GPIO_ENTRY_OWNED,
+};
+
+struct lvl_gpio_entry {
+	struct device		dev;
+
+	unsigned int		irq_flags;
+	int			gpio;
+	int			irq;
+	wait_queue_head_t	waitq;
+	unsigned long		flags;
+};
+
+struct lvl_gpio_device {
+	dev_t				devno;
+	struct cdev			cdev;
+	size_t				num_gpio;
+
+	struct lvl_gpio_entry		*entries[];
+};
+
+static irqreturn_t lvl_gpio_irq_handler(int num, void *e_)
+{
+	struct lvl_gpio_entry	*e = e_;
+
+	wake_up_all(&e->waitq);
+	return IRQ_HANDLED;
+}
+
+static int lvl_gpio_open(struct inode *ino, struct file *filp)
+{
+	struct cdev		*cdev = ino->i_cdev;
+	struct lvl_gpio_device	*gdev =
+		container_of(cdev, struct lvl_gpio_device, cdev);
+	size_t			idx = MINOR(ino->i_rdev);
+	struct lvl_gpio_entry	*e;
+	int			rc;
+
+	if (WARN_ON(idx >= gdev->num_gpio))
+		return -ENOENT;
+
+	e = gdev->entries[idx];
+	if (WARN_ON(!e) || !get_device(&e->dev))
+		return -ENOENT;
+
+	if (!test_and_set_bit(LVL_GPIO_ENTRY_FLAG_OPENED, &e->flags)) {
+		rc = request_irq(e->irq, lvl_gpio_irq_handler,
+				 e->irq_flags | IRQF_SHARED,
+				 dev_name(&e->dev), e);
+		if (rc < 0) {
+			dev_err(&e->dev, "failed to request irq #%d: %d\n",
+				e->irq, rc);
+			clear_bit(LVL_GPIO_ENTRY_FLAG_OPENED, &e->flags);
+			put_device(&e->dev);
+			return rc;
+		}
+	}
+	
+	filp->private_data = e;
+	return 0;
+}
+
+static int lvl_gpio_release(struct inode *ino, struct file *filp)
+{
+	struct lvl_gpio_entry	*e = filp->private_data;
+
+	free_irq(e->irq, e);
+	put_device(&e->dev);
+	clear_bit(LVL_GPIO_ENTRY_FLAG_OPENED, &e->flags);
+
+	return 0;
+}
+
+static unsigned int lvl_gpio_poll(struct file *filp,
+				  struct poll_table_struct *wait)
+{
+	struct lvl_gpio_entry	*e = filp->private_data;
+	int			v;
+
+	poll_wait(filp, &e->waitq, wait);
+	v = gpio_get_value_cansleep(e->gpio);
+
+	return v ? (POLLIN|POLLRDNORM) : (POLLOUT|POLLWRNORM);
+}
+
+static long lvl_gpio_ioctl(struct file *filp,
+			   unsigned int cmd, unsigned long args)
+{
+	struct lvl_gpio_entry	*e = filp->private_data;
+
+	return gpio_get_value_cansleep(e->gpio) ? 1 : 0;
+}
+
+struct file_operations		lvl_gpio_fops = {
+	.owner		=  THIS_MODULE,
+	.open		=  lvl_gpio_open,
+	.release	=  lvl_gpio_release,
+	.poll		=  lvl_gpio_poll,
+	.unlocked_ioctl	=  lvl_gpio_ioctl, 
+};
+
+static void lvl_gpio_device_release(struct device *dev)
+{
+	struct lvl_gpio_entry	*e =
+		container_of(dev, struct lvl_gpio_entry, dev);
+
+	if (test_bit(LVL_GPIO_ENTRY_OWNED, &e->flags))
+		gpio_free(e->gpio);
+
+	kfree(e);
+}
+
+static int __devinit lvl_gpio_init_entry(struct platform_device *pdev,
+					 struct lvl_gpio_device *gdev,
+					 struct lvl_gpio_gpio const *gp,
+					 size_t idx)
+{
+	struct lvl_gpio_entry		*e;
+	int				rc;
+
+	e = kzalloc(sizeof *e, GFP_KERNEL);
+	if (!e) {
+		dev_err(&pdev->dev, "failed to allocate gpio entry\n");
+		rc = -ENOMEM;
+		goto err;
+	}
+
+	device_initialize(&e->dev);
+	dev_set_name(&e->dev, "gpio/%s", gp->name);
+
+	e->gpio = -1;
+
+	e->dev.devt    = MKDEV(MAJOR(gdev->devno), idx);
+	e->dev.release = lvl_gpio_device_release;
+	e->dev.parent  = &pdev->dev;
+
+	/* request the gpio unless it is managed by somebody else */
+	if (gp->is_managed)
+		rc = 0;
+	else
+		rc = gpio_request(gp->gpio, dev_name(&e->dev));
+
+	if (rc < 0) {
+		dev_err(&e->dev, "failed to request gpio %d: %d\n",
+			gp->gpio, rc);
+		goto err;
+	}
+
+	e->gpio = gp->gpio;
+	if (gp->is_managed)
+		clear_bit(LVL_GPIO_ENTRY_OWNED, &e->flags);
+	else
+		set_bit(LVL_GPIO_ENTRY_OWNED, &e->flags);
+
+	/* configure the gpio unless it is managed by somebody else */
+	if (gp->is_managed)
+		rc  = 0;
+	else
+		rc = gpio_direction_input(e->gpio);
+
+	if (rc < 0) {
+		dev_err(&e->dev, "failed to configure gpio %d: %d\n",
+			e->gpio, rc);
+		goto err;
+	}
+
+	e->irq        = gpio_to_irq(e->gpio);
+	e->irq_flags  = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;
+	e->irq_flags ^= gp->irq_mask;
+
+	init_waitqueue_head(&e->waitq);
+
+	rc = device_add(&e->dev);
+	if (rc < 0) {
+		dev_err(&e->dev, "failed to add device: %d\n", rc);
+		goto err;
+	}
+
+	gdev->entries[idx] = e;
+	return 0;
+
+err:
+	if (e) {
+		if (test_bit(LVL_GPIO_ENTRY_OWNED, &e->flags)) {
+			gpio_free(e->gpio);
+			e->gpio = -1;
+		}
+
+		put_device(&e->dev);
+	}
+	return rc;
+}
+
+static int __devinit lvl_gpio_driver_probe(struct platform_device *pdev)
+{
+	struct lvl_gpio_data const	*ldata = pdev->dev.platform_data;
+	struct lvl_gpio_device		*gdev;
+	int				rc;
+	size_t				i;
+	
+
+	if (!ldata)
+		return -EINVAL;
+
+	gdev = kzalloc(sizeof *gdev + 
+		       ldata->num_gpio * sizeof gdev->entries[0],
+		       GFP_KERNEL);
+	if (!gdev)
+		return -EINVAL;
+
+	rc = alloc_chrdev_region(&gdev->devno, 0, ldata->num_gpio,
+				 dev_name(&pdev->dev));
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to allocate chrdev region: %d\n",
+			rc);
+		gdev->devno = 0;
+		goto err;
+	}
+
+	for (i = 0; i < ldata->num_gpio; ++i) {
+		rc = lvl_gpio_init_entry(pdev, gdev, &ldata->gpios[i], i);
+		if (rc < 0)
+			break;
+	}
+
+	gdev->num_gpio = i;
+
+	if (rc < 0)
+		goto err;
+
+	cdev_init(&gdev->cdev, &lvl_gpio_fops);
+	gdev->cdev.owner = THIS_MODULE;
+
+	rc = cdev_add(&gdev->cdev, gdev->devno, gdev->num_gpio);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to add cdev entries: %d\n", rc);
+		goto err;
+	}
+
+	platform_set_drvdata(pdev, gdev);
+
+	return 0;
+
+err:
+	while (gdev->num_gpio-- > 0) {
+		struct lvl_gpio_entry	*e = gdev->entries[gdev->num_gpio];
+
+		BUG_ON(e == NULL);
+
+		device_del(&e->dev);
+		put_device(&e->dev);
+	}
+
+	if (gdev->devno)
+		unregister_chrdev_region(gdev->devno, ldata->num_gpio);
+
+	kfree(gdev);
+	return rc;
+}
+
+static int __devexit lvl_gpio_driver_remove(struct platform_device *pdev)
+{
+	struct lvl_gpio_device		*gdev = platform_get_drvdata(pdev);
+
+	cdev_del(&gdev->cdev);
+	while (gdev->num_gpio-- > 0) {
+		struct lvl_gpio_entry	*e = gdev->entries[gdev->num_gpio];
+
+		BUG_ON(e == NULL);
+
+		device_del(&e->dev);
+		put_device(&e->dev);
+	}
+	unregister_chrdev_region(gdev->devno, gdev->num_gpio);
+
+	return 0;
+}
+
+static struct platform_driver 		lvl_gpio_driver = {
+	.driver = {
+		.name	= "lvl-gpio",
+	},
+	.probe	= lvl_gpio_driver_probe,
+	.remove = __devexit_p(lvl_gpio_driver_remove),
+};
+
+module_platform_driver(lvl_gpio_driver);
+MODULE_ALIAS("platform:lvl-gpio");
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Enrico Scholz <enrico.scholz@sigma-chemnitz.de>");
diff -Naur linux-3.4.11/drivers/char/Makefile linux-HEAD/drivers/char/Makefile
--- linux-3.4.11/drivers/char/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/char/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -48,6 +48,7 @@
 obj-$(CONFIG_NSC_GPIO)		+= nsc_gpio.o
 obj-$(CONFIG_GPIO_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
+obj-$(CONFIG_LEVELED_GPIO)	+= lvl_gpio.o
 
 obj-$(CONFIG_MWAVE)		+= mwave/
 obj-$(CONFIG_AGP)		+= agp/
@@ -64,3 +65,7 @@
 js-rtc-y = rtc.o
 
 obj-$(CONFIG_TILE_SROM)		+= tile-srom.o
+
+obj-$(CONFIG_MXS_RAW_AUART)     += mxs_raw_auart.o
+
+obj-$(CONFIG_EQ3_CHAR_LOOPBACK)    += eq3_char_loop.o
diff -Naur linux-3.4.11/drivers/char/mxs_raw_auart.c linux-HEAD/drivers/char/mxs_raw_auart.c
--- linux-3.4.11/drivers/char/mxs_raw_auart.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/char/mxs_raw_auart.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,1047 @@
+/*
+* Raw UART driver for HomeMatic CCU2 (Freescale MXS platform)
+*
+* Copyright (c) 2015 by eQ-3 Entwicklung GmbH
+* Author: Lars Reemts, lars.reemts@finalbit.de
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+* General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+*
+*/
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/wait.h>
+#include <linux/poll.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/circ_buf.h>
+#include <linux/cdev.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <asm/termbits.h>
+#include <asm/termios.h>
+#include <asm/ioctls.h>
+
+#include <asm/cacheflush.h>
+
+/*
+* Ioctl definitions
+*/
+
+/* Use 'u' as magic number */
+#define MXS_AUART_IOC_MAGIC  'u'
+
+/*
+* S means "Set" through a ptr,
+* G means "Get": reply by setting through a pointer
+*/
+
+/* Set and get the priority for the current channel */
+#define MXS_AUART_IOCSPRIORITY _IOW(MXS_AUART_IOC_MAGIC,  1, unsigned long)
+#define MXS_AUART_IOCGPRIORITY _IOR(MXS_AUART_IOC_MAGIC,  2, unsigned long)
+
+#define MXS_AUART_IOC_MAXNR 2
+
+#define MXS_AUART_PORTS 5
+#define CIRCBUF_SIZE 1024
+#define BAUD    115200
+
+#define MODNAME "mxs-raw-auart"
+
+/* enable debuging via proc filesystem */
+#define PROC_DEBUG
+
+/* TX FIFO empty interrupt is generated if FIFO is less than this level. */
+#define TXIFSEL   AUART_CTRL2_TXIFSEL_ONE_HALF /* half full, N <= 8 */
+
+/* number of charaters to be written to the TX FIFO at once. */
+/* This number must be selected big enough that a write operation always fills the FIFO above the interrupt threshold defined by TXIFSEL. */
+#define TX_CHUNK_SIZE 11
+
+/* RX FIFO interrupt is generated if FIFO level is above this level */
+#define RXIFSEL AUART_CTRL2_RXIFSEL_ONE_QUARTER /* quarter full, N >= 4 */
+//#define RXIFSEL AUART_CTRL2_RXIFSEL_ONE_HALF /* half full, N >= 8 */
+
+/* notify user space application if nothing was received for the following number of bit times */
+static int rxto=31; /* rx timeout in bit times */
+module_param(rxto, int, S_IRUGO);
+
+/*
+ * Latency calculation *
+ * =================== *
+ * UART settings are 8N1@115k2. This means 10 bits per byte or 0,087ms per byte. Assuming 0,013ms pause between consecutive bytes we calculate with 0,1ms per byte. *
+ * With the above settings the user space application is notified when there are at least 4 bytes in the RX FIFO and if nothing was received for 31 bit times. *
+ * Under these assumptions the maximum receive latency is 3 byte time plus 31 bit times = 0,3ms + 0,27ms = 0,57ms. *
+ * The maximum send latency is determined by the TX FIFO size. The FIFO has 16 entries, each corresponding to 0,087ms wire time. This gives 1,392ms maximum send latency *
+ */
+ 
+/*
+ * Priorites *
+ * ========= *
+ * Each connection from user space is assigned a priority. The default priority is 0. A higher priority can be set using ioctls. *
+ * Write operations from user space are synchronous. The write() function returns after all bytes have been transferred to the TX FIFO. *
+ * A write operation from a channel with a higher priority cancels a lower priority write in progress. *
+ * write() always returns the numer of bytes actually sent.
+ */
+ 
+ 
+
+#define AUART_CTRL0			0x00000000
+#define AUART_CTRL0_SET			0x00000004
+#define AUART_CTRL0_CLR			0x00000008
+#define AUART_CTRL0_TOG			0x0000000c
+#define AUART_CTRL1			0x00000010
+#define AUART_CTRL1_SET			0x00000014
+#define AUART_CTRL1_CLR			0x00000018
+#define AUART_CTRL1_TOG			0x0000001c
+#define AUART_CTRL2			0x00000020
+#define AUART_CTRL2_SET			0x00000024
+#define AUART_CTRL2_CLR			0x00000028
+#define AUART_CTRL2_TOG			0x0000002c
+#define AUART_LINECTRL			0x00000030
+#define AUART_LINECTRL_SET		0x00000034
+#define AUART_LINECTRL_CLR		0x00000038
+#define AUART_LINECTRL_TOG		0x0000003c
+#define AUART_LINECTRL2			0x00000040
+#define AUART_LINECTRL2_SET		0x00000044
+#define AUART_LINECTRL2_CLR		0x00000048
+#define AUART_LINECTRL2_TOG		0x0000004c
+#define AUART_INTR			0x00000050
+#define AUART_INTR_SET			0x00000054
+#define AUART_INTR_CLR			0x00000058
+#define AUART_INTR_TOG			0x0000005c
+#define AUART_DATA			0x00000060
+#define AUART_STAT			0x00000070
+#define AUART_DEBUG			0x00000080
+#define AUART_VERSION			0x00000090
+#define AUART_AUTOBAUD			0x000000a0
+
+#define AUART_CTRL0_SFTRST			(1 << 31)
+#define AUART_CTRL0_CLKGATE			(1 << 30)
+#define AUART_CTRL0_RXTIMEOUT_SHIFT   16
+#define AUART_CTRL0_RXTIMEOUT_MASK   (0x7ff << AUART_CTRL0_RXTIMEOUT_SHIFT)
+
+#define AUART_CTRL2_CTSEN			(1 << 15)
+#define AUART_CTRL2_RTS				(1 << 11)
+#define AUART_CTRL2_RXE				(1 << 9)
+#define AUART_CTRL2_TXE				(1 << 8)
+#define AUART_CTRL2_UARTEN			(1 << 0)
+#define AUART_CTRL2_RXIFSEL_SHIFT   20
+#define AUART_CTRL2_RXIFSEL_MASK   (7 << AUART_CTRL2_RXIFSEL_SHIFT)
+#define AUART_CTRL2_RXIFSEL_NOT_EMPTY   (0 << AUART_CTRL2_RXIFSEL_SHIFT)
+#define AUART_CTRL2_RXIFSEL_ONE_QUARTER   (1 << AUART_CTRL2_RXIFSEL_SHIFT)
+#define AUART_CTRL2_RXIFSEL_ONE_HALF   (2 << AUART_CTRL2_RXIFSEL_SHIFT)
+#define AUART_CTRL2_RXIFSEL_THREE_QUARTER   (3 << AUART_CTRL2_RXIFSEL_SHIFT)
+#define AUART_CTRL2_RXIFSEL_SEVEN_EIGHTS   (4 << AUART_CTRL2_RXIFSEL_SHIFT)
+#define AUART_CTRL2_TXIFSEL_SHIFT   16
+#define AUART_CTRL2_TXIFSEL_MASK   (7 << AUART_CTRL2_TXIFSEL_SHIFT)
+#define AUART_CTRL2_TXIFSEL_NOT_EMPTY   (0 << AUART_CTRL2_TXIFSEL_SHIFT)
+#define AUART_CTRL2_TXIFSEL_ONE_QUARTER   (1 << AUART_CTRL2_TXIFSEL_SHIFT)
+#define AUART_CTRL2_TXIFSEL_ONE_HALF   (2 << AUART_CTRL2_TXIFSEL_SHIFT)
+#define AUART_CTRL2_TXIFSEL_THREE_QUARTER   (3 << AUART_CTRL2_TXIFSEL_SHIFT)
+#define AUART_CTRL2_TXIFSEL_SEVEN_EIGHTS   (4 << AUART_CTRL2_TXIFSEL_SHIFT)
+
+#define AUART_LINECTRL_BAUD_DIVINT_SHIFT	16
+#define AUART_LINECTRL_BAUD_DIVINT_MASK		0xffff0000
+#define AUART_LINECTRL_BAUD_DIVINT(v)		(((v) & 0xffff) << 16)
+#define AUART_LINECTRL_BAUD_DIVFRAC_SHIFT	8
+#define AUART_LINECTRL_BAUD_DIVFRAC_MASK	0x00003f00
+#define AUART_LINECTRL_BAUD_DIVFRAC(v)		(((v) & 0x3f) << 8)
+#define AUART_LINECTRL_WLEN_MASK		0x00000060
+#define AUART_LINECTRL_WLEN(v)			(((v) & 0x3) << 5)
+#define AUART_LINECTRL_FEN			(1 << 4)
+#define AUART_LINECTRL_STP2			(1 << 3)
+#define AUART_LINECTRL_EPS			(1 << 2)
+#define AUART_LINECTRL_PEN			(1 << 1)
+#define AUART_LINECTRL_BRK			(1 << 0)
+
+#define AUART_INTR_ABDIEN			(1 << 27)
+#define AUART_INTR_OEIEN			(1 << 26)
+#define AUART_INTR_BEIEN			(1 << 25)
+#define AUART_INTR_PEIEN			(1 << 24)
+#define AUART_INTR_FEIEN			(1 << 23)
+#define AUART_INTR_RTIEN			(1 << 22)
+#define AUART_INTR_TXIEN			(1 << 21)
+#define AUART_INTR_RXIEN			(1 << 20)
+#define AUART_INTR_CTSMIEN			(1 << 17)
+#define AUART_INTR_ABDIS			(1 << 11)
+#define AUART_INTR_OEIS				(1 << 10)
+#define AUART_INTR_BEIS				(1 << 9)
+#define AUART_INTR_PEIS				(1 << 8)
+#define AUART_INTR_FEIS				(1 << 7)
+#define AUART_INTR_RTIS				(1 << 6)
+#define AUART_INTR_TXIS				(1 << 5)
+#define AUART_INTR_RXIS				(1 << 4)
+#define AUART_INTR_DSRMIS			(1 << 3)
+#define AUART_INTR_DCDMIS			(1 << 2)
+#define AUART_INTR_CTSMIS			(1 << 1)
+#define AUART_INTR_RIMIS			(1 << 0)
+
+#define AUART_STAT_BUSY				(1 << 29)
+#define AUART_STAT_CTS				(1 << 28)
+#define AUART_STAT_TXFE				(1 << 27)
+#define AUART_STAT_TXFF				(1 << 25)
+#define AUART_STAT_RXFE				(1 << 24)
+#define AUART_STAT_OERR				(1 << 19)
+#define AUART_STAT_BERR				(1 << 18)
+#define AUART_STAT_PERR				(1 << 17)
+#define AUART_STAT_FERR				(1 << 16)
+
+struct per_connection_data;
+
+/* Information about a single hardware UART */
+struct mxs_auart_port {
+	unsigned long mapbase;							//physical address of UART registers
+	unsigned long irq;								//interrupt number
+	void __iomem* membase;							//logical address of UART registers
+	int open_count;									//number of open connections
+
+	struct circ_buf rxbuf;							//RX buffer
+	struct per_connection_data* tx_connection;		//connection which is currently sending
+	spinlock_t lock_tx;								//TX lock for accessing tx_connection
+
+	struct semaphore sem;							//semaphore for accessing this struct
+	wait_queue_head_t readq;						//wait queue for read operations
+	wait_queue_head_t writeq;						//wait queue for write operations
+	
+	struct clk *clk;								//System clock assigned to the UART device
+	struct device *dev;								//System device
+	
+	dev_t devnode;									//Major/minor of /dev entry
+	struct cdev cdev;								//character device structure
+	struct class * class;							//driver class
+	
+	struct termios termios;							//dummy termios for emulating tty ioctls
+	
+	int count_tx;									//Statistic counter: Number of bytes transmitted
+	int count_rx;									//Statistic counter: Number of bytes received
+	int count_brk;									//Statistic counter: Number of break conditions received
+	int count_parity;								//Statistic counter: Number of parity errors
+	int count_frame;								//Statistic counter: Number of frame errors
+	int count_overrun;								//Statistic counter: Number of RX overruns in hardware FIFO
+	int count_buf_overrun;							//Statistic counter: Number of RX overruns in user space buffer
+};
+
+/* Information about a single connection from user space */
+struct per_connection_data
+{
+	unsigned char txbuf[512];				//tx buffer. For HM-MOD-UART set buffer size at least to 3072
+	size_t tx_buf_length;					//length of tx frame transmitted from userspace
+	size_t tx_buf_index;					//index into txbuf
+	
+	struct mxs_auart_port* port;			//corresponding port
+	
+	unsigned long priority;					//priority of the corresponding channel
+
+	struct semaphore sem;					//semaphore for accessing this struct. 
+};
+
+/* Array of port information for ports handled by this driver */
+static struct mxs_auart_port *auart_port[MXS_AUART_PORTS];
+
+static void mxs_raw_auart_start_tx(struct mxs_auart_port *port);
+static struct mxs_auart_port* mxs_raw_auart_port_by_devnode( dev_t devnode );
+
+/* read() function. */
+static ssize_t mxs_raw_auart_read(struct file *filp, char *buf, size_t count, loff_t *offset)
+{
+	struct per_connection_data *conn = filp->private_data;
+	struct mxs_auart_port *port = conn->port;
+
+	if (down_interruptible(&port->sem))
+	return -ERESTARTSYS;
+	
+	while(!CIRC_CNT( port->rxbuf.head, port->rxbuf.tail, CIRCBUF_SIZE)) { /* nothing to read */
+		up(&port->sem); /* release the lock */
+		if (filp->f_flags & O_NONBLOCK)
+		return -EAGAIN;
+		if (wait_event_interruptible(port->readq, CIRC_CNT( port->rxbuf.head, port->rxbuf.tail, CIRCBUF_SIZE)))
+		return -ERESTARTSYS; /* signal: tell the fs layer to handle it */
+		/* otherwise loop, but first reacquire the lock */
+		if (down_interruptible(&port->sem))
+		return -ERESTARTSYS;
+	}
+	/* ok, data is there, return something */
+	count = min((int)count, CIRC_CNT_TO_END( port->rxbuf.head, port->rxbuf.tail, CIRCBUF_SIZE));
+	if (copy_to_user(buf, port->rxbuf.buf+port->rxbuf.tail, count)) {
+		up (&port->sem);
+		return -EFAULT;
+	}
+	smp_mb();
+	port->rxbuf.tail = (port->rxbuf.tail + count) & (CIRCBUF_SIZE - 1);
+	up (&port->sem);
+
+	return count;
+}
+
+/* try to become the current sender and start sending. Fails if a higher priority send is in progress */
+static int acquire_sender( struct per_connection_data *conn )
+{
+	int retval = 0;
+	struct mxs_auart_port *port = conn->port;
+	unsigned long lock_flags;
+	int sender_idle;
+	spin_lock_irqsave(&port->lock_tx, lock_flags);
+	sender_idle = port->tx_connection == NULL;
+	if( (port->tx_connection == NULL) || (port->tx_connection->priority < conn->priority) )
+	{
+		port->tx_connection = conn;
+		retval = 1;
+		if( sender_idle )
+		{
+			mxs_raw_auart_start_tx( port );
+		}else{
+			wake_up_interruptible( &port->writeq );
+		}
+	}
+	spin_unlock_irqrestore(&port->lock_tx, lock_flags);
+	return retval;
+}
+
+/* check if sendig by the given connection was completed. Sendig was completed if the sending connection has changed */
+static int send_completed( struct per_connection_data *conn )
+{
+	int retval = 0;
+	struct mxs_auart_port *port = conn->port;
+	unsigned long lock_flags;
+	spin_lock_irqsave(&port->lock_tx, lock_flags);
+	retval = port->tx_connection != conn;
+	spin_unlock_irqrestore(&port->lock_tx, lock_flags);
+	return retval;
+}
+
+/* write() function. Waits until count bytes have been transferred to the TX FIFO. May return less than count if send was interrupted by a higher priority write operation */
+static ssize_t mxs_raw_auart_write(struct file *filp, const char *buf, size_t count, loff_t *offset)
+{
+	struct per_connection_data *conn = filp->private_data;
+	struct mxs_auart_port *port = conn->port;
+	
+	int retval=0;
+	
+	int conn_sem_aquired = 0;/* keep track of aquiring the connection semaphore in order to properly release it */
+
+	if (down_interruptible(&conn->sem))
+	{
+		retval = -ERESTARTSYS;
+		goto exit;
+	}
+	conn_sem_aquired = 1;
+	
+	if( count > sizeof(conn->txbuf)  )
+	{
+		retval =  -EMSGSIZE;
+		goto exit;
+	}
+	
+	if(copy_from_user(conn->txbuf, buf, count)){
+		retval=-EFAULT;
+		goto exit;
+	}
+	
+	conn->tx_buf_index = 0;
+	conn->tx_buf_length = count;
+	smp_wmb();
+	
+	if (wait_event_interruptible(port->writeq, acquire_sender( conn ) )){
+		retval=-ERESTARTSYS;
+		goto exit;
+	}
+	
+	//wait for sending to complete
+	if (wait_event_interruptible(port->writeq, send_completed( conn ) )){
+		retval=-ERESTARTSYS;
+		goto exit;
+	}
+	
+	//return number of characters actually sent
+	retval = conn->tx_buf_index;
+	
+exit:
+	if(conn_sem_aquired)up(&conn->sem);
+	return retval;    
+}
+
+/* Disable TX FIFO interrupt */
+static void mxs_raw_auart_stop_txie(struct mxs_auart_port *port)
+{
+	writel(AUART_INTR_TXIEN, port->membase + AUART_INTR_CLR);
+}
+
+/* Transfer the next chunk of characters from the sending connection to the TX FIFO */
+static inline void mxs_raw_auart_tx_chars(struct mxs_auart_port *port)
+{
+	int tx_count = 0;
+	while( (tx_count < TX_CHUNK_SIZE) && (!(readl(port->membase + AUART_STAT) & AUART_STAT_TXFF)) && (port->tx_connection != NULL) && (port->tx_connection->tx_buf_index < port->tx_connection->tx_buf_length) )
+	{
+		writeb(port->tx_connection->txbuf[port->tx_connection->tx_buf_index], port->membase + AUART_DATA);
+		port->tx_connection->tx_buf_index++;
+		smp_wmb();
+		tx_count++;
+	}
+	if( (port->tx_connection != NULL) && (port->tx_connection->tx_buf_index >= port->tx_connection->tx_buf_length) )
+	{
+		mxs_raw_auart_stop_txie(port);
+		port->tx_connection = NULL;
+		smp_wmb();
+		wake_up_interruptible( &port->writeq );
+	}
+}
+
+/* Read a single character from the RX FIFO and store it in the port's circular RX buffer */
+static void mxs_raw_auart_rx_char(struct mxs_auart_port *port)
+{
+	u32 stat;
+	u8 c;
+
+	c = readl(port->membase + AUART_DATA);
+	stat = readl(port->membase + AUART_STAT);
+
+	port->count_rx++;
+
+	if (stat & AUART_STAT_BERR) {
+		port->count_brk++;
+		goto out;
+	} else if (stat & AUART_STAT_PERR) {
+		port->count_parity++;
+	} else if (stat & AUART_STAT_FERR) {
+		port->count_frame++;
+	}
+
+	if (stat & AUART_STAT_OERR)
+	port->count_overrun++;
+
+	if( CIRC_SPACE( port->rxbuf.head, port->rxbuf.tail, CIRCBUF_SIZE ) )
+	{
+		port->rxbuf.buf[port->rxbuf.head] = c;
+		smp_wmb();
+		port->rxbuf.head = (port->rxbuf.head + 1) & (CIRCBUF_SIZE - 1);
+	}
+out:
+	writel(stat, port->membase + AUART_STAT);
+}
+
+/* Read all available characters from the hardware RX FIFO and store them in the port's circular RX buffer. Notify userspace. */
+static void mxs_raw_auart_rx_chars(struct mxs_auart_port *port)
+{
+	u32 stat = 0;
+
+	for (;;) {
+		stat = readl(port->membase + AUART_STAT);
+		if (stat & AUART_STAT_RXFE)
+		break;
+		mxs_raw_auart_rx_char(port);
+	}
+
+	writel(stat, port->membase + AUART_STAT);
+	wake_up_interruptible( &port->readq );
+}
+
+/* UART interrupt dispatcher for RX and TX interrupts */
+static irqreturn_t mxs_raw_auart_irq_handle(int irq, void *context)
+{
+	u32 istatus, istat;
+	struct mxs_auart_port *port = context;
+
+	istatus = istat = readl(port->membase + AUART_INTR);
+
+	writel(istatus & 0xffffu, port->membase + AUART_INTR_CLR);
+
+	if (istat & (AUART_INTR_RTIS | AUART_INTR_RXIS)) {
+		mxs_raw_auart_rx_chars(port);
+		istat &= ~(AUART_INTR_RTIS | AUART_INTR_RXIS);
+	}
+
+	if (istat & AUART_INTR_TXIS) {
+		spin_lock( &port->lock_tx );
+		mxs_raw_auart_tx_chars(port);
+		spin_unlock( &port->lock_tx );
+		istat &= ~AUART_INTR_TXIS;
+	}
+
+	return IRQ_HANDLED;
+}
+
+/* Reset the UART hardware */ 
+static void mxs_raw_auart_reset(struct mxs_auart_port *port)
+{
+	int i;
+	unsigned int reg;
+
+	while ((readl(port->membase + AUART_CTRL2) & AUART_CTRL2_UARTEN) &&	(readl(port->membase + AUART_STAT) & AUART_STAT_BUSY))
+		schedule();
+
+	writel(AUART_CTRL2_TXE, port->membase + AUART_CTRL0_CLR);
+
+	writel(AUART_CTRL0_SFTRST, port->membase + AUART_CTRL0_CLR);
+
+	for (i = 0; i < 10000; i++) {
+		reg = readl(port->membase + AUART_CTRL0);
+		if (!(reg & AUART_CTRL0_SFTRST))
+		break;
+		udelay(3);
+	}
+	writel(AUART_CTRL0_CLKGATE, port->membase + AUART_CTRL0_CLR);
+}
+
+/* Configure and enable the UART hardware */
+static int mxs_raw_auart_startup(struct mxs_auart_port *port)
+{
+	int rc;
+	u32 div, ctrl, ctrl2;
+
+	clk_prepare_enable(port->clk);
+
+	writel(AUART_CTRL0_CLKGATE, port->membase + AUART_CTRL0_CLR);
+
+	writel( AUART_CTRL0_RXTIMEOUT_MASK, port->membase + AUART_CTRL0_CLR);
+	writel( (rxto / 8) << AUART_CTRL0_RXTIMEOUT_SHIFT, port->membase + AUART_CTRL0_SET);
+	writel(3, port->membase + AUART_CTRL0_SET);
+	
+	/* FIFO enable, 8 data bits, no parity */
+	ctrl = AUART_LINECTRL_FEN | AUART_LINECTRL_WLEN(3);
+	
+	/* set baud rate */
+	div = clk_get_rate(port->clk) * 32 / BAUD;
+	ctrl |= AUART_LINECTRL_BAUD_DIVFRAC(div & 0x3F);
+	ctrl |= AUART_LINECTRL_BAUD_DIVINT(div >> 6);
+
+	writel(ctrl, port->membase + AUART_LINECTRL);
+	
+	/* disable + clear interrupts */
+	writel(0, port->membase + AUART_INTR);
+
+	rc = request_irq(port->irq, mxs_raw_auart_irq_handle, 0, dev_name(port->dev), port);
+	if (rc)
+	goto out;
+
+	/* enable RX and TX, set RX FIFO threshold to lowest and TX FIFO threshold to mid */
+	
+	ctrl2 = AUART_CTRL2_UARTEN | AUART_CTRL2_RXE | AUART_CTRL2_TXE | RXIFSEL | TXIFSEL;
+	writel(ctrl2, port->membase + AUART_CTRL2);
+	
+	/*
+	* Enable fifo so all four bytes of a DMA word are written to
+	* output (otherwise, only the LSB is written, ie. 1 in 4 bytes)
+	*/
+	writel(AUART_LINECTRL_FEN, port->membase + AUART_LINECTRL_SET);
+
+	writel(AUART_INTR_OEIEN |
+	AUART_INTR_BEIEN |
+	AUART_INTR_FEIEN |
+	AUART_INTR_RTIEN |
+	AUART_INTR_RXIEN,
+	port->membase + AUART_INTR);
+
+	port->rxbuf.head = port->rxbuf.tail = 0;
+	rc = 0;
+
+out:
+	if (rc < 0)
+	clk_disable(port->clk);
+
+	return rc;
+}
+
+/* Disable the UART hardware */
+static void mxs_raw_auart_shutdown(struct mxs_auart_port *port)
+{
+
+	writel(AUART_CTRL2_UARTEN, port->membase + AUART_CTRL2_CLR);
+
+	writel(AUART_CTRL0_CLKGATE, port->membase + AUART_CTRL0_SET);
+
+	writel(AUART_INTR_RXIEN | AUART_INTR_RTIEN | AUART_INTR_CTSMIEN,
+	port->membase + AUART_INTR_CLR);
+
+	free_irq(port->irq, port);
+	clk_disable_unprepare(port->clk);
+}
+
+/* Start sending */
+static void mxs_raw_auart_start_tx(struct mxs_auart_port *port)
+{
+	/* enable transmitter */
+	writel(AUART_CTRL2_TXE, port->membase + AUART_CTRL2_SET);
+
+	/* clear + enable TX interrupts */
+	writel(AUART_INTR_TXIS,  port->membase + AUART_INTR_CLR);
+	writel(AUART_INTR_TXIEN, port->membase + AUART_INTR_SET);
+
+	mxs_raw_auart_tx_chars(port);
+}
+
+/* Get the port structure for a given device node (major/minor) */
+static struct mxs_auart_port * mxs_raw_auart_port_by_devnode( dev_t devnode )
+{
+	int i;
+	for( i = 0; i < MXS_AUART_PORTS; i++ )
+	{
+		if( auart_port[i] && auart_port[i]->devnode == devnode )
+		{
+			return auart_port[i];
+		}
+	}
+	return NULL;
+}
+
+
+/* open(). Attach to UART port identified by devnode. If necessary, perform initialization and enable port for reception */
+static int mxs_raw_auart_open(struct inode *inode, struct file *filp)
+{
+	int retval;
+	struct mxs_auart_port *port = mxs_raw_auart_port_by_devnode(inode->i_rdev);
+	struct per_connection_data* conn;
+	
+	if( !port )
+	{
+		return -ENODEV;
+	}
+	
+	if (down_interruptible(&port->sem)){
+		return -ERESTARTSYS;
+	}
+	
+	if( !port->open_count ){
+		port->rxbuf.head = port->rxbuf.tail = 0;
+		retval = mxs_raw_auart_startup( port );
+		if(retval){
+			up(&port->sem);
+			return retval;
+		}
+		init_waitqueue_head(&port->writeq);
+		init_waitqueue_head(&port->readq);
+	}
+	port->open_count++;
+
+	up(&port->sem);
+
+	conn = kmalloc( sizeof( struct per_connection_data ), GFP_KERNEL );
+	memset( conn, 0, sizeof( struct per_connection_data ) );
+	conn->port = port;
+
+	sema_init(&conn->sem, 1);
+
+	filp->private_data = (void *)conn;
+	
+	return 0;
+}
+
+/* close(). Remove conection. If necessary, disable UART port */
+static int mxs_raw_auart_close(struct inode *inode, struct file *filp)
+{
+	struct per_connection_data *conn = filp->private_data;
+	struct mxs_auart_port *port = conn->port;
+
+	if (down_interruptible(&conn->sem)){
+		return -ERESTARTSYS;
+	}
+
+	kfree(conn);
+	
+	if (down_interruptible(&port->sem)){
+		return -ERESTARTSYS;
+	}
+	
+	port->open_count--;
+	
+	if(!port->open_count){
+		mxs_raw_auart_shutdown( port);
+	}
+	
+	up(&port->sem);
+	
+	return 0;
+}
+
+/* poll(). Called from userspace to request notification if port becomes readable or writeable. */
+static unsigned int mxs_raw_auart_poll(struct file* filp, poll_table* wait)
+{
+	unsigned int mask=0;
+	struct per_connection_data *conn = filp->private_data;
+	struct mxs_auart_port *port = conn->port;
+	unsigned long lock_flags;
+	
+	poll_wait(filp, &port->readq, wait);
+	poll_wait(filp, &port->writeq, wait);
+	
+	spin_lock_irqsave(&port->lock_tx, lock_flags);
+	if( (port->tx_connection == NULL) || (port->tx_connection->priority < conn->priority) )
+	{
+		mask |= POLLOUT | POLLWRNORM;
+	}
+	spin_unlock_irqrestore(&port->lock_tx, lock_flags);
+	
+	if( CIRC_CNT(port->rxbuf.head, port->rxbuf.tail, CIRCBUF_SIZE) > 0 ) mask |= POLLIN | POLLRDNORM;
+	return mask;
+}
+
+/* ioctl(). Called from userspace to set the connection priority. Emulates a subset of TTY ioctls used by some userspace tools. */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11))
+static int mxs_raw_auart_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg)
+#else
+static long mxs_raw_auart_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+#endif
+{
+	struct per_connection_data *conn = filp->private_data;
+	struct mxs_auart_port *port = conn->port;
+	int err = 0;
+	int ret = 0;
+	unsigned long temp;
+	
+	if (_IOC_TYPE(cmd) == MXS_AUART_IOC_MAGIC)
+	{
+		/*
+		* extract the type and number bitfields, and don't decode
+		* wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok()
+		*/
+		if (_IOC_NR(cmd) > MXS_AUART_IOC_MAXNR) return -ENOTTY;
+
+		/*
+		* the direction is a bitmask, and VERIFY_WRITE catches R/W
+		* transfers. `Type' is user-oriented, while
+		* access_ok is kernel-oriented, so the concept of "read" and
+		* "write" is reversed
+		*/
+		if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+		else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err =  !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+		if (err) return -EFAULT;
+	}
+
+	if (down_interruptible(&conn->sem))
+		return -ERESTARTSYS;
+	
+	switch(cmd) {
+
+	/* Set connection priority */
+	case MXS_AUART_IOCSPRIORITY: /* Set: arg points to the value */
+		ret = __get_user(temp, (unsigned long *)arg);
+		if(ret)break;
+		conn->priority = temp;
+		break;
+
+	/* Get connection priority */
+	case MXS_AUART_IOCGPRIORITY: /* Get: arg is pointer to result */
+		ret = __put_user(conn->priority, (unsigned long *)arg);
+		break;
+		
+	/* Emulated TTY ioctl: Get termios struct */
+	case TCGETS:
+		if( access_ok(VERIFY_READ, (void *)arg, sizeof(struct termios) ) )
+		{
+			if (down_interruptible(&port->sem))
+			{
+				ret = -ERESTARTSYS;
+			}else{
+				ret = copy_to_user( (void*)arg, &port->termios, sizeof(struct termios) );
+				up(&port->sem);
+			}
+		} else {
+			ret = -EFAULT;
+		}
+	break;
+	
+	/* Emulated TTY ioctl: Set termios struct */
+	case TCSETS:
+		if( access_ok(VERIFY_WRITE, (void *)arg, sizeof(struct termios) ) )
+		{
+			if (down_interruptible(&port->sem))
+			{
+				ret = -ERESTARTSYS;
+			}else{
+				ret = copy_from_user( &port->termios, (void*)arg, sizeof(struct termios) );
+				up(&port->sem);
+			}
+		} else {
+			ret = -EFAULT;
+		}
+		break;
+		
+	/* Emulated TTY ioctl: Get receive queue size */
+	case TIOCINQ:
+		if (down_interruptible(&port->sem))
+		{
+			ret = -ERESTARTSYS;
+		}else{
+			temp = CIRC_CNT( port->rxbuf.head, port->rxbuf.tail, CIRCBUF_SIZE);
+			up(&port->sem);
+			ret = __put_user( temp, (int*)arg );
+		}
+		break;
+		
+	/* Emulated TTY ioctl: Get send queue size */
+	case TIOCOUTQ:
+		temp = 0;
+		ret = __put_user( temp, (int*)arg );
+		break;
+		
+	/* Emulated TTY ioctl: Exclusive use */
+	case TIOCEXCL:
+		break;
+		
+	/* Emulated TTY ioctl: Flush */
+	case TCFLSH:
+		break;
+		
+	/* Emulated TTY ioctl: Get states of modem control lines */
+	case TIOCMGET:
+		temp = TIOCM_DSR | TIOCM_CD | TIOCM_CTS;
+		ret = __put_user( temp, (int*)arg );
+		break;
+		
+	/* Emulated TTY ioctl: Set states of modem control lines */
+	case TIOCMSET:
+		break;
+
+	default:
+		ret = -ENOTTY;
+	}
+	
+	up(&conn->sem);
+	return ret;
+
+}
+
+
+
+static struct file_operations mxs_raw_auart_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= mxs_raw_auart_read,
+	.write		= mxs_raw_auart_write,
+	.open		= mxs_raw_auart_open,
+	.release	= mxs_raw_auart_close,
+	.poll       = mxs_raw_auart_poll,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11))
+	.ioctl      = mxs_raw_auart_ioctl,
+#else
+	.unlocked_ioctl = mxs_raw_auart_ioctl,
+#endif
+};
+
+#ifdef PROC_DEBUG
+/* Provides values of relevant hardware registers and statistical information via /proc filesystem. Useful for debugging */
+static int mxs_raw_auart_read_procmem(char* buf, char** start, off_t offset, int count, int* eof, void* data)
+{
+	struct mxs_auart_port *port = data;
+	int len = 0;
+	
+	len += sprintf(buf+len, "CTRL0    =%08X\n", readl(port->membase + AUART_CTRL0));
+	len += sprintf(buf+len, "CTRL1    =%08X\n", readl(port->membase + AUART_CTRL1));
+	len += sprintf(buf+len, "CTRL2    =%08X\n", readl(port->membase + AUART_CTRL2));
+	len += sprintf(buf+len, "LINECTRL =%08X\n", readl(port->membase + AUART_LINECTRL));
+	len += sprintf(buf+len, "INTR     =%08X\n", readl(port->membase + AUART_INTR));
+	len += sprintf(buf+len, "STAT     =%08X\n", readl(port->membase + AUART_STAT));
+
+	len += sprintf( buf+len, "open_count=%d\n", port->open_count);
+	len += sprintf( buf+len, "count_tx=%d\n", port->count_tx);
+	len += sprintf( buf+len, "count_rx=%d\n", port->count_rx);
+	len += sprintf( buf+len, "count_brk=%d\n", port->count_brk);
+	len += sprintf( buf+len, "count_parity=%d\n", port->count_parity);
+	len += sprintf( buf+len, "count_frame=%d\n", port->count_frame);
+	len += sprintf( buf+len, "count_overrun=%d\n", port->count_overrun);
+	len += sprintf( buf+len, "rxbuf_size=%d\n", CIRC_CNT(port->rxbuf.head, port->rxbuf.tail, CIRCBUF_SIZE));
+	len += sprintf( buf+len, "rxbuf_head=%d\n", port->rxbuf.head);
+	len += sprintf( buf+len, "rxbuf_tail=%d\n", port->rxbuf.tail);
+	
+	*eof = 1;
+	return len;
+}
+#endif
+
+/* Exit function called once for every UART port handled by this driver. */
+static int __devexit mxs_raw_auart_remove(struct platform_device *pdev)
+{
+	struct mxs_auart_port *port = platform_get_drvdata(pdev);
+	
+#ifdef PROC_DEBUG
+	{
+		char proc_name[32];
+		sprintf( proc_name, "mxs_auart_raw.%d", pdev->id );
+		remove_proc_entry(proc_name, NULL);
+	}
+#endif
+	
+	device_destroy(port->class, MKDEV(MAJOR(port->devnode), MINOR(port->devnode)));
+	class_destroy(port->class);
+	cdev_del(&port->cdev);
+	unregister_chrdev_region(port->devnode, 1);
+	
+
+	auart_port[pdev->id] = NULL;
+
+	clk_put(port->clk);
+	
+	kfree(port->rxbuf.buf);
+	
+	kfree(port);
+
+	return 0;
+}
+
+/* Probe function called once for every UART port handled by this driver */
+static int __devinit mxs_raw_auart_probe(struct platform_device *pdev)
+{
+	struct mxs_auart_port *port;
+	u32 version;
+	int ret = 0;
+	struct resource *r;
+	char clk_name[32];
+	char dev_name[32];
+
+	port = kzalloc(sizeof(struct mxs_auart_port), GFP_KERNEL);
+	if (!port) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	sprintf( clk_name, "mxs-auart.%d", pdev->id );
+
+	port->clk = clk_get_sys(clk_name, NULL);
+	if (IS_ERR(port->clk)) {
+		printk(KERN_ERR "mxs_auart_raw: Unable to get device clock %s\n", clk_name);
+		ret = PTR_ERR(port->clk);
+		goto out_free;
+	}
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		printk(KERN_ERR "mxs_auart_raw: Unable to get mem resource\n");
+		ret = -ENXIO;
+		goto out_free_clk;
+	}
+
+	sprintf( dev_name, "mxs_auart_raw.%d", pdev->id );
+	
+	ret = alloc_chrdev_region(&port->devnode, 0, 1, dev_name);
+	if( ret )
+	{
+		printk(KERN_ERR "mxs_auart_raw: Unable to get device number region\n");
+		goto out_free_clk;
+	}
+	cdev_init(&port->cdev, &mxs_raw_auart_fops);
+	port->cdev.owner=THIS_MODULE;
+	port->cdev.ops=&mxs_raw_auart_fops;
+	ret=cdev_add(&port->cdev, port->devnode, 1);
+	if(ret){
+		printk(KERN_ERR "mxs_auart_raw: Unable to add driver\n");
+		goto out_unregister_chrdev_region;
+	}
+	port->class=class_create(THIS_MODULE, dev_name);
+	if(IS_ERR(port->class)){
+		ret = -EIO;
+		printk(KERN_ERR "mxs_auart_raw: Unable to register driver class\n");
+		goto out_cdev_del;
+	}
+	
+	device_create(port->class, NULL, MKDEV(MAJOR(port->devnode), MINOR(port->devnode)), "%s", dev_name);
+	
+
+	port->mapbase = r->start;
+	port->membase = ioremap(r->start, resource_size(r));
+	port->dev = get_device(&pdev->dev);
+	port->irq = platform_get_irq(pdev, 0);
+	
+	sema_init(&port->sem, 1);
+	spin_lock_init(&port->lock_tx);
+	init_waitqueue_head(&port->readq);
+	init_waitqueue_head(&port->writeq);
+	
+	port->rxbuf.buf = kmalloc(CIRCBUF_SIZE, GFP_KERNEL);
+	
+	platform_set_drvdata(pdev, port);
+
+	auart_port[pdev->id] = port;
+
+	mxs_raw_auart_reset(port);
+
+	version = readl(port->membase + AUART_VERSION);
+	dev_info(&pdev->dev, "Found raw APPUART %d.%d.%d\n",
+	(version >> 24) & 0xff,
+	(version >> 16) & 0xff, version & 0xffff);
+
+#ifdef PROC_DEBUG
+	{
+		create_proc_read_entry(dev_name, 0, NULL, mxs_raw_auart_read_procmem, port);
+	}
+#endif
+
+	return 0;
+
+	auart_port[pdev->id] = NULL;
+
+	out_cdev_del:
+	cdev_del(&port->cdev);
+	
+	out_unregister_chrdev_region:
+	unregister_chrdev_region(port->devnode, 1);
+	
+	out_free_clk:
+	clk_put(port->clk);
+	out_free:
+	kfree(port);
+out:
+	return ret;
+}
+
+
+static struct platform_driver mxs_auart_driver = {
+	.probe = mxs_raw_auart_probe,
+	.remove = __devexit_p(mxs_raw_auart_remove),
+	.driver = {
+		.name = MODNAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+/* Init funtion for this driver. */
+static int __init mxs_raw_auart_init(void)
+{
+	int r;
+	
+	memset( auart_port, 0, sizeof(auart_port) );
+	r = platform_driver_register(&mxs_auart_driver);
+	if (r)
+	goto out;
+
+	return 0;
+
+out:
+	return r;
+}
+
+/* Exit function for this driver */
+static void __exit mxs_raw_auart_exit(void)
+{
+	platform_driver_unregister(&mxs_auart_driver);
+}
+
+module_init(mxs_raw_auart_init);
+module_exit(mxs_raw_auart_exit);
+MODULE_DESCRIPTION("eQ-3 raw MXS application uart driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.4.11/drivers/gpio/gpio-mxs.c linux-HEAD/drivers/gpio/gpio-mxs.c
--- linux-3.4.11/drivers/gpio/gpio-mxs.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/gpio/gpio-mxs.c	2015-11-18 09:04:24.000000000 +0000
@@ -57,6 +57,7 @@
 	int id;
 	int irq;
 	int virtual_irq_start;
+	unsigned long both_edge;
 	struct bgpio_chip bgc;
 };
 
@@ -68,9 +69,12 @@
 	u32 pin_mask = 1 << (gpio & 31);
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mxs_gpio_port *port = gc->private;
+	int lvl;
 	void __iomem *pin_addr;
 	int edge;
 
+	clear_bit(gpio & 31, &port->both_edge);
+
 	switch (type) {
 	case IRQ_TYPE_EDGE_RISING:
 		edge = GPIO_INT_RISE_EDGE;
@@ -84,6 +88,14 @@
 	case IRQ_TYPE_LEVEL_HIGH:
 		edge = GPIO_INT_HIGH_LEV;
 		break;
+	case IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING:
+		/* mx28 does not support triggering irq by both edges; emulate
+		 * behavior by configuring irq as level triggered and update
+		 * irq polarity in the irq handler */
+		set_bit(gpio & 31, &port->both_edge);
+		lvl  = readl(port->base + PINCTRL_DIN(port->id));
+		edge = (lvl & pin_mask) ? GPIO_INT_LOW_LEV : GPIO_INT_HIGH_LEV;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -114,11 +126,26 @@
 	u32 irq_stat;
 	struct mxs_gpio_port *port = irq_get_handler_data(irq);
 	u32 gpio_irq_no_base = port->virtual_irq_start;
+	void __iomem *base = port->base;
+	u32 pol_msk;
 
 	desc->irq_data.chip->irq_ack(&desc->irq_data);
 
-	irq_stat = readl(port->base + PINCTRL_IRQSTAT(port->id)) &
-			readl(port->base + PINCTRL_IRQEN(port->id));
+	irq_stat = readl(base + PINCTRL_IRQSTAT(port->id)) &
+			readl(base + PINCTRL_IRQEN(port->id));
+
+	/* handle irqs triggered by both edges */
+	pol_msk = irq_stat & port->both_edge;
+	if (pol_msk) {
+		void __iomem *reg = base + PINCTRL_IRQPOL(port->id);
+		u32 port_lvl = readl(base + PINCTRL_DIN(port->id));
+
+		/* \todo write into the TOGGLE register (without reading port
+		 * level register); this requires a special unmask operation
+		 * which updates the IRQPOL register */
+		writel(pol_msk & port_lvl, reg + MXS_CLR);
+		writel(pol_msk & ~port_lvl, reg + MXS_SET);
+	}
 
 	while (irq_stat != 0) {
 		int irqoffset = fls(irq_stat) - 1;
diff -Naur linux-3.4.11/drivers/gpio/gpio-pxa.c linux-HEAD/drivers/gpio/gpio-pxa.c
--- linux-3.4.11/drivers/gpio/gpio-pxa.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/gpio/gpio-pxa.c	2015-11-18 09:04:24.000000000 +0000
@@ -21,6 +21,7 @@
 #include <linux/platform_device.h>
 #include <linux/syscore_ops.h>
 #include <linux/slab.h>
+#include <linux/module.h>
 
 #include <mach/irqs.h>
 
@@ -55,6 +56,7 @@
 #define BANK_OFF(n)	(((n) < 3) ? (n) << 2 : 0x100 + (((n) - 3) << 2))
 
 int pxa_last_gpio;
+EXPORT_SYMBOL(pxa_last_gpio);
 
 struct pxa_gpio_chip {
 	struct gpio_chip chip;
@@ -563,7 +565,7 @@
 		irq <= gpio_to_irq(pxa_last_gpio); irq++) {
 		irq_set_chip_and_handler(irq, &pxa_muxed_gpio_chip,
 					 handle_edge_irq);
-		set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+		set_irq_flags(irq, IRQF_VALID);
 	}
 
 	irq_set_chained_handler(irq_mux, pxa_gpio_demux_handler);
diff -Naur linux-3.4.11/drivers/gpio/Kconfig linux-HEAD/drivers/gpio/Kconfig
--- linux-3.4.11/drivers/gpio/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/gpio/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -190,6 +190,10 @@
 	  additional drivers must be enabled in order to use the
 	  functionality of the device.
 
+config GPIO_KUK_TTLIO
+	tristate "TTLIO driver Keith & Koep Board CPLDs"
+	depends on GPIOLIB && HAVE_KUK_CPLD
+
 config GPIO_GE_FPGA
 	bool "GE FPGA based GPIO"
 	depends on GE_FPGA
diff -Naur linux-3.4.11/drivers/gpio/kuk-ttlio.c linux-HEAD/drivers/gpio/kuk-ttlio.c
--- linux-3.4.11/drivers/gpio/kuk-ttlio.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/gpio/kuk-ttlio.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,211 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@informatik.tu-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+
+struct kuk_ttlio_device {
+	struct gpio_chip	gpio;
+	spinlock_t		lock;
+	unsigned long		shadow_out;
+	struct resource		*res_mem;
+	void __iomem		*iobase;
+
+	unsigned int		num_input;
+	unsigned int		num_output;
+};
+
+#define to_kuk_ttlio(_gpio) \
+	container_of(_gpio, struct kuk_ttlio_device, gpio)
+
+static void kuk_ttlio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct kuk_ttlio_device	*tdev = to_kuk_ttlio(chip);
+	unsigned long		flags;
+
+	if (offset < tdev->num_input)
+		return;
+
+	if (offset >= tdev->num_input + tdev->num_output)
+		return;
+
+	spin_lock_irqsave(&tdev->lock, flags);
+
+	if (value)
+		set_bit(offset - tdev->num_input,   &tdev->shadow_out);
+	else
+		clear_bit(offset - tdev->num_input, &tdev->shadow_out);
+
+	__raw_writew(tdev->shadow_out, tdev->iobase);
+
+	spin_unlock_irqrestore(&tdev->lock, flags);
+}
+
+static int kuk_ttlio_get(struct gpio_chip *chip, unsigned int offset)
+{
+	struct kuk_ttlio_device	*tdev = to_kuk_ttlio(chip);
+
+	if (offset < tdev->num_input)
+		return __raw_readw(tdev->iobase) & (1 << offset);
+	else
+		return tdev->shadow_out & (1 << (offset - tdev->num_input));
+}
+
+static int kuk_ttlio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	struct kuk_ttlio_device	*tdev = to_kuk_ttlio(chip);
+
+	if (offset >= tdev->num_input)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int kuk_ttlio_direction_output(struct gpio_chip *chip, unsigned offset,
+				      int value)
+{
+	struct kuk_ttlio_device	*tdev = to_kuk_ttlio(chip);
+
+	if (offset < tdev->num_input)
+		return -EINVAL;
+
+	if (offset >= tdev->num_input + tdev->num_output)
+		return -EINVAL;
+
+	kuk_ttlio_set(chip, offset, value);
+	return 0;
+}
+
+static int __devinit kuk_ttlio_probe(struct platform_device *pdev)
+{
+	struct kuk_ttlio_device		*tdev;
+	struct gpio_chip		*gc;
+	unsigned long			start_gpio;
+	struct resource			*res_mem;
+	int				rc;
+
+	start_gpio = (uintptr_t)(pdev->dev.platform_data);
+	if (!start_gpio)
+		return -EINVAL;
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res_mem)
+		return -EINVAL;
+
+	tdev = kzalloc(sizeof *tdev, GFP_KERNEL);
+	if (!tdev)
+		return -ENOMEM;
+
+	spin_lock_init(&tdev->lock);
+	tdev->res_mem = request_mem_region(res_mem->start,
+					   resource_size(res_mem),
+					   "K&K GPIO");
+	if (!tdev->res_mem) {
+		rc = -EBUSY;
+		goto err;
+	}
+
+	tdev->num_input  = 8;
+	tdev->num_output = 8;
+	tdev->iobase = ioremap(tdev->res_mem->start,
+			       resource_size(tdev->res_mem));
+	if (!tdev->iobase) {
+		rc = -ENOMEM;
+		goto err;
+	}
+
+	gc = &tdev->gpio;
+
+	gc->label	= dev_name(&pdev->dev);
+	gc->owner	= THIS_MODULE;
+	gc->dev		= &pdev->dev;
+	gc->base	= start_gpio;
+	gc->ngpio	= tdev->num_input + tdev->num_output;
+	gc->can_sleep	= 0;
+
+	gc->direction_input	=  kuk_ttlio_direction_input;
+	gc->direction_output	=  kuk_ttlio_direction_output;
+	gc->get			=  kuk_ttlio_get;
+	gc->set			=  kuk_ttlio_set;
+
+	platform_set_drvdata(pdev, tdev);
+	rc = gpiochip_add(&tdev->gpio);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "gpiochip_add() failed: %d\n", rc);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	if (tdev->iobase)
+		iounmap(tdev->iobase);
+
+	if (tdev->res_mem)
+		release_mem_region(tdev->res_mem->start,
+				   resource_size(tdev->res_mem));
+
+	kfree(tdev);
+
+	return rc;
+}
+
+static int __devinit kuk_ttlio_remove(struct platform_device *pdev)
+{
+	struct kuk_ttlio_device		*tdev = platform_get_drvdata(pdev);
+	int				rc;
+
+	rc = gpiochip_remove(&tdev->gpio);
+	if (rc < 0) {
+		dev_warn(&pdev->dev, "gpiochip_remove(): %d\n", rc);
+		return rc;
+	}
+
+	iounmap(tdev->iobase);
+	release_mem_region(tdev->res_mem->start, resource_size(tdev->res_mem));
+	kfree(tdev);
+
+	return 0;
+}
+
+static struct platform_driver kuk_ttlio_driver = {
+	.driver = {
+		.name	= "kuk-ttlio",
+		.owner	= THIS_MODULE,
+	},
+	.probe	= kuk_ttlio_probe,
+	.remove	= __devexit_p(kuk_ttlio_remove),
+};
+
+static int __init kuk_ttlio_init(void)
+{
+	return platform_driver_register(&kuk_ttlio_driver);
+}
+subsys_initcall(kuk_ttlio_init);
+
+static void __exit kuk_ttlio_exit(void)
+{
+	platform_driver_unregister(&kuk_ttlio_driver);
+}
+module_exit(kuk_ttlio_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Enrico Scholz");
+MODULE_ALIAS("platform:kuk-ttlio");
diff -Naur linux-3.4.11/drivers/gpio/Makefile linux-HEAD/drivers/gpio/Makefile
--- linux-3.4.11/drivers/gpio/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/gpio/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -64,3 +64,6 @@
 obj-$(CONFIG_GPIO_WM8350)	+= gpio-wm8350.o
 obj-$(CONFIG_GPIO_WM8994)	+= gpio-wm8994.o
 obj-$(CONFIG_GPIO_XILINX)	+= gpio-xilinx.o
+
+
+obj-$(CONFIG_GPIO_KUK_TTLIO)	+= kuk-ttlio.o
diff -Naur linux-3.4.11/drivers/hwmon/ad7814.c linux-HEAD/drivers/hwmon/ad7814.c
--- linux-3.4.11/drivers/hwmon/ad7814.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/hwmon/ad7814.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,184 @@
+/*	--*- c -*--
+ * Copyright (C) 2008 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+#include <linux/sysfs.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+
+struct ad7814_dev
+{
+	struct spi_device	*spi;
+	struct device		*dev;
+};
+
+static ssize_t show_temp_param(struct device *dev, struct device_attribute *da,
+			       char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	switch (attr->index) {
+	case 0: return snprintf(buf, PAGE_SIZE, "-128\n");
+	case 1: return snprintf(buf, PAGE_SIZE, "+128\n");
+	default: BUG();
+	}
+}
+
+static ssize_t show_temp(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	struct spi_device		*spi  = to_spi_device(dev);
+	int				rc;
+	signed int			temp;
+
+	union {
+		uint16_t		rx;
+		uint8_t			b[2];
+	}				b;
+
+	rc = spi_read(spi, b.b, 2);
+	if (rc<0)
+		return rc;
+
+	temp = (int16_t)(b.rx << 1);
+
+	dev_dbg(dev, "raw: [%02x,%02x], temp: %02x\n", b.b[0], b.b[1], temp);
+	return snprintf(buf, PAGE_SIZE, "%d\n", (temp*10 >> 6)/4);
+}
+
+static SENSOR_DEVICE_ATTR(temp0_max,   0444, show_temp_param, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp0_min,   0444, show_temp_param, NULL, 1);
+static SENSOR_DEVICE_ATTR(temp0_input, 0400, show_temp,       NULL, 0);
+
+static struct attribute *ad7814_attributes[] = {
+	&sensor_dev_attr_temp0_min.dev_attr.attr,
+	&sensor_dev_attr_temp0_max.dev_attr.attr,
+	&sensor_dev_attr_temp0_input.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group	ad7814_group = {
+	.attrs = ad7814_attributes
+};
+
+static int __devinit ad7814_probe(struct spi_device *spi)
+{
+	struct ad7814_dev	*ad = 0;
+	int			rc;
+
+	spi->mode          = SPI_MODE_3;
+	spi->bits_per_word = 16;
+
+	rc = spi_setup(spi);
+	if (rc<0) {
+		dev_err(&spi->dev, "failed to setup SPI data: %d\n", rc);
+		return rc;
+	}
+
+	ad = kzalloc(sizeof *ad, GFP_KERNEL);
+	if (!ad) {
+		dev_err(&spi->dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	ad->spi = spi;
+	ad->dev = hwmon_device_register(&spi->dev);
+	if (IS_ERR(ad->dev)) {
+		rc      = PTR_ERR(ad->dev);
+		ad->dev = NULL;
+		dev_err(&spi->dev, "failed to register hwmon device: %d\n", rc);
+		goto err;
+	}
+
+	rc = sysfs_create_group(&spi->dev.kobj, &ad7814_group);
+	if (rc<0) {
+		dev_err(&spi->dev, "failed to create sysfs group: %d\n", rc);
+		goto err;
+	}
+
+	dev_set_drvdata(ad->dev, ad);
+	dev_info(&spi->dev, "ads7814 device registered as %s\n",
+		 ad->dev->bus_id);
+	return 0;
+
+err:
+	hwmon_device_unregister(ad->dev);
+	kfree(ad);
+	return rc;
+}
+
+static int __devexit ad7814_remove(struct spi_device *spi)
+{
+	struct ad7814_dev	*ad = spi_get_drvdata(spi);;
+
+
+	sysfs_remove_group(&spi->dev.kobj, &ad7814_group);
+	hwmon_device_unregister(ad->dev);
+	kfree(ad);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int
+ad7814_suspend(struct spi_device *spi, pm_message_t mesg)
+{
+	return 0;
+}
+
+static int
+ad7814_resume(struct spi_device *spi)
+{
+	return 0;
+}
+
+static void
+ad7814_shutdown(struct spi_device *spi)
+{
+}
+#endif
+
+static struct spi_driver	ad7814_driver = {
+	.driver = {
+		.name	=  "ad7814",
+		.bus	=  &spi_bus_type,
+		.owner	=  THIS_MODULE,
+	},
+	.probe		=  ad7814_probe,
+	.remove		=  __devexit_p(ad7814_remove),
+#ifdef CONFIG_PM
+	.suspend	=  ad7814_suspend,
+	.resume		=  ad7814_resume,
+	.shutdown	=  ad7814_shutdown,
+#endif
+};
+
+int __init ad7814_init(void)
+{
+	return spi_register_driver(&ad7814_driver);
+}
+
+void __exit ad7814_exit(void)
+{
+	spi_unregister_driver(&ad7814_driver);
+}
+
+module_init(ad7814_init);
+module_exit(ad7814_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("ad7814");
diff -Naur linux-3.4.11/drivers/hwmon/adc121.c linux-HEAD/drivers/hwmon/adc121.c
--- linux-3.4.11/drivers/hwmon/adc121.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/hwmon/adc121.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,239 @@
+// $Id$    --*- c -*--
+
+// Copyright (C) 2006 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; version 2 of the License.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+
+#define DEBUG
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/jiffies.h>
+#include <linux/delay.h>
+
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+
+#include <linux/spi/spi.h>
+
+#include "adc121.h"
+
+static struct adc121_data *
+adc121_update_device(struct device *dev)
+{
+	struct adc121_data *data	=  dev_get_drvdata(dev);
+
+	mutex_lock(&data->update_lock);
+
+	if (time_after(jiffies, data->last_updated + HZ / 5) ||
+	    !data->valid) {
+		uint16_t		tmp;
+		unsigned long		flags;
+		struct adc121_data	new_data = {
+			.in0_input    = data->in0_input,
+			.last_updated = data->last_updated,
+			.valid        = 0
+		};
+
+		spi_read(data->spi_dev, (void *)&tmp, sizeof tmp);
+		ndelay(75);			/* tQUIET */
+
+		if (spi_read(data->spi_dev, (void *)&tmp, sizeof tmp)<0)
+			dev_err(dev, "failed to read SPI data\n");
+		else if ((tmp&0xe000)!=0)
+			dev_warn(dev, "read invalid data (%04x)\n", tmp);
+		else {
+			dev_dbg(dev, "raw data=%04x\n", tmp);
+
+			tmp                 >>= 1;
+			new_data.in0_input    = tmp & ((1<<12)-1);
+			new_data.valid        = 1;
+			new_data.last_updated = jiffies;
+		}
+
+
+		write_lock_irqsave(&data->lock, flags);
+		data->in0_input    = new_data.in0_input;
+		data->valid        = new_data.valid;
+		data->last_updated = new_data.last_updated;
+		write_unlock_irqrestore(&data->lock, flags);
+	}
+
+	mutex_unlock(&data->update_lock);
+
+	return data;
+}
+
+static int
+adc121_get_in(struct adc121_data *data)
+{
+	unsigned long	flags;
+	int		res;
+
+	read_lock_irqsave(&data->lock, flags);
+	if (data->valid)
+		res = data->in0_input;
+	else
+		res = -1;
+	read_unlock_irqrestore(&data->lock, flags);
+
+	return res;
+}
+
+
+static ssize_t
+show_in0_input(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct adc121_data *data	=  adc121_update_device(dev);
+	return sprintf(buf, "%d\n", adc121_get_in(data));
+}
+
+static ssize_t
+show_in0_min(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", 0);
+}
+
+static ssize_t
+show_in0_max(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", 4095);
+}
+
+static DEVICE_ATTR(in0_input, 0400, show_in0_input, 0);
+static DEVICE_ATTR(in0_min,   0444, show_in0_min,   0);
+static DEVICE_ATTR(in0_max,   0444, show_in0_max,   0);
+
+
+static int __devinit
+adc121_probe(struct spi_device *spi)
+{
+	struct adc121_data	*data = 0;
+	int			rc;
+
+	spi->mode          = SPI_MODE_3;
+	spi->bits_per_word = 16;
+	rc = spi_setup(spi);
+	if (rc<0) {
+		dev_err(&spi->dev, "spi_setup() failed with %i\n", rc);
+		goto err;
+	}
+
+	data = kzalloc(sizeof *data, GFP_KERNEL);
+	if (data==0) {
+		dev_err(&spi->dev, "failed to allocate memory for device data\n");
+		rc = -ENOMEM;
+		goto err;
+	}
+
+	dev_set_drvdata(&spi->dev, data);
+
+	mutex_init(&data->update_lock);
+	rwlock_init(&data->lock);
+
+	data->spi_dev = spi;
+	data->dev     = hwmon_device_register(&spi->dev);
+	if (IS_ERR(data->dev)) {
+		rc = PTR_ERR(data->dev);
+		goto err;
+	}
+
+	if ((rc = device_create_file(&spi->dev, &dev_attr_in0_input))<0 ||
+	    (rc = device_create_file(&spi->dev, &dev_attr_in0_max))<0 ||
+	    (rc = device_create_file(&spi->dev, &dev_attr_in0_min))<0)
+		goto err1;
+
+	return 0;
+
+err1:
+	device_remove_file(&spi->dev, &dev_attr_in0_min);
+	device_remove_file(&spi->dev, &dev_attr_in0_max);
+	device_remove_file(&spi->dev, &dev_attr_in0_input);
+
+	hwmon_device_unregister(data->dev);
+err:
+	kfree(data);
+	return rc;
+}
+
+static int __devexit
+adc121_remove(struct spi_device *spi)
+{
+	struct adc121_data	*data = dev_get_drvdata(&spi->dev);;
+
+	if (data==0)
+		return 0;
+
+	device_remove_file(&spi->dev, &dev_attr_in0_min);
+	device_remove_file(&spi->dev, &dev_attr_in0_max);
+	device_remove_file(&spi->dev, &dev_attr_in0_input);
+
+	hwmon_device_unregister(data->dev);
+	kfree(data);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int
+adc121_suspend(struct spi_device *spi, pm_message_t mesg)
+{
+	return 0;
+}
+
+static int
+adc121_resume(struct spi_device *spi)
+{
+	return 0;
+}
+
+static void
+adc121_shutdown(struct spi_device *spi)
+{
+}
+#endif
+
+
+static struct spi_driver	adc121_driver = {
+	.driver = {
+		.name	=  "adc121",
+		.bus	=  &spi_bus_type,
+		.owner	=  THIS_MODULE,
+	},
+	.probe		=  adc121_probe,
+	.remove		=  __devexit_p(adc121_remove),
+#ifdef CONFIG_PM
+	.suspend	=  adc121_suspend,
+	.resume		=  adc121_resume,
+	.shutdown	=  adc121_shutdown,
+#endif
+};
+
+int __init adc121_init(void)
+{
+	return spi_register_driver(&adc121_driver);
+}
+
+void __exit adc121_exit(void)
+{
+	spi_unregister_driver(&adc121_driver);
+}
+
+module_init(adc121_init);
+module_exit(adc121_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("adc121");
diff -Naur linux-3.4.11/drivers/hwmon/adc121.h linux-HEAD/drivers/hwmon/adc121.h
--- linux-3.4.11/drivers/hwmon/adc121.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/hwmon/adc121.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,39 @@
+// $Id$    --*- c -*--
+
+// Copyright (C) 2006 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; version 2 of the License.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+
+#ifndef H_SIGMA_DRIVERS_HWMON_ADC121_H
+#define H_SIGMA_DRIVERS_HWMON_ADC121_H
+
+struct class_device;
+struct spi_device;
+
+struct adc121_data
+{
+	struct device		*dev;
+	struct spi_device	*spi_dev;
+
+	int			valid;
+	rwlock_t		lock;
+	struct mutex		update_lock;
+	unsigned long		last_updated;
+
+	uint16_t		in0_input;
+
+};
+
+#endif	//  H_SIGMA_DRIVERS_HWMON_ADC121_H
diff -Naur linux-3.4.11/drivers/hwmon/ads782x.c linux-HEAD/drivers/hwmon/ads782x.c
--- linux-3.4.11/drivers/hwmon/ads782x.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/hwmon/ads782x.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,306 @@
+/*	--*- c -*--
+ * Copyright (C) 2008 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* TODO: locking */
+/* TODO: configure number of channels through platform_data */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+
+struct ads782x_attr {
+	struct device_attribute	attr;
+	char			name[sizeof("pdown99")];
+};
+
+struct ads782x_device {
+	uint8_t			diff_setup;
+	uint16_t		pdown_setup;
+
+	struct i2c_client	*i2c;
+	size_t			channels;
+	struct device		*dev;
+
+	struct ads782x_attr	*attr_volt;
+	struct ads782x_attr	*attr_diff;
+	struct ads782x_attr	*attr_pdown;
+};
+
+static void xxx_device_remove_files(struct device *dev, struct ads782x_attr attr[],
+				   size_t num_attr)
+{
+	while (num_attr-->0)
+		device_remove_file(dev, &attr[num_attr].attr);
+}
+
+static int xxx_device_create_files(struct device *dev, struct ads782x_attr attr[],
+				   size_t num_attr)
+{
+	size_t		i;
+	int		rc = 0;
+
+	for (i=0; i<num_attr && likely(rc==0); ++i)
+		rc = device_create_file(dev, &attr[i].attr);
+
+	if (rc)
+		xxx_device_remove_files(dev, attr, i);
+
+	return rc;
+}
+
+#define to_ads782x_device(X)	i2c_get_clientdata(to_i2c_client(X))
+#define to_ads782x_attr(X)	container_of(X, struct ads782x_attr,   attr)
+
+static ssize_t
+ads782x_volt_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct ads782x_device	*ads      = to_ads782x_device(dev);
+	struct ads782x_attr	*ads_attr = to_ads782x_attr(attr);
+	unsigned int		chan      = ads_attr - ads->attr_volt;
+	unsigned int		chnum     = chan/2 | ((chan%2)<<2);
+	uint8_t			cmd;
+	s32			rc;
+
+	BUG_ON(chan>=8);
+
+	/* TODO: locking */
+	cmd = ((((~ads->diff_setup >> (chan/2)) & 1) << 7) |
+	       (chnum << 4) |
+	       (((ads->pdown_setup >> (chan*2)) & 3) << 2));
+
+	rc  = i2c_smbus_read_word_data(ads->i2c, cmd);
+	if (rc<0)
+		return rc;
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", be16_to_cpu(rc));
+}
+
+static ssize_t
+ads782x_diff_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct ads782x_device	*ads      = to_ads782x_device(dev);
+	struct ads782x_attr	*ads_attr = to_ads782x_attr(attr);
+	unsigned int		id        = ads_attr - ads->attr_diff;
+
+	BUG_ON(id>=ads->channels/2);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", (ads->diff_setup >> id) & 1);
+}
+
+static ssize_t
+ads782x_diff_store(struct device *dev, struct device_attribute *attr,
+		   char const *buf, size_t l)
+{
+	struct ads782x_device	*ads      = to_ads782x_device(dev);
+	struct ads782x_attr	*ads_attr = to_ads782x_attr(attr);
+	unsigned int		id        = ads_attr - ads->attr_diff;
+
+	BUG_ON(id>=ads->channels/2);
+
+	/* TODO: locking */
+	if (simple_strtoul(buf, NULL, 2))
+		ads->diff_setup |=  (1<<id);
+	else
+		ads->diff_setup &= ~(1<<id);
+
+	return l;
+}
+
+static ssize_t
+ads782x_pdown_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct ads782x_device	*ads      = to_ads782x_device(dev);
+	struct ads782x_attr	*ads_attr = to_ads782x_attr(attr);
+	unsigned int		id        = ads_attr - ads->attr_pdown;
+
+	BUG_ON(id>=ads->channels);
+
+	return snprintf(buf, PAGE_SIZE, "%u\n", (ads->pdown_setup >> (id*2)) & 3);
+}
+
+static ssize_t
+ads782x_pdown_store(struct device *dev, struct device_attribute *attr,
+		    char const *buf, size_t l)
+{
+	struct ads782x_device	*ads      = to_ads782x_device(dev);
+	struct ads782x_attr	*ads_attr = to_ads782x_attr(attr);
+	unsigned int		id        = ads_attr - ads->attr_pdown;
+
+	BUG_ON(id>=ads->channels);
+
+	id *= 2;
+
+	/* TODO: locking */
+	ads->pdown_setup &= ~(3<<id);
+	ads->pdown_setup |=  (simple_strtoul(buf, NULL, 0) & 3)<<id;
+
+	return l;
+}
+
+static int __devinit ads782x_probe(struct i2c_client *client)
+{
+	struct ads782x_device		*ads;
+	int				rc;
+	size_t				i;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_READ_WORD_DATA)) {
+		dev_err(&client->dev, "insufficient i2c bus capabilities\n");
+		return -EINVAL;
+	}
+
+	ads = kzalloc(sizeof *ads, GFP_KERNEL);
+	if (!ads) {
+		dev_err(&client->dev, "failed to allocate memory for ads782x device\n");
+		return -ENOMEM;
+	}
+
+	ads->i2c        = client;
+	ads->channels   = 8;		/* TODO: provide this through platform_data */
+	ads->attr_volt  = kcalloc(ads->channels,   sizeof *ads->attr_volt,  GFP_KERNEL);
+	ads->attr_diff  = kcalloc(ads->channels/2, sizeof *ads->attr_diff,  GFP_KERNEL);
+	ads->attr_pdown = kcalloc(ads->channels,   sizeof *ads->attr_pdown, GFP_KERNEL);
+
+	rc = -ENOMEM;
+	if (!ads->attr_volt || !ads->attr_diff || !ads->attr_pdown) {
+		dev_err(&client->dev, "failed to allocate memory for attributes\n");
+		goto err;
+	}
+
+	ads->dev      = hwmon_device_register(&client->dev);
+	if (IS_ERR(ads->dev)) {
+		rc       = PTR_ERR(ads->dev);
+		ads->dev = NULL;
+		dev_err(&client->dev, "failed to register hwmon device: %d\n", rc);
+		goto err;
+	}
+
+	i2c_set_clientdata(client, ads);
+
+	for (i=0; i<ads->channels; ++i) {
+		struct ads782x_attr * const	tmp = ads->attr_pdown + i;
+		tmp->attr.attr.name = tmp->name;
+		tmp->attr.attr.mode = 0644;
+		tmp->attr.show      = ads782x_pdown_show;
+		tmp->attr.store     = ads782x_pdown_store;
+
+		snprintf(tmp->name, sizeof (tmp->name), "pdown%u", i);
+	}
+	rc = xxx_device_create_files(&client->dev, ads->attr_pdown, ads->channels);
+	if (rc<0) {
+		dev_err(&client->dev, "failed to register attr* sysfs entries: %d\n", rc);
+		goto err;
+	}
+
+	for (i=0; i<ads->channels; ++i) {
+		struct ads782x_attr * const	tmp = ads->attr_volt + i;
+		tmp->attr.attr.name = tmp->name;
+		tmp->attr.attr.mode = 0400;
+		tmp->attr.show      = ads782x_volt_show;
+
+		snprintf(tmp->name, sizeof (tmp->name), "volt%u", i);
+	}
+	rc = xxx_device_create_files(&client->dev, ads->attr_volt, ads->channels);
+	if (rc<0) {
+		dev_err(&client->dev, "failed to register volt* sysfs entries: %d\n", rc);
+		goto err1;
+	}
+
+	for (i=0; i<ads->channels/2; ++i) {
+		struct ads782x_attr * const	tmp = ads->attr_diff + i;
+		tmp->attr.attr.name = tmp->name;
+		tmp->attr.attr.mode = 0644;
+		tmp->attr.show      = ads782x_diff_show;
+		tmp->attr.store     = ads782x_diff_store;
+
+		snprintf(tmp->name, sizeof (tmp->name), "diff%u", i);
+	}
+	rc = xxx_device_create_files(&client->dev, ads->attr_diff, ads->channels/2);
+	if (rc<0) {
+		dev_err(&client->dev, "failed to register diff* sysfs entries: %d\n", rc);
+		goto err2;
+	}
+
+	dev_info(&client->dev, "ads782%u device registered as %s\n",
+		 ads->channels, ads->dev->bus_id);
+
+	return 0;
+
+err2:	xxx_device_remove_files(&client->dev, ads->attr_volt,  ads->channels);
+err1:	xxx_device_remove_files(&client->dev, ads->attr_pdown, ads->channels);
+
+err:
+	if (ads->dev)
+		hwmon_device_unregister(ads->dev);
+
+	kfree(ads->attr_pdown);
+	kfree(ads->attr_diff);
+	kfree(ads->attr_volt);
+
+	kfree(ads);
+	return rc;
+}
+
+static int __devexit ads782x_remove(struct i2c_client *client)
+{
+	struct ads782x_device		*ads = i2c_get_clientdata(client);
+
+	xxx_device_remove_files(&client->dev, ads->attr_diff,  ads->channels/2);
+	xxx_device_remove_files(&client->dev, ads->attr_volt,  ads->channels);
+	xxx_device_remove_files(&client->dev, ads->attr_pdown, ads->channels);
+	hwmon_device_unregister(ads->dev);
+
+	kfree(ads->attr_diff);
+	kfree(ads->attr_volt);
+
+	kfree(ads);
+	return 0;
+}
+
+static struct i2c_driver ads782x_driver = {
+	.driver = {
+		.name	= "ads782x",
+	},
+	.probe	= ads782x_probe,
+	.remove	= __devexit_p(ads782x_remove),
+};
+
+static int __init ads782x_init(void)
+{
+	int		rc;
+
+	rc = i2c_add_driver(&ads782x_driver);
+	if (rc)
+		printk(KERN_WARNING "%s: failed to detect driver: %d\n",
+		       __FUNCTION__, rc);
+
+	return rc;
+}
+
+static void __exit ads782x_exit(void)
+{
+	i2c_del_driver(&ads782x_driver);
+}
+
+module_init(ads782x_init);
+module_exit(ads782x_exit);
+
+MODULE_LICENSE("GPL");
diff -Naur linux-3.4.11/drivers/hwmon/Kconfig linux-HEAD/drivers/hwmon/Kconfig
--- linux-3.4.11/drivers/hwmon/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/hwmon/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -1376,6 +1376,22 @@
         help
           Support for the A/D converter on MC13783 and MC13892 PMIC.
 
+config SENSORS_ADC121
+	tristate "ADC121 SPI A/D converter"
+	depends on HWMON && SPI && EXPERIMENTAL
+
+config SENSORS_ADS782X
+	tristate "ADS782x ADC"
+	depends on I2C && EXPERIMENTAL
+
+config SENSORS_AD7814
+	tristate "ADS7814 SPI temperature senor"
+	depends on SPI && EXPERIMENTAL
+
+config SENSORS_PXA168
+        tristate "PXA168 room temperature sensor"
+	depends on ARCH_PXA168
+
 if ACPI
 
 comment "ACPI drivers"
diff -Naur linux-3.4.11/drivers/hwmon/Makefile linux-HEAD/drivers/hwmon/Makefile
--- linux-3.4.11/drivers/hwmon/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/hwmon/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -127,7 +127,13 @@
 obj-$(CONFIG_SENSORS_WM831X)	+= wm831x-hwmon.o
 obj-$(CONFIG_SENSORS_WM8350)	+= wm8350-hwmon.o
 
+obj-$(CONFIG_SENSORS_ADC121)	+= adc121.o
+obj-$(CONFIG_SENSORS_ADS782X)	+= ads782x.o
+obj-$(CONFIG_SENSORS_AD7814)	+= ad7814.o
+
+obj-$(CONFIG_SENSORS_PXA168)	+= pxa168-hwmon.o
 obj-$(CONFIG_PMBUS)		+= pmbus/
 
+
 ccflags-$(CONFIG_HWMON_DEBUG_CHIP) := -DDEBUG
 
diff -Naur linux-3.4.11/drivers/hwmon/pxa168-hwmon.c linux-HEAD/drivers/hwmon/pxa168-hwmon.c
--- linux-3.4.11/drivers/hwmon/pxa168-hwmon.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/hwmon/pxa168-hwmon.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,225 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/io.h>
+
+#include <mach/addr-map.h>
+
+#define TSC_CONFIG	(APB_VIRT_BASE + 0x197fc)
+#define TSC_CAL1	(AXI_VIRT_BASE + 0x82c80)
+#define TSC_CAL2	(AXI_VIRT_BASE + 0x82c88)
+
+#define TSC_CONFIG_ADC_sft	(0)
+#define TSC_CONFIG_ADC_msk	(0x3ffu << TSC_CONFIG_ADC_sft)
+
+#define TSC_CONFIG_DATA_RDY		(1u << 10) /* read-only */
+
+#define TSC_CONFIG_ADC_CAL_NORMAL	((0u << 11) | (0u << 15))
+#define TSC_CONFIG_ADC_CAL_OFFSET	((1u << 11) | (0u << 15))
+#define TSC_CONFIG_ADC_CAL_GAIL		((0u << 11) | (1u << 15))
+#define TSC_CONFIG_ADC_CAL_msk		((1u << 11) | (1u << 15))
+
+#define TSC_CONFIG_TST_SEL_DISABLED	(0u << 12)
+#define TSC_CONFIG_TST_SEL_VCM		(1u << 12)
+#define TSC_CONFIG_TST_SEL_VBE		(2u << 12)
+#define TSC_CONFIG_TST_SEL_VREFP	(3u << 12)
+#define TSC_CONFIG_TST_SEL_msk		(3u << 12)
+
+#define TSC_CONFIG_CLK_SEL_1250		(0u << 14)
+#define TSC_CONFIG_CLK_SEL_2500		(1u << 14)
+
+#define TSC_CONFIG_CLK_TS_EN		(1u << 16)
+#define TSC_CONFIG_EXT_EN		(1u << 17)
+
+#define TSC_CONFIG_MODE_SEL_0_125	(0u << 18)
+#define TSC_CONFIG_MODE_SEL_10_50	(1u << 18)
+#define TSC_CONFIG_MODE_SEL_msk		(1u << 18)
+
+struct pxa168_hwmon_device {
+	struct device *classdev;
+};
+
+static ssize_t show_label(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	char const * const	LABELS[] = {
+		"PXA168 internal die temperature",
+		"PXA168 external temperature",
+	};
+
+	int channel = to_sensor_dev_attr(attr)->index;
+
+	if (WARN_ON(channel >= ARRAY_SIZE(LABELS)))
+		return -ENOENT;
+
+	return sprintf(buf, "%s\n", LABELS[channel]);
+}
+
+static ssize_t show_chip_temp(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	uint32_t	tsc_config;
+	uint32_t	tsc_cal[2];
+	unsigned long	num_retries = 1000;
+	signed long	raw;
+	signed long	temp;
+
+	signed long	offset;
+
+	do {
+		tsc_config = __raw_readl(TSC_CONFIG);
+
+		if ((tsc_config & TSC_CONFIG_DATA_RDY) == 0)
+			cpu_relax();
+
+	} while (num_retries-- > 0 && (tsc_config & TSC_CONFIG_DATA_RDY) == 0);
+
+	if (!(tsc_config & TSC_CONFIG_DATA_RDY))
+		return -EIO;
+
+	if ((tsc_config & TSC_CONFIG_EXT_EN)) {
+		dev_warn(dev,
+			 "external sensor selected while measuring internal temperature\n");
+		return -ENOENT;
+	}
+
+	tsc_cal[0] = __raw_readl(TSC_CAL1);
+	tsc_cal[1] = __raw_readl(TSC_CAL2);
+
+	offset = ((((tsc_cal[0] >> 17) & 0x1) << 2) |
+		  (((tsc_cal[0] >> 15) & 0x1) << 1) |
+		  (((tsc_cal[1] >> 18) & 0x1) << 0));
+
+	if (tsc_cal[1] & (1u << 28))
+		offset = -offset;
+
+	raw = (tsc_config & TSC_CONFIG_ADC_msk) >> TSC_CONFIG_ADC_sft;
+	raw *= 1000;
+
+	switch (tsc_config & TSC_CONFIG_MODE_SEL_msk) {
+	case TSC_CONFIG_MODE_SEL_0_125:
+		temp = (raw - 525900) / 1988 + offset;
+		break;
+
+	case TSC_CONFIG_MODE_SEL_10_50:
+		temp = (raw - 785300) / 2870 + offset;
+		break;
+
+	default:
+		BUG();
+	}
+
+	return sprintf(buf, "%ld\n", temp);
+}
+
+
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_chip_temp, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, show_label, NULL, 0);
+
+static struct attribute *pxa168_attributes[] = {
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+
+	NULL,
+};
+
+static struct attribute_group const	pxa168_attr_group = {
+	.attrs	= pxa168_attributes,
+};
+
+static int __devinit pxa168_hwmon_probe(struct platform_device *pdev)
+{
+	int				rc;
+	struct pxa168_hwmon_device	*hwmon;
+
+	__raw_writel(TSC_CONFIG_MODE_SEL_0_125 |
+		     TSC_CONFIG_CLK_TS_EN |
+		     TSC_CONFIG_CLK_SEL_1250 |
+		     TSC_CONFIG_TST_SEL_DISABLED, TSC_CONFIG);
+
+	hwmon = kzalloc(sizeof *hwmon, GFP_KERNEL);
+	if (!hwmon)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, hwmon);
+
+	hwmon->classdev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(hwmon->classdev)) {
+		rc = PTR_ERR(hwmon->classdev);
+		goto err;
+	}
+
+	rc = sysfs_create_group(&hwmon->classdev->kobj, &pxa168_attr_group);
+	if (rc < 0) {
+		goto err;
+	}
+
+	rc = 0;
+
+err:
+	if (rc < 0 && hwmon) {
+		if (hwmon->classdev)
+			hwmon_device_unregister(hwmon->classdev);
+
+		kfree(hwmon);
+	}
+
+	return rc;
+}
+
+static int __devexit pxa168_hwmon_remove(struct platform_device *pdev)
+{
+	struct pxa168_hwmon_device	*hwmon = platform_get_drvdata(pdev);
+
+	sysfs_remove_group(&hwmon->classdev->kobj, &pxa168_attr_group);
+	hwmon_device_unregister(hwmon->classdev);
+	kfree(hwmon);
+
+	return 0;
+}
+
+static struct platform_driver pxa168_hwmon_driver = {
+	.probe	= pxa168_hwmon_probe,
+	.remove = __devexit_p(pxa168_hwmon_remove),
+	.driver = {
+		.name	= "pxa168-hwmon",
+		.owner	= THIS_MODULE,
+	}
+};
+
+static int __init pxa168_hwmon_init(void)
+{
+	return platform_driver_register(&pxa168_hwmon_driver);
+}
+module_init(pxa168_hwmon_init);
+
+static void __exit pxa168_hwmon_exit(void)
+{
+	platform_driver_unregister(&pxa168_hwmon_driver);
+}
+module_exit(pxa168_hwmon_exit);
+
+MODULE_AUTHOR("Enrico Scholz <enrico.scholz@sigma-chemnitz.de>");
+MODULE_DESCRIPTION("PXA168 Room Temperature Monitoring");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pxa168-hwmon");
diff -Naur linux-3.4.11/drivers/i2c/busses/i2c-pxa.c linux-HEAD/drivers/i2c/busses/i2c-pxa.c
--- linux-3.4.11/drivers/i2c/busses/i2c-pxa.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/i2c/busses/i2c-pxa.c	2015-11-18 09:04:24.000000000 +0000
@@ -1093,7 +1093,7 @@
 	return 0;
 }
 
-static int i2c_pxa_probe(struct platform_device *dev)
+static int __init i2c_pxa_probe(struct platform_device *dev)
 {
 	struct i2c_pxa_platform_data *plat = dev->dev.platform_data;
 	enum pxa_i2c_types i2c_type;
@@ -1280,7 +1280,6 @@
 #endif
 
 static struct platform_driver i2c_pxa_driver = {
-	.probe		= i2c_pxa_probe,
 	.remove		= __exit_p(i2c_pxa_remove),
 	.driver		= {
 		.name	= "pxa2xx-i2c",
@@ -1293,7 +1292,7 @@
 
 static int __init i2c_adap_pxa_init(void)
 {
-	return platform_driver_register(&i2c_pxa_driver);
+	return platform_driver_probe(&i2c_pxa_driver, i2c_pxa_probe);
 }
 
 static void __exit i2c_adap_pxa_exit(void)
diff -Naur linux-3.4.11/drivers/input/keyboard/gpio_keys.c linux-HEAD/drivers/input/keyboard/gpio_keys.c
--- linux-3.4.11/drivers/input/keyboard/gpio_keys.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/input/keyboard/gpio_keys.c	2015-11-18 09:04:24.000000000 +0000
@@ -705,6 +705,8 @@
 
 		if (button->wakeup)
 			wakeup = 1;
+
+		gpio_keys_gpio_report_event(bdata);
 	}
 
 	error = sysfs_create_group(&pdev->dev.kobj, &gpio_keys_attr_group);
diff -Naur linux-3.4.11/drivers/input/keyboard/pxa27x_keypad.c linux-HEAD/drivers/input/keyboard/pxa27x_keypad.c
--- linux-3.4.11/drivers/input/keyboard/pxa27x_keypad.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/input/keyboard/pxa27x_keypad.c	2015-11-18 09:04:24.000000000 +0000
@@ -200,8 +200,10 @@
 		row = KPAS_RP(kpas);
 
 		/* if invalid row/col, treat as no key pressed */
-		if (col >= pdata->matrix_key_cols ||
-		    row >= pdata->matrix_key_rows)
+		if (col >= MAX_MATRIX_KEY_COLS ||
+		    row >= MAX_MATRIX_KEY_ROWS ||
+		    (pdata->mask_rows & (1<<row))==0 ||
+		    (pdata->mask_cols & (1<<col))==0)
 			goto scan;
 
 		new_state[col] = (1 << row);
@@ -224,15 +226,21 @@
 		new_state[7] = (kpasmkp3 >> 16) & KPASMKP_MKC_MASK;
 	}
 scan:
-	for (col = 0; col < pdata->matrix_key_cols; col++) {
+	for (col = 0; col < MAX_MATRIX_KEY_COLS; col++) {
 		uint32_t bits_changed;
 		int code;
 
+		if ((pdata->mask_cols & (1<<col))==0)
+			continue;
+
 		bits_changed = keypad->matrix_key_state[col] ^ new_state[col];
 		if (bits_changed == 0)
 			continue;
 
-		for (row = 0; row < pdata->matrix_key_rows; row++) {
+		for (row = 0; row < MAX_MATRIX_KEY_ROWS; row++) {
+			if ((pdata->mask_rows & (1<<row))==0)
+				continue;
+
 			if ((bits_changed & (1 << row)) == 0)
 				continue;
 
@@ -359,12 +367,21 @@
 	struct pxa27x_keypad_platform_data *pdata = keypad->pdata;
 	unsigned int mask = 0, direct_key_num = 0;
 	unsigned long kpc = 0;
+	unsigned int	rows, cols;
+
+	for (cols=MAX_MATRIX_KEY_COLS; cols>0; --cols)
+		if ((pdata->mask_cols & (1<<(cols-1)))!=0)
+			break;
+
+	for (rows=MAX_MATRIX_KEY_ROWS; rows>0; --rows)
+		if ((pdata->mask_rows & (1<<(rows-1)))!=0)
+			break;
 
 	/* enable matrix keys with automatic scan */
-	if (pdata->matrix_key_rows && pdata->matrix_key_cols) {
+	if (rows && cols) {
 		kpc |= KPC_ASACT | KPC_MIE | KPC_ME | KPC_MS_ALL;
-		kpc |= KPC_MKRN(pdata->matrix_key_rows) |
-		       KPC_MKCN(pdata->matrix_key_cols);
+		kpc |= KPC_MKRN(rows) |
+		       KPC_MKCN(cols);
 	}
 
 	/* enable rotary key, debounce interval same as direct keys */
diff -Naur linux-3.4.11/drivers/input/touchscreen/stmpe-ts.c linux-HEAD/drivers/input/touchscreen/stmpe-ts.c
--- linux-3.4.11/drivers/input/touchscreen/stmpe-ts.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/input/touchscreen/stmpe-ts.c	2015-11-18 09:04:24.000000000 +0000
@@ -118,6 +118,7 @@
 	__stmpe_reset_fifo(ts->stmpe);
 
 	input_report_abs(ts->idev, ABS_PRESSURE, 0);
+	input_report_abs(ts->idev, BTN_TOUCH, 0);
 	input_sync(ts->idev);
 }
 
@@ -151,6 +152,7 @@
 	input_report_abs(ts->idev, ABS_X, x);
 	input_report_abs(ts->idev, ABS_Y, y);
 	input_report_abs(ts->idev, ABS_PRESSURE, z);
+	input_report_abs(ts->idev, BTN_TOUCH, 1);
 	input_sync(ts->idev);
 
        /* flush the FIFO after we have read out our values. */
diff -Naur linux-3.4.11/drivers/input/touchscreen/ucb1400_ts.c linux-HEAD/drivers/input/touchscreen/ucb1400_ts.c
--- linux-3.4.11/drivers/input/touchscreen/ucb1400_ts.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/input/touchscreen/ucb1400_ts.c	2015-11-18 09:04:24.000000000 +0000
@@ -148,15 +148,6 @@
 	ucb1400_reg_write(ucb->ac97, UCB_IE_FAL, 0);
 }
 
-static void ucb1400_ts_report_event(struct input_dev *idev, u16 pressure, u16 x, u16 y)
-{
-	input_report_abs(idev, ABS_X, x);
-	input_report_abs(idev, ABS_Y, y);
-	input_report_abs(idev, ABS_PRESSURE, pressure);
-	input_report_key(idev, BTN_TOUCH, 1);
-	input_sync(idev);
-}
-
 static void ucb1400_ts_event_release(struct input_dev *idev)
 {
 	input_report_abs(idev, ABS_PRESSURE, 0);
@@ -164,6 +155,19 @@
 	input_sync(idev);
 }
 
+static void ucb1400_ts_report_event(struct input_dev *idev, u16 pressure, u16 x, u16 y)
+{
+	if (pressure < 50)
+		ucb1400_ts_event_release(idev);
+	else {
+		input_report_abs(idev, ABS_X, x);
+		input_report_abs(idev, ABS_Y, y);
+		input_report_abs(idev, ABS_PRESSURE, pressure);
+		input_report_key(idev, BTN_TOUCH, 1);
+		input_sync(idev);
+	}
+}
+
 static void ucb1400_clear_pending_irq(struct ucb1400_ts *ucb)
 {
 	unsigned int isr;
@@ -359,8 +363,8 @@
 	 * This also further reduces jitter on boards where ADCSYNC
 	 * pin is connected.
 	 */
-	fcsr = ucb1400_reg_read(ucb->ac97, UCB_FCSR);
-	ucb1400_reg_write(ucb->ac97, UCB_FCSR, fcsr | UCB_FCSR_AVE);
+	fcsr = ucb1400_reg_read(ucb->ac97, UCB_FCSR2);
+	ucb1400_reg_write(ucb->ac97, UCB_FCSR2, fcsr | UCB_FCSR2_AVE);
 
 	ucb1400_adc_enable(ucb->ac97);
 	x_res = ucb1400_ts_read_xres(ucb);
@@ -368,6 +372,7 @@
 	ucb1400_adc_disable(ucb->ac97);
 	dev_dbg(&pdev->dev, "x/y = %d/%d\n", x_res, y_res);
 
+	x_res = y_res = 1023;
 	input_set_abs_params(ucb->ts_idev, ABS_X, 0, x_res, 0, 0);
 	input_set_abs_params(ucb->ts_idev, ABS_Y, 0, y_res, 0, 0);
 	input_set_abs_params(ucb->ts_idev, ABS_PRESSURE, 0, 0, 0, 0);
@@ -382,6 +387,7 @@
 			"unable to grab irq%d: %d\n", ucb->irq, error);
 		goto err_free_devs;
 	}
+	disable_irq(ucb->irq);
 
 	error = input_register_device(ucb->ts_idev);
 	if (error)
@@ -390,6 +396,7 @@
 	return 0;
 
 err_free_irq:
+	enable_irq(ucb->irq);
 	free_irq(ucb->irq, ucb);
 err_free_devs:
 	input_free_device(ucb->ts_idev);
@@ -401,6 +408,7 @@
 {
 	struct ucb1400_ts *ucb = pdev->dev.platform_data;
 
+	enable_irq(ucb->irq);
 	free_irq(ucb->irq, ucb);
 	input_unregister_device(ucb->ts_idev);
 
@@ -463,5 +471,6 @@
 		"delay between panel setup and pressure read."
 		"  Default = 0us.");
 
+MODULE_ALIAS("platform:ucb1400_ts");
 MODULE_DESCRIPTION("Philips UCB1400 touchscreen driver");
 MODULE_LICENSE("GPL");
diff -Naur linux-3.4.11/drivers/input/touchscreen/usbtouchscreen.c linux-HEAD/drivers/input/touchscreen/usbtouchscreen.c
--- linux-3.4.11/drivers/input/touchscreen/usbtouchscreen.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/input/touchscreen/usbtouchscreen.c	2015-11-18 09:04:24.000000000 +0000
@@ -311,6 +311,7 @@
 	dev->x = ((pkt[3] & 0x0F) << 7) | (pkt[4] & 0x7F);
 	dev->y = ((pkt[1] & 0x0F) << 7) | (pkt[2] & 0x7F);
 	dev->touch = pkt[0] & 0x01;
+	dev->press = dev->touch ? 1 : 0;
 
 	return 1;
 }
@@ -1046,6 +1047,7 @@
 		.max_xc		= 0x07ff,
 		.min_yc		= 0x0,
 		.max_yc		= 0x07ff,
+		.max_press	= 1,
 		.rept_size	= 16,
 		.process_pkt	= usbtouch_process_multi,
 		.get_pkt_len	= egalax_get_pkt_len,
diff -Naur linux-3.4.11/drivers/input/touchscreen/wm97xx-core.c linux-HEAD/drivers/input/touchscreen/wm97xx-core.c
--- linux-3.4.11/drivers/input/touchscreen/wm97xx-core.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/input/touchscreen/wm97xx-core.c	2015-11-18 09:04:24.000000000 +0000
@@ -471,7 +471,7 @@
 
 	do {
 		rc = wm97xx_read_samples(wm);
-	} while (rc & RC_AGAIN);
+	} while ((rc & RC_AGAIN));
 
 	if (wm->pen_is_down || !wm->pen_irq)
 		queue_delayed_work(wm->ts_workq, &wm->ts_reader,
@@ -515,12 +515,8 @@
 	else
 		dev_err(wm->dev, "No IRQ specified\n");
 
-	/* If we either don't have an interrupt for pen down events or
-	 * failed to acquire it then we need to poll.
-	 */
-	if (wm->pen_irq == 0)
-		queue_delayed_work(wm->ts_workq, &wm->ts_reader,
-				   wm->ts_reader_interval);
+	queue_delayed_work(wm->ts_workq, &wm->ts_reader,
+			   wm->ts_reader_interval);
 
 	return 0;
 }
@@ -713,6 +709,10 @@
 {
 	struct wm97xx *wm = dev_get_drvdata(dev);
 
+	/* HACK: platform_device_release() kfree's the platform_data */
+	wm->battery_dev->dev.platform_data = NULL;
+	wm->touch_dev->dev.platform_data = NULL;
+
 	platform_device_unregister(wm->battery_dev);
 	platform_device_unregister(wm->touch_dev);
 	input_unregister_device(wm->input_dev);
diff -Naur linux-3.4.11/drivers/misc/eeprom/eeprom.c linux-HEAD/drivers/misc/eeprom/eeprom.c
--- linux-3.4.11/drivers/misc/eeprom/eeprom.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/misc/eeprom/eeprom.c	2015-11-18 09:04:24.000000000 +0000
@@ -4,6 +4,7 @@
  * Copyright (C) 2003 Greg Kroah-Hartman <greg@kroah.com>
  * Copyright (C) 2003 IBM Corp.
  * Copyright (C) 2004 Jean Delvare <khali@linux-fr.org>
+ * Copyright (C) 2006 Walter Goossens <walter.goossens at axon.tv>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -23,6 +24,7 @@
 #include <linux/jiffies.h>
 #include <linux/i2c.h>
 #include <linux/mutex.h>
+#include <linux/delay.h>
 
 /* Addresses to scan */
 static const unsigned short normal_i2c[] = { 0x50, 0x51, 0x52, 0x53, 0x54,
@@ -45,6 +47,9 @@
 	unsigned long last_updated[8];	/* In jiffies, 8 slices */
 	u8 data[EEPROM_SIZE];		/* Register values */
 	enum eeprom_nature nature;
+#ifdef CONFIG_SENSORS_EEPROM_WRITE
+	u8 write_lock;
+#endif
 };
 
 
@@ -90,7 +95,7 @@
 	u8 slice;
 
 	if (off > EEPROM_SIZE)
-		return 0;
+		return -ESPIPE;
 	if (off + count > EEPROM_SIZE)
 		count = EEPROM_SIZE - off;
 
@@ -119,13 +124,93 @@
 	return count;
 }
 
+#ifdef CONFIG_SENSORS_EEPROM_WRITE
+
+static ssize_t eeprom_write(struct file *filep, struct kobject *kobj,
+                            struct bin_attribute *attr, char *buf, loff_t off,
+                            size_t count)
+{
+	int i = 0;
+	struct i2c_client *client = to_i2c_client(container_of(kobj, struct device, kobj));
+	struct eeprom_data *data = i2c_get_clientdata(client);
+	int			rc = 0;
+	char shadow[count];
+
+	/* Only allow writes when we are unlocked! */
+	if(data->write_lock != 0)
+		return -EPERM;
+	/* Refuse to write Vaio Chips */
+	if(data->nature == VAIO)
+		return -ENXIO;
+	if(off+count>EEPROM_SIZE)
+		return -ESPIPE;
+
+	memcpy(shadow,buf,count);
+	/* Prevent reading when we're writing */
+	mutex_lock(&data->update_lock);
+	data->valid = 0;
+	while(i < count && rc>=0) {
+		if((count - i) >= 8) {
+			/* Pagewrites (8 bytes) are the relatively fast */
+			rc = i2c_smbus_write_i2c_block_data(client, (off + i), 8, shadow + i);
+
+			if (rc>=0) {
+				/* Wait for the chip to store everything. */
+				msleep(32);
+				i += 8;
+			}
+		} else {
+			rc = i2c_smbus_write_i2c_block_data(client, (off + i), (count - i), shadow + i);
+
+			if (rc>=0) {
+				/* Wait for the chip to store everything. */
+				msleep(10 * (count - i));
+				i += (count - i);
+			}
+		}
+	}
+	mutex_unlock(&data->update_lock);
+	return rc < 0 ? rc : count;
+}
+
+static ssize_t show_lock(struct device *dev, struct device_attribute *attr, char *buf)
+{
+  struct eeprom_data *data = i2c_get_clientdata(to_i2c_client(dev));
+  return sprintf(buf, "%u\n", data->write_lock);
+}
+
+static ssize_t set_lock(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+  struct i2c_client *client = to_i2c_client(dev);
+  struct eeprom_data *data = i2c_get_clientdata(client);
+  unsigned long val = simple_strtoul(buf, NULL, 10);
+  if (val == 0)
+  {
+	data->write_lock = 0;
+  } else {
+	data->write_lock = 1;
+  }
+  return count;
+}
+
+static DEVICE_ATTR(write_lock, S_IWUSR | S_IRUGO, show_lock, set_lock);
+
+#endif //CONFIG_SENSORS_EEPROM_WRITE
+
 static struct bin_attribute eeprom_attr = {
 	.attr = {
 		.name = "eeprom",
+#ifdef CONFIG_SENSORS_EEPROM_WRITE
+		.mode = S_IRUGO | S_IWUSR,
+#else
 		.mode = S_IRUGO,
+#endif
 	},
 	.size = EEPROM_SIZE,
 	.read = eeprom_read,
+#ifdef CONFIG_SENSORS_EEPROM_WRITE
+	.write = eeprom_write,
+#endif
 };
 
 /* Return 0 if detection is successful, -ENODEV otherwise */
@@ -172,6 +257,11 @@
 	mutex_init(&data->update_lock);
 	data->nature = UNKNOWN;
 
+#ifdef CONFIG_SENSORS_EEPROM_WRITE
+	/* Disallow write by default */
+	data->write_lock = 1;
+#endif
+
 	/* Detect the Vaio nature of EEPROMs.
 	   We use the "PCG-" or "VGN-" prefix as the signature. */
 	if (client->addr == 0x57
@@ -195,6 +285,12 @@
 	if (err)
 		goto exit_kfree;
 
+	err = device_create_file(&client->dev, &dev_attr_write_lock);
+	if (err) {
+		sysfs_remove_bin_file(&client->dev.kobj, &eeprom_attr);
+		goto exit_kfree;
+	}
+
 	return 0;
 
 exit_kfree:
@@ -205,6 +301,7 @@
 
 static int eeprom_remove(struct i2c_client *client)
 {
+	device_remove_file(&client->dev, &dev_attr_write_lock);
 	sysfs_remove_bin_file(&client->dev.kobj, &eeprom_attr);
 	kfree(i2c_get_clientdata(client));
 
diff -Naur linux-3.4.11/drivers/misc/eeprom/Kconfig linux-HEAD/drivers/misc/eeprom/Kconfig
--- linux-3.4.11/drivers/misc/eeprom/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/misc/eeprom/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -61,6 +61,19 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called max6875.
 
+config SENSORS_EEPROM_WRITE
+	bool "EEPROM Write support (experimental)"
+	depends on EEPROM_AT24 && EXPERIMENTAL
+	help
+	  If you say yes here you get write access to the EEPROM data. Be
+	  VERY carefull when writing since this driver is designed to work
+	  with chips on memory DIMMs which you will NOT want to destroy!
+
+	  Even when write support is enabled you will need to unlock it at
+	  runtime to prevent errors. Write UNLOCK to the lock file in the
+	  sys/i2c/devices/<address>/ directory to gain write access. Any
+	  other value will lock write support.
+
 
 config EEPROM_93CX6
 	tristate "EEPROM 93CX6 support"
diff -Naur linux-3.4.11/drivers/misc/gpio/gpio-devall.c linux-HEAD/drivers/misc/gpio/gpio-devall.c
--- linux-3.4.11/drivers/misc/gpio/gpio-devall.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/gpio/gpio-devall.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,179 @@
+// $Id$    --*- c -*--
+
+// Copyright (C) 2006 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; version 2 of the License.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+
+#include "gpio-pxa.h"
+
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+
+static ssize_t
+gpiodevall_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	struct gpiodevall_dev	*dev = filp->private_data;
+	int			retval;
+	uint64_t		levels;
+	unsigned int		seqnr;
+	int			i;
+	char			tmpbuf[65];
+	char			*ptr = tmpbuf;
+	unsigned int		new_seqnr;
+
+	if (count < gpio_pxa_get_pin_cnt(dev->vec)+1)
+		return -ENOSPC;
+
+	if (*f_pos != 0)
+		return -EINVAL;
+
+	seqnr     = gpio_pxa_get_global_state(dev->vec, &levels);
+	new_seqnr = seqnr;
+
+	while (seqnr == dev->seqnr) {
+		up(&dev->sem);
+
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		if (wait_event_interruptible(dev->vec->eventq,
+					     (new_seqnr=gpio_pxa_get_global_state(dev->vec, &levels)) != seqnr))
+			return -ERESTARTSYS;
+
+		if (down_interruptible(&dev->sem))
+			return -ERESTARTSYS;
+
+		dev->seqnr  = new_seqnr;
+	}
+
+	// assign current seqnr in case of 'seqnr != dev->seqnr' upon entering
+	// this function (e.g. first read)
+	dev->seqnr  = new_seqnr;
+
+	memset(tmpbuf, '.', sizeof tmpbuf);
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	for (i=0; i<dev->vec->num_in;  ++i)
+		*ptr++ = (levels & (1<<i))             ? '1' : '0';
+#endif
+	for (i=0; i<dev->vec->num_out; ++i)
+		*ptr++ = (dev->vec->pins_out[i].level) ? 'H' : 'L';
+
+	*ptr++ = '\n';
+	retval = ptr-tmpbuf;
+
+	if (copy_to_user(buf, tmpbuf, retval)) {
+		retval = -EFAULT;
+		goto err;
+	}
+
+	*f_pos = 0;
+
+err:
+	up(&dev->sem);
+	return retval;
+}
+
+static unsigned int
+gpiodevall_poll(struct file *filp, poll_table *wait)
+{
+	struct gpiodevall_dev	*dev = filp->private_data;
+	unsigned int		mask = 0;
+
+	down(&dev->sem);
+
+	poll_wait(filp, &dev->vec->eventq, wait);
+	if (dev->vec->seqnr != dev->seqnr)
+		mask |= POLLIN | POLLRDNORM;
+
+	up(&dev->sem);
+
+	return mask;
+}
+
+
+static int
+gpiodevall_open(struct inode *ino, struct file *filp)
+{
+	struct gpiodevall_dev	*dev = container_of(ino->i_cdev,
+						    struct gpiodevall_dev,
+						    cdev);
+
+	filp->private_data = dev;
+	dev->seqnr         = dev->vec->seqnr-1;
+	return 0;
+}
+
+
+static int
+gpiodevall_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+//////////////////////////
+
+struct file_operations		gpiodevall_fops = {
+	.owner		=  THIS_MODULE,
+	.read		=  gpiodevall_read,
+	.poll		=  gpiodevall_poll,
+	.open		=  gpiodevall_open,
+	.release	=  gpiodevall_release,
+};
+
+int __devinit
+gpiodevall_add_gpio_dev(struct gpiodevall_dev *dev,
+			struct gpio_pxa_pin_vector *vec,
+			int *major)
+{
+	int	err;
+	dev_t	devno;
+
+	err = alloc_chrdev_region(&devno, 0, gpio_pxa_get_pin_cnt(vec)+1,
+				  "gpio");
+	if (err < 0)
+		return err;
+	*major = MAJOR(devno);
+
+	cdev_init(&dev->cdev, &gpiodevall_fops);
+	dev->cdev.owner = THIS_MODULE;
+	dev->vec        = vec;
+	sema_init(&dev->sem, 1);
+
+	err = cdev_add (&dev->cdev, devno, 1);
+
+	if (err)
+		printk(KERN_ERR "%s() failed to add gpiodev%d; error %i",
+		       __FUNCTION__,  0, err);
+
+	return err;
+}
+
+void
+gpiodevall_del_gpio_dev(struct gpiodevall_dev *dev)
+{
+	cdev_del(&dev->cdev);
+}
+
+void
+gpiodevall_unregister_chrdevs(int major, int count)
+{
+	dev_t		dev = MKDEV(major, 0);
+
+	unregister_chrdev_region(dev, count);
+}
diff -Naur linux-3.4.11/drivers/misc/gpio/gpio-dev.c linux-HEAD/drivers/misc/gpio/gpio-dev.c
--- linux-3.4.11/drivers/misc/gpio/gpio-dev.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/gpio/gpio-dev.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,239 @@
+// $Id$    --*- c -*--
+
+// Copyright (C) 2006 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; version 2 of the License.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+
+#include "gpio-pxa.h"
+
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <asm/uaccess.h>
+#include <asm/atomic.h>
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+static int
+gpiodev_readevent(struct file *filp, struct gpiodev_dev *dev, struct gpio_event *event)
+{
+	struct gpio_pxa_pin_in * const	pinin    = to_pinin(dev->pin);
+	unsigned int			cur_seq;
+
+	cur_seq = dev->seqnr;
+	do {
+		up(&dev->sem);
+
+		if (cur_seq==pinin->cur.event.seqnr &&
+		    (filp->f_flags & O_NONBLOCK))
+			return -EAGAIN;
+
+		if (wait_event_interruptible(pinin->eventq,
+					     cur_seq!=pinin->cur.event.seqnr))
+			return -ERESTARTSYS;
+
+		if (down_interruptible(&dev->sem))
+			return -ERESTARTSYS;
+
+		gpio_pxa_get_event(pinin, event);
+	} while (cur_seq == event->seqnr);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+static ssize_t
+gpiodev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	struct gpiodev_dev	*dev = filp->private_data;
+	int			retval;
+
+	if (down_interruptible(&dev->sem))
+		return -ERESTARTSYS;
+
+	if (*f_pos >= sizeof(dev->data)) {
+		retval = -EINVAL;
+		goto err0;
+	}
+
+	if (*f_pos==0) {
+		struct gpio_event	event;
+
+		retval = gpiodev_readevent(filp, dev, &event);
+		if (retval!=0)
+			return retval;
+
+		dev->data.event = event;
+		dev->seqnr      = event.seqnr;
+	}
+
+	if (*f_pos + count > sizeof(dev->data))
+		count = sizeof(dev->data) - *f_pos;
+
+	if (copy_to_user(buf, dev->data.buf + *f_pos, count)) {
+		retval = -EFAULT;
+		goto err0;
+	}
+
+	*f_pos += count;
+	retval  = count;
+	if (*f_pos >= sizeof(dev->data))
+		*f_pos = 0;
+
+
+err0:
+	up(&dev->sem);
+
+	return retval;
+}
+#endif
+
+static ssize_t
+gpiodev_write(struct file *filp, const char __user *buf, size_t count,
+	      loff_t *f_pos)
+{
+	struct gpiodev_dev	*dev = filp->private_data;
+	int			rc   = 0;
+
+	// only the first bytes are interesting; ignore the rest
+	char			inp[16];
+
+	if (count==0 || *f_pos!=0)
+		return -EINVAL;
+
+	if (copy_from_user(inp, buf, min(count, sizeof inp)))
+		return -EFAULT;
+
+	rc = str2bool(buf, min(count, sizeof inp));
+	if (rc<0)
+		return rc;
+
+	if (down_interruptible(&dev->sem))
+		return -ERESTARTSYS;
+
+	gpio_pxa_set_state(to_pinout(dev->pin), rc ? gpioHI :gpioLO);
+
+	up(&dev->sem);
+
+	return count;
+}
+
+static int
+gpiodev_open(struct inode *ino, struct file *filp)
+{
+	struct gpiodev_dev	*dev = container_of(ino->i_cdev,
+						    struct gpiodev_dev,
+						    cdev);
+	filp->private_data = dev;
+
+	switch (dev->pin->dir) {
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	case gpiodirIN	:
+		if ((filp->f_flags & O_ACCMODE)!=O_RDONLY)
+			return -EINVAL;
+		dev->seqnr = to_pinin(dev->pin)->pend.event.seqnr - 1;
+		break;
+#endif
+	case gpiodirOUT	:
+		if ((filp->f_flags & O_ACCMODE)!=O_WRONLY)
+			return -EINVAL;
+		break;
+	default		:  BUG();
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+static unsigned int
+gpiodev_poll(struct file *filp, poll_table *wait)
+{
+	struct gpiodev_dev * const	dev  = filp->private_data;
+	struct gpio_pxa_pin_in * const	pinin = to_pinin(dev->pin);
+	unsigned int			mask  = 0;
+	struct gpio_event		event;
+
+	down(&dev->sem);
+
+	poll_wait(filp, &pinin->eventq, wait);
+	gpio_pxa_get_event(pinin, &event);
+	if (event.seqnr!=dev->seqnr)
+		mask |= POLLIN | POLLRDNORM;
+
+	up(&dev->sem);
+	return mask;
+}
+#endif
+
+static int
+gpiodev_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+///////////////////////////////////////
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+struct file_operations		gpiodev_in_fops = {
+	.owner		=  THIS_MODULE,
+	.read		=  gpiodev_read,
+	.poll           =  gpiodev_poll,
+	.open		=  gpiodev_open,
+	.release	=  gpiodev_release,
+};
+#endif
+
+struct file_operations		gpiodev_out_fops = {
+	.owner		=  THIS_MODULE,
+	.write		=  gpiodev_write,
+	.open		=  gpiodev_open,
+	.release	=  gpiodev_release,
+};
+
+int __devinit
+gpiodev_add_gpio_dev(struct gpiodev_dev *dev,
+		     struct gpio_pxa_pin *pin,
+		     int major)
+{
+	int	err;
+	dev_t	devno = MKDEV(major, pin->id+1);
+
+	switch (pin->dir) {
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	case gpiodirIN:		cdev_init(&dev->cdev, &gpiodev_in_fops);  break;
+#endif
+	case gpiodirOUT:	cdev_init(&dev->cdev, &gpiodev_out_fops); break;
+	default:		BUG();
+	}
+
+	dev->cdev.owner = THIS_MODULE;
+	dev->pin        = pin;
+	sema_init(&dev->sem, 1);
+
+	err = cdev_add (&dev->cdev, devno, 1);
+
+	if (err)
+		printk(KERN_ERR "%s() failed to add gpiodev%d; error %i",
+		       __FUNCTION__,  pin->id+1, err);
+
+	return err;
+}
+
+void
+gpiodev_del_gpio_dev(struct gpiodev_dev *dev)
+{
+	cdev_del(&dev->cdev);
+}
diff -Naur linux-3.4.11/drivers/misc/gpio/gpio-pin.c linux-HEAD/drivers/misc/gpio/gpio-pin.c
--- linux-3.4.11/drivers/misc/gpio/gpio-pin.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/gpio/gpio-pin.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,172 @@
+#define PIN_LOCK(P)	spin_lock_irqsave(&(P)->lock, flags)
+#define PIN_UNLOCK(P)	spin_unlock_irqrestore(&(P)->lock, flags)
+
+#include <linux/gpio.h>
+
+static inline int
+gpio_pxa_get_negated_level(struct gpio_pxa_pin const *pin,
+			   uint32_t reg)
+{
+	return ((reg & GPIO_bit(pin->gpio)) ?
+		(pin->negated ? gpioLO : gpioHI) :
+		(pin->negated ? gpioHI : gpioLO));
+}
+
+static inline int
+gpio_pxa_get_level(struct gpio_pxa_pin const *pin)
+{
+	return gpio_pxa_get_negated_level(pin, GPLR(pin->gpio));
+}
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+static void	gpio_pxa_refresh_level_in (struct gpio_pxa_pin_in  *pinin);
+#endif
+
+static void	gpio_pxa_refresh_level_out(struct gpio_pxa_pin_out *pinout);
+
+static void
+gpio_pxa_refresh_level(struct gpio_pxa_pin *pin)
+{
+	switch (pin->dir) {
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	case gpiodirIN:
+		gpio_pxa_refresh_level_in (to_pinin(pin));
+		break;
+#endif
+	case gpiodirOUT:
+		gpio_pxa_refresh_level_out(to_pinout(pin));
+		break;
+	}
+}
+
+static int
+gpio_pxa_register_new_level(struct gpio_pxa_pin *pin,
+			    int level)
+{
+	unsigned long	flags;
+	uint64_t const	mask = (1<<pin->id);
+	uint64_t	cur_level;
+
+	spin_lock_irqsave(&pin->owner->lock, flags);
+
+	cur_level  = pin->owner->levels;
+	if (level)
+		 pin->owner->levels |=  mask;
+	else
+		 pin->owner->levels &= ~mask;
+
+	cur_level        ^= pin->owner->levels;
+	pin->owner->seqnr = atomic_read(&gpio_pxa_seqnr);
+
+	spin_unlock_irqrestore(&pin->owner->lock, flags);
+
+	return cur_level != 0;
+}
+
+static void __devinit
+gpio_pxa_activate_pin(struct gpio_pxa_pin *pin)
+{
+	unsigned long		flags;
+
+	PIN_LOCK(pin);
+	gpio_pxa_refresh_level(pin);
+	PIN_UNLOCK(pin);
+}
+
+static int __devinit __must_check
+gpio_pxa_init_pin(struct gpio_pxa_pin   *pin,
+		  char const		*name,
+		  unsigned int		id)
+
+{
+	int		rc;
+	pin->id = id;
+
+	snprintf(pin->name, sizeof pin->name, "%s", name);
+	rc = gpio_request(pin->gpio, pin->name);
+	if (rc<0) {
+		printk(KERN_ERR "failed to request gpio %u: %d\n",
+		       pin->gpio, rc);
+		return rc;
+	}
+
+	spin_lock_init(&pin->lock);
+
+	return 0;
+}
+
+static int __devinit
+gpio_pxa_create_dev(struct gpio_pxa_pin *pin)
+{
+	int			ret;
+
+	WARN_ON(pin->dev!=0);
+
+	pin->dev = kzalloc(sizeof(*pin->dev), GFP_KERNEL);
+	if (IS_ERR(pin->dev)) {
+		ret = PTR_ERR(pin->dev);
+		goto err0;
+	}
+
+	ret = gpiodev_add_gpio_dev(pin->dev, pin,
+				   pin->owner->dev_major);
+	if (ret < 0)
+		goto err1;
+
+	pin->sysfs = gpiosysfs_attach(pin);
+	if (IS_ERR(pin->sysfs)) {
+		ret = PTR_ERR(pin->sysfs);
+		goto err2;
+	}
+
+	return 0;
+
+err2:
+	pin->sysfs = 0;
+	gpiodev_del_gpio_dev(pin->dev);
+
+err1:
+	kfree(pin->dev);
+
+err0:
+	pin->dev   = 0;
+	return ret;
+}
+
+static void
+gpio_pxa_release_pin(struct gpio_pxa_pin *pin)
+{
+	if (pin->dev) {
+		gpiodev_del_gpio_dev(pin->dev);
+		pin->dev   = 0;
+	}
+	if (pin->sysfs) {
+		gpiosysfs_detach(pin->sysfs);
+		pin->sysfs = 0;
+	}
+	gpio_free(pin->gpio);
+}
+
+////////////////
+
+int
+gpio_pxa_set_negated(struct gpio_pxa_pin *pin,
+		     int neg)
+{
+	unsigned long	flags;
+
+	if (pin->negated==neg)
+		return 1;
+
+	PIN_LOCK(pin);
+
+	pin->negated = neg;
+	gpio_pxa_refresh_level(pin);
+
+	PIN_UNLOCK(pin);
+
+	return 0;
+}
+
+#undef PIN_UNLOCK
+#undef PIN_LOCK
diff -Naur linux-3.4.11/drivers/misc/gpio/gpio-pin-in.c linux-HEAD/drivers/misc/gpio/gpio-pin-in.c
--- linux-3.4.11/drivers/misc/gpio/gpio-pin-in.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/gpio/gpio-pin-in.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,274 @@
+#define PIN_LOCK(P)	spin_lock_irqsave(&(P)->pin.lock, flags)
+#define PIN_UNLOCK(P)	spin_unlock_irqrestore(&(P)->pin.lock, flags)
+
+static int
+gpio_pxa_valid_edge_state(struct gpio_pxa_pin_in const *pinin)
+{
+	gpio_state_t const		state = pinin->cur.state;
+
+	switch (pinin->edge) {
+	case IRQ_TYPE_EDGE_BOTH:	return 1;
+	case IRQ_TYPE_NONE:		return 0;
+	case IRQ_TYPE_EDGE_FALLING:
+		if (pinin->pin.negated) return state==gpioHI;
+		else                    return state==gpioLO;
+	case IRQ_TYPE_EDGE_RISING:
+		if (pinin->pin.negated) return state==gpioLO;
+		else	        	return state==gpioHI;
+	default:		        return 0;
+	}
+}
+
+static void
+gpio_pxa_event_report_state(struct gpio_pxa_pin_in *pin, int force)
+{
+	int			do_report;
+
+	force = force || (pin->edge!=IRQ_TYPE_EDGE_BOTH);
+
+	if (!force && pin->cur.state==pin->pend.state && pin->cur.state!=gpioINVALID)
+		return;
+
+	pin->cur                = pin->pend;
+	pin->cur.event.time_rep = current_kernel_time();
+
+	do_report = gpio_pxa_register_new_level(&pin->pin,
+						pin->cur.event.level);
+
+	if (!gpio_pxa_valid_edge_state(pin))
+		do_report = 0;
+	else
+		wake_up_interruptible(&pin->eventq);
+
+	if (do_report || force)
+		wake_up_interruptible(&pin->pin.owner->eventq);
+};
+
+static void
+gpio_pxa_fill_event(struct gpio_pxa_in_event     *event,
+		    struct gpio_pxa_pin_in const *pin,
+		    gpio_state_t state)
+{
+	WARN_ON(state!=gpioHI && state!=gpioLO);
+
+	event->event.time_ev = current_kernel_time();
+	event->event.id      = pin->pin.id;
+	event->event.seqnr   = atomic_inc_return(&gpio_pxa_seqnr);
+	event->event.level   = state == gpioHI ? 1 : 0;
+	event->state         = state;
+}
+
+static void
+gpio_pxa_refresh_level_in(struct gpio_pxa_pin_in *pinin)
+{
+	gpio_state_t			cur_state;
+
+	cur_state = gpio_pxa_get_level(&pinin->pin);
+
+	if (pinin->debounce==0) {
+		gpio_pxa_fill_event(&pinin->pend, pinin, cur_state);
+		gpio_pxa_event_report_state(pinin, 0);
+	}
+	else if (cur_state!=pinin->pend.state ||
+		 // reported state will be constant when only one edge
+		 // is triggered
+		 pinin->edge!=IRQ_TYPE_EDGE_BOTH  ||
+		 !timer_pending(&pinin->timer)) {
+		gpio_pxa_fill_event(&pinin->pend, pinin, cur_state);
+		mod_timer(&pinin->timer, jiffies + pinin->debounce);
+	}
+}
+
+static void
+gpio_pxa_debounce(unsigned long arg)
+{
+	struct gpio_pxa_pin_in * const	pinin   = (void *)(arg);
+	unsigned long			flags;
+
+	WARN_ON(pinin==0);
+
+	if (pinin==0)
+		return;
+
+	spin_lock_irqsave(&pinin->pin.lock, flags);
+
+	if (gpio_pxa_get_level(&pinin->pin) == pinin->pend.state)
+		gpio_pxa_event_report_state(pinin, 0);
+
+	spin_unlock_irqrestore(&pinin->pin.lock, flags);
+}
+
+static irqreturn_t
+gpio_pxa_event_interrupt(int irq, void *dev_id)
+{
+	struct gpio_pxa_pin_in		*pinin = dev_id;
+	unsigned long			flags;
+
+	WARN_ON(pinin==0);
+
+	if (pinin==0)
+		return IRQ_NONE;
+
+	spin_lock_irqsave(&pinin->pin.lock, flags);
+	gpio_pxa_refresh_level_in(pinin);
+	spin_unlock_irqrestore(&pinin->pin.lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static void
+gpio_pxa_ptimer_in(struct gpio_pxa_pin_in *pinin)
+{
+	gpio_state_t const	cur_state = gpio_pxa_get_level(&pinin->pin);
+
+	if (cur_state != pinin->pend.state && !timer_pending(&pinin->timer))
+		gpio_pxa_refresh_level_in(pinin);
+}
+
+static int __devinit
+gpio_pxa_init_pin_in(struct gpio_pxa_pin_in    *pinin,
+		     struct gpio_in_data const *gpio,
+		     unsigned int id)
+{
+	int		ret;
+
+	pinin->pin.negated = gpio->negated;
+	pinin->pin.gpio    = gpio->num;
+	pinin->pin.dir     = gpiodirIN;
+
+	ret = gpio_pxa_init_pin(&pinin->pin, gpio->name, id);
+	if (ret<0)
+		return ret;
+
+	pinin->debounce = gpio->debounce;
+	pinin->edge     = gpio->edge;
+
+	init_waitqueue_head(&pinin->eventq);
+	setup_timer(&pinin->timer, gpio_pxa_debounce, (unsigned long)(pinin));
+
+	ret = request_irq(IRQ_GPIO(pinin->pin.gpio),
+			  gpio_pxa_event_interrupt,
+			  IRQF_SAMPLE_RANDOM,
+			  pinin->pin.name,
+			  pinin);
+
+	if (ret<0) {
+		printk(KERN_ERR "%s(): request_irq() failed for GPIO %u with %i\n",
+		       __FUNCTION__, pinin->pin.gpio, ret);
+		gpio_pxa_release_pin(&pinin->pin);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __devinit
+gpio_pxa_activate_pin_in(struct gpio_pxa_pin_in *pinin)
+{
+	unsigned long			flags;
+
+	//pxa_gpio_mode(pinin->pin.gpio | GPIO_IN);
+	gpio_direction_input(pinin->pin.gpio);
+
+	PIN_LOCK(pinin);
+	gpio_pxa_fill_event(&pinin->cur, pinin,
+			    gpio_pxa_get_level(&pinin->pin));
+	pinin->cur.state  = gpioINVALID;
+	pinin->pend.state = gpioINVALID;
+	PIN_UNLOCK(pinin);
+
+	gpio_pxa_set_edge(pinin, pinin->edge);
+	gpio_pxa_activate_pin(&pinin->pin);
+}
+
+static void
+gpio_pxa_release_pin_in(struct gpio_pxa_pin_in *pinin)
+{
+	free_irq(IRQ_GPIO(pinin->pin.gpio), pinin);
+	del_timer_sync(&pinin->timer);
+
+	gpio_pxa_release_pin(&pinin->pin);
+}
+
+////////////////
+
+void
+gpio_pxa_get_event(struct gpio_pxa_pin_in *pinin,
+		   struct gpio_event      *event)
+{
+	unsigned long		flags;
+
+	PIN_LOCK(pinin);
+	*event = pinin->cur.event;
+	PIN_UNLOCK(pinin);
+}
+
+int
+gpio_pxa_set_debounce(struct gpio_pxa_pin_in *pinin,
+		      int debounce)
+{
+	pinin->debounce = debounce;
+
+	return 0;
+}
+
+int
+gpio_pxa_trigger(struct gpio_pxa_pin_in *pinin)
+{
+	unsigned long		flags;
+
+	PIN_LOCK(pinin);
+
+	pinin->cur.event.seqnr    = atomic_inc_return(&gpio_pxa_seqnr);
+	pinin->cur.event.time_rep = current_kernel_time();
+	wake_up_interruptible(&pinin->eventq);
+
+	PIN_UNLOCK(pinin);
+
+	return 0;
+}
+
+int
+gpio_pxa_set_edge(struct gpio_pxa_pin_in *pinin, unsigned int edge)
+{
+	unsigned long		flags;
+
+	spin_lock_irqsave(&pinin->pin.lock, flags);
+
+	pinin->edge = edge;
+	if (pinin->pin.negated) {
+		switch (edge) {
+		case IRQ_TYPE_EDGE_RISING:	edge = IRQ_TYPE_EDGE_FALLING; break;
+		case IRQ_TYPE_EDGE_FALLING:	edge = IRQ_TYPE_EDGE_RISING;  break;
+		default:		break;
+		}
+	}
+	set_irq_type(IRQ_GPIO(pinin->pin.gpio), edge);
+
+	spin_unlock_irqrestore(&pinin->pin.lock, flags);
+
+	return 0;
+}
+
+int
+gpio_pxa_get_edge(struct gpio_pxa_pin_in *pinin, unsigned int *edge)
+{
+	unsigned long		flags;
+
+	spin_lock_irqsave(&pinin->pin.lock, flags);
+
+	*edge = pinin->edge;
+	if (pinin->pin.negated) {
+		switch (*edge) {
+		case IRQ_TYPE_EDGE_RISING:	*edge = IRQ_TYPE_EDGE_FALLING; break;
+		case IRQ_TYPE_EDGE_FALLING:	*edge = IRQ_TYPE_EDGE_RISING;  break;
+		default:		break;
+		}
+	}
+
+	spin_unlock_irqrestore(&pinin->pin.lock, flags);
+	return 0;
+}
+
+#undef PIN_UNLOCK
+#undef PIN_LOCK
diff -Naur linux-3.4.11/drivers/misc/gpio/gpio-pin-out.c linux-HEAD/drivers/misc/gpio/gpio-pin-out.c
--- linux-3.4.11/drivers/misc/gpio/gpio-pin-out.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/gpio/gpio-pin-out.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,149 @@
+#define PIN_LOCK(P)	spin_lock_irqsave(&(P)->pin.lock, flags)
+#define PIN_UNLOCK(P)	spin_unlock_irqrestore(&(P)->pin.lock, flags)
+
+#include <linux/sched.h>
+#include <mach/pxa2xx-regs.h>
+
+#ifdef CONFIG_PM
+static uint32_t volatile *
+gpio_pxa_get_pgsr(struct gpio_pxa_pin_out const *pin)
+{
+	if      (pin->pin.gpio<32)
+		return &PGSR0;
+	else if (pin->pin.gpio<64)
+		return &PGSR1;
+	else if (pin->pin.gpio<96)
+		return &PGSR2;
+	else
+		return &PGSR3;
+}
+#endif
+
+static void
+gpio_pxa_refresh_level_out(struct gpio_pxa_pin_out *pin)
+{
+#ifdef CONFIG_PM
+	uint32_t	pgsr = *gpio_pxa_get_pgsr(pin);
+
+	switch (gpio_pxa_get_negated_level(&pin->pin, pgsr)) {
+	case gpioLO:	pin->suspend_level = 0; break;
+	case gpioHI:	pin->suspend_level = 1; break;
+	default:	BUG(); break;
+	}
+#endif
+
+	switch (gpio_pxa_get_level(&pin->pin)) {
+	case gpioLO:	pin->level = 0; break;
+	case gpioHI:	pin->level = 1; break;
+	default:	BUG(); break;
+	}
+
+}
+
+static void __devinit
+gpio_pxa_activate_pin_out(struct gpio_pxa_pin_out *pinout)
+{
+	enum { GPIO_DFLT_HIGH, GPIO_DFLT_LOW };
+
+	unsigned int		mask;
+	switch (pinout->level) {
+	case 0:		mask = pinout->pin.negated ? GPIO_DFLT_HIGH : GPIO_DFLT_LOW;  break;
+	case 1:		mask = pinout->pin.negated ? GPIO_DFLT_LOW  : GPIO_DFLT_HIGH; break;
+	default:	mask = 0; break;
+	}
+
+	gpio_direction_output(pinout->pin.gpio, mask == GPIO_DFLT_HIGH);
+
+	gpio_pxa_activate_pin(&pinout->pin);
+}
+
+static int __devinit
+gpio_pxa_init_pin_out(struct gpio_pxa_pin_out    *pinout,
+		      struct gpio_out_data const *gpio,
+		      unsigned int id)
+{
+	int	rc;
+
+	pinout->pin.negated = gpio->negated;
+	pinout->level       = gpio->level;
+	pinout->pin.gpio    = gpio->num;
+	pinout->pin.dir     = gpiodirOUT;
+
+	rc = gpio_pxa_init_pin(&pinout->pin, gpio->name, id);
+	if (rc<0)
+		return rc;
+
+	return 0;
+}
+
+static void
+gpio_pxa_release_pin_out(struct gpio_pxa_pin_out *pinout)
+{
+	gpio_pxa_release_pin(&pinout->pin);
+}
+
+//////////////////////
+
+int
+gpio_pxa_set_state(struct gpio_pxa_pin_out *pinout, gpio_state_t state)
+{
+	unsigned long		flags;
+	unsigned int const	mask = GPIO_bit(pinout->pin.gpio);
+
+	state = gpio_pxa_apply_neg(state, pinout->pin.negated);
+	if (state!=gpioHI && state!=gpioLO && state!=gpioINVALID)
+		return -EINVAL;
+
+	PIN_LOCK(pinout);
+
+	switch (state) {
+	case gpioHI:	GPSR(pinout->pin.gpio) |= mask; break;
+	case gpioLO:	GPCR(pinout->pin.gpio) |= mask; break;
+	case gpioINVALID:	/* ... just update value ...*/ break;
+	default:	break;
+	}
+
+	gpio_pxa_refresh_level_out(pinout);
+	PIN_UNLOCK(pinout);
+
+	atomic_inc(&gpio_pxa_seqnr);
+	if (gpio_pxa_register_new_level(&pinout->pin, pinout->level))
+		wake_up_interruptible(&pinout->pin.owner->eventq);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+int
+gpio_pxa_set_suspend_state(struct gpio_pxa_pin_out *pinout, gpio_state_t state)
+{
+	unsigned long		flags, flags1;
+	unsigned int const	mask = GPIO_bit(pinout->pin.gpio);
+	uint32_t volatile	*pgsr;
+
+	state = gpio_pxa_apply_neg(state, pinout->pin.negated);
+	if (state!=gpioHI && state!=gpioLO)
+		return -EINVAL;
+
+	pgsr = gpio_pxa_get_pgsr(pinout);
+
+	PIN_LOCK(pinout);
+	local_irq_save(flags1);
+
+	switch (state) {
+	case gpioHI:	*pgsr |=  mask; break;
+	case gpioLO:	*pgsr &= ~mask; break;
+	default:	break;
+	}
+
+	local_irq_restore(flags1);
+
+	gpio_pxa_refresh_level_out(pinout);
+	PIN_UNLOCK(pinout);
+
+	return 0;
+}
+#endif
+
+#undef PIN_UNLOCK
+#undef PIN_LOCK
diff -Naur linux-3.4.11/drivers/misc/gpio/gpio-pin-vector.c linux-HEAD/drivers/misc/gpio/gpio-pin-vector.c
--- linux-3.4.11/drivers/misc/gpio/gpio-pin-vector.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/gpio/gpio-pin-vector.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,89 @@
+int
+gpio_pxa_get_global_state(struct gpio_pxa_pin_vector *dev,
+			  uint64_t *level)
+{
+	unsigned long	flags;
+	int		res;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	*level = dev->levels;
+	res    = dev->seqnr;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return res;
+}
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+static void
+gpio_pxa_ptimer(unsigned long arg)
+{
+	struct gpio_pxa_pin_vector	*vec = (void *)(arg);
+	size_t				i;
+
+	for (i=0; i<vec->num_in; ++i) {
+		unsigned long		flags;
+		struct gpio_pxa_pin_in	* const	pinin = vec->pins_in+i;
+
+		spin_lock_irqsave(&pinin->pin.lock, flags);
+		gpio_pxa_ptimer_in(pinin);
+		spin_unlock_irqrestore(&pinin->pin.lock, flags);
+
+	}
+
+	mod_timer(&vec->timer, jiffies + vec->ptimer_time);
+}
+#endif
+
+static void
+gpio_pxa_clean_device_vector(struct gpio_pxa_pin_vector *vec)
+{
+	size_t			i;
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	del_timer_sync(&vec->timer);
+#endif
+
+	for (i=0; i<vec->num_out; ++i)
+		gpio_pxa_release_pin_out(vec->pins_out + i);
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	for (i=0; i<vec->num_in; ++i)
+		gpio_pxa_release_pin_in (vec->pins_in  + i);
+#endif
+
+	if (vec->sysfs_class!=0)
+		gpiosysfs_release(vec->sysfs_class);
+
+	if (vec->dev!=0)
+		gpiodevall_del_gpio_dev(vec->dev);
+
+	if (vec->dev_major!=0)
+		gpiodevall_unregister_chrdevs(vec->dev_major,
+					      gpio_pxa_get_pin_cnt(vec)+1);
+
+#ifdef MODULE
+	if (vec->platform_module!=0)
+		module_put(vec->platform_module);
+#endif
+
+	kfree(vec->dev);
+	kfree(vec);
+}
+
+///////////////////////
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+int
+gpio_pxa_set_ptimer(struct gpio_pxa_pin_vector *vec,
+		    unsigned long new_timeout)
+{
+	vec->ptimer_time = new_timeout;
+
+	if (new_timeout==0)
+		del_timer(&vec->timer);
+	else
+		mod_timer(&vec->timer, jiffies);	// fire timer now
+
+	return 0;
+}
+#endif
diff -Naur linux-3.4.11/drivers/misc/gpio/gpio-pxa-core.c linux-HEAD/drivers/misc/gpio/gpio-pxa-core.c
--- linux-3.4.11/drivers/misc/gpio/gpio-pxa-core.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/gpio/gpio-pxa-core.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,254 @@
+// $Id$    --*- c -*--
+
+// Copyright (C) 2006 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; version 2 of the License.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/irq.h>
+#include <linux/slab.h>
+
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/gpio-misc.h>
+#include <linux/ioport.h>
+#include <mach/hardware.h>
+
+
+#include "gpio-pxa.h"
+
+static atomic_t		gpio_pxa_seqnr = ATOMIC_INIT(0);
+
+int str2bool(char const *buf, size_t count)
+{
+	if (count==0)
+		return -EINVAL;
+
+	switch (*buf) {
+	case '0'	:
+	case 'n'	:
+	case 'N'	:
+	case 'l'	:
+	case 'L'	:  return 0;
+	case '1'	:
+	case 'y'	:
+	case 'Y'	:
+	case 'h'	:
+	case 'H'	:  return 1;
+	default		:  return -EINVAL;
+	}
+}
+
+static gpio_state_t
+gpio_pxa_apply_neg(gpio_state_t state, int is_neg)
+{
+	if (!is_neg) return state;
+	return (state==gpioHI ? gpioLO :
+		state==gpioLO ? gpioHI : state);
+}
+
+#include "gpio-pin.c"
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+#  include "gpio-pin-in.c"
+#endif
+#include "gpio-pin-out.c"
+#include "gpio-pin-vector.c"
+
+static int __devinit gpio_pxa_drv_probe(struct platform_device *pdev)
+{
+	struct gpio_platform_data	*pdata =  pdev->dev.platform_data;
+	struct gpio_pxa_pin_vector	*devdat_vec;
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	struct resource			*gpio_resources;
+#endif
+	size_t				i, idx;
+	int				ret = -ENOMEM;
+
+	dev_dbg(&pdev->dev, "%s:%u/%s()\n", __FILE__, __LINE__, __FUNCTION__);
+
+	if (!pdata)
+		return -EINVAL;
+
+	devdat_vec = kzalloc(sizeof *devdat_vec, GFP_KERNEL);
+	if (devdat_vec==0)
+		return -ENOMEM;
+	idx        = 0;
+
+	spin_lock_init(&devdat_vec->lock);
+	init_waitqueue_head(&devdat_vec->eventq);
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	setup_timer(&devdat_vec->timer, gpio_pxa_ptimer, (unsigned long)(devdat_vec));
+	devdat_vec->ptimer_time = msecs_to_jiffies(10000);
+#endif
+
+#ifdef MODULE
+	devdat_vec->platform_module = pdata->module;
+	if (devdat_vec->platform_module &&
+	    !try_module_get(devdat_vec->platform_module)) {
+		devdat_vec->platform_module = 0;
+		ret                         = -EINVAL;
+		goto err;
+	}
+#endif
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	gpio_resources       = kcalloc(pdata->num_in,  sizeof(gpio_resources[0]),
+				       GFP_KERNEL);
+	devdat_vec->pins_in  = kcalloc(pdata->num_in,  sizeof(devdat_vec->pins_in[0]),
+				       GFP_KERNEL);
+#endif
+	devdat_vec->pins_out = kcalloc(pdata->num_out, sizeof(devdat_vec->pins_out[0]),
+				       GFP_KERNEL);
+	devdat_vec->dev      = kzalloc(sizeof(*devdat_vec->dev), GFP_KERNEL);
+
+	if (devdat_vec->pins_out==0 ||
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	    devdat_vec->pins_in==0  ||
+	    gpio_resources==0       ||
+#endif
+	    devdat_vec->dev==0) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	for (i=0; i<pdata->num_in; ++i) {
+		ret = gpio_pxa_init_pin_in(devdat_vec->pins_in+i,
+					   pdata->gpios_in + i,
+					   idx);
+		if (ret<0)
+			goto err;
+
+		devdat_vec->pins_in[i].pin.owner = devdat_vec;
+		++devdat_vec->num_in;
+		++idx;
+	}
+#endif
+
+	for (i=0; i<pdata->num_out; ++i) {
+		ret = gpio_pxa_init_pin_out(devdat_vec->pins_out+i,
+					    pdata->gpios_out + i,
+					    idx);
+		if (ret<0)
+			goto err;
+
+		devdat_vec->pins_out[i].pin.owner = devdat_vec;
+		++devdat_vec->num_out;
+		++idx;
+	}
+
+	ret = gpiodevall_add_gpio_dev(devdat_vec->dev, devdat_vec,
+				      &devdat_vec->dev_major);
+	if (ret<0)
+		goto err;
+
+	devdat_vec->sysfs_class = gpiosysfs_create(devdat_vec);
+	if (IS_ERR(devdat_vec->sysfs_class)) {
+		ret                     = PTR_ERR(devdat_vec->sysfs_class);
+		devdat_vec->sysfs_class = 0;
+		goto err;
+	}
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	for (i=0; i<devdat_vec->num_in; ++i) {
+		ret = gpio_pxa_create_dev(&devdat_vec->pins_in[i].pin);
+		if (ret<0)
+			goto err;
+	}
+#endif
+
+	for (i=0; i<devdat_vec->num_out; ++i) {
+		ret = gpio_pxa_create_dev(&devdat_vec->pins_out[i].pin);
+		if (ret<0)
+			goto err;
+	}
+
+	platform_set_drvdata(pdev, devdat_vec);
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	for (i=0; i<devdat_vec->num_in; ++i)
+		gpio_pxa_activate_pin_in (devdat_vec->pins_in + i);
+#endif
+
+	for (i=0; i<devdat_vec->num_out; ++i)
+		gpio_pxa_activate_pin_out(devdat_vec->pins_out + i);
+
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	if (devdat_vec->ptimer_time!=0)
+		mod_timer(&devdat_vec->timer, jiffies);
+#endif
+
+	return 0;
+
+err:
+	gpio_pxa_clean_device_vector(devdat_vec);
+	dev_err(&pdev->dev, "%s() failed with code %d\n", __FUNCTION__, ret);
+
+	return ret;
+}
+
+static int __devexit gpio_pxa_drv_remove(struct platform_device *pdev)
+{
+	struct gpio_pxa_pin_vector	*devdat_vec = platform_get_drvdata(pdev);
+
+	dev_dbg(&pdev->dev, "%s:%u/%s()\n", __FILE__, __LINE__, __FUNCTION__);
+
+	if (devdat_vec==0)
+		return -ENODEV;
+
+	gpio_pxa_clean_device_vector(devdat_vec);
+
+	return 0;
+}
+
+static struct platform_driver gpio_pxa_driver = {
+	.probe		=  gpio_pxa_drv_probe,
+	.remove		=  gpio_pxa_drv_remove,
+#if 0
+	.suspend	=  gpio_pxa_drv_suspend,
+	.resume		=  gpio_pxa_drv_resume,
+#endif
+	.driver		= {
+		.owner  = THIS_MODULE,
+		.name	= "pxa2xx-gpio"
+	}
+};
+
+int __init gpio_pxa_init(void)
+{
+	int		ret;
+
+	ret = platform_driver_register(&gpio_pxa_driver);
+	if (ret!=0)
+		printk(KERN_ERR "%s(): platform_driver_register() failed with code %i\n", __FUNCTION__, ret);
+
+	return ret;
+}
+
+void __exit gpio_pxa_exit(void)
+{
+	platform_driver_unregister(&gpio_pxa_driver);
+}
+
+
+module_init(gpio_pxa_init);
+module_exit(gpio_pxa_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pxa2xx-gpio");
diff -Naur linux-3.4.11/drivers/misc/gpio/gpio-pxa.h linux-HEAD/drivers/misc/gpio/gpio-pxa.h
--- linux-3.4.11/drivers/misc/gpio/gpio-pxa.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/gpio/gpio-pxa.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,230 @@
+// $Id$    --*- c -*--
+
+// Copyright (C) 2006 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; version 2 of the License.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+
+#ifndef _H_SIGMA_GPIO_PXA_H
+#define _H_SIGMA_GPIO_PXA_H
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/gpio-misc.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/semaphore.h>
+
+#define GPIODEV_MAJOR		192
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+#define to_pinin(PIN)	container_of(PIN, struct gpio_pxa_pin_in,  pin)
+#endif
+
+#define to_pinout(PIN)	container_of(PIN, struct gpio_pxa_pin_out, pin)
+
+typedef enum { gpioINVALID, gpioHI=23, gpioLO=42 }		gpio_state_t;
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+struct gpio_pxa_in_event
+{
+	struct gpio_event		event;
+	gpio_state_t			state;
+};
+#endif
+
+struct gpio_pxa_pin
+{
+	char				name[GPIO_NAME_SIZE];
+	enum {
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+		gpiodirIN=32,
+#endif
+		gpiodirOUT=24 }	dir;
+	unsigned int			gpio;
+	int				negated;
+	int				id;
+	spinlock_t			lock;
+	struct gpio_pxa_pin_vector	*owner;
+
+	struct gpiodev_dev		*dev;
+	struct device			*sysfs;
+};
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+struct gpio_pxa_pin_in
+{
+	// debounce-timeout (jiffies); 0 disables debounce feature
+	unsigned long			debounce;
+	// edge on which the event gets triggered; encoded by using the IRQT_*
+	// macros
+	unsigned int			edge;
+
+	wait_queue_head_t		eventq;
+	struct gpio_pxa_in_event	cur;
+	struct gpio_pxa_in_event	pend;
+
+	struct timer_list		timer;
+	struct gpio_pxa_pin		pin;
+};
+#endif
+
+struct gpio_pxa_pin_out
+{
+	int				level;
+#ifdef CONFIG_PM
+	int				suspend_level;
+#endif
+	struct gpio_pxa_pin		pin;
+};
+
+
+struct gpiodev_dev;
+struct gpiodevall_dev;
+
+struct gpio_pxa_pin_vector
+{
+	int				dev_major;
+
+	struct gpiodevall_dev		*dev;
+	struct gpiosysfs_class		*sysfs_class;
+
+	spinlock_t			lock;
+	wait_queue_head_t		eventq;
+
+#ifdef MODULE
+	struct module			*platform_module;
+#endif
+
+	unsigned int			seqnr;
+	uint64_t			levels;
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	struct timer_list		timer;
+	unsigned long			ptimer_time;
+
+	size_t				num_in;
+	struct gpio_pxa_pin_in		*pins_in;
+#endif
+
+	size_t				num_out;
+	struct gpio_pxa_pin_out		*pins_out;
+};
+
+
+struct gpiodev_dev
+{
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	union {
+		struct gpio_event	event;
+		char			buf[sizeof(struct gpio_event)];
+	} __attribute__((__packed__))	data;
+
+	unsigned int			seqnr;
+#endif
+
+	struct gpio_pxa_pin		*pin;
+	struct semaphore		sem;
+	struct cdev			cdev;
+};
+
+struct gpiodevall_dev
+{
+	struct gpio_pxa_pin_vector	*vec;
+
+	unsigned int			seqnr;
+
+	struct semaphore		sem;
+	struct cdev			cdev;
+};
+
+struct gpiosysfs_class
+{
+	struct gpio_pxa_pin_vector	*gpio;
+	struct device			all;
+	struct class			cls;
+};
+
+
+int		str2bool(char const *buf, size_t count);
+
+int		gpio_pxa_set_state        (struct gpio_pxa_pin_out *pin,    gpio_state_t state);
+
+#ifdef CONFIG_PM
+int		gpio_pxa_set_suspend_state(struct gpio_pxa_pin_out *pin,    gpio_state_t state);
+#endif
+
+int		gpio_pxa_set_negated (struct gpio_pxa_pin    *devdat, int neg);
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+int		gpio_pxa_set_debounce(struct gpio_pxa_pin_in *devdat, int debounce);
+int		gpio_pxa_set_edge    (struct gpio_pxa_pin_in *devdat, unsigned int edge);
+int		gpio_pxa_get_edge    (struct gpio_pxa_pin_in *devdat, unsigned int *edge);
+void		gpio_pxa_get_event   (struct gpio_pxa_pin_in *devdat, struct gpio_event *event);
+int		gpio_pxa_trigger(struct gpio_pxa_pin_in *devdat);
+
+int		gpio_pxa_set_ptimer(struct gpio_pxa_pin_vector *vec, unsigned long new_timeout);
+#endif
+
+inline static size_t
+gpio_pxa_get_pin_cnt(struct gpio_pxa_pin_vector const *vec)
+{
+	return vec->num_out
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+		+ vec->num_in
+#endif
+		;
+}
+
+
+int		gpio_pxa_get_global_state(struct gpio_pxa_pin_vector *dev,
+					  uint64_t *level);
+
+
+
+
+
+int		gpiodev_add_gpio_dev(struct gpiodev_dev *dev,
+				     struct gpio_pxa_pin *info,
+				     int major);
+
+void		gpiodev_del_gpio_dev(struct gpiodev_dev *dev);
+
+
+int		gpiodevall_add_gpio_dev(struct gpiodevall_dev *dev,
+					struct gpio_pxa_pin_vector *vec,
+					int *major);
+
+void		gpiodevall_del_gpio_dev(struct gpiodevall_dev *dev);
+
+void		gpiodevall_unregister_chrdevs(int major, int count);
+
+
+struct gpiosysfs_class *	gpiosysfs_create(struct gpio_pxa_pin_vector *);
+void				gpiosysfs_release(struct gpiosysfs_class *c);
+
+struct device *			gpiosysfs_attach(struct gpio_pxa_pin *info);
+void				gpiosysfs_detach(struct device *);
+
+#if !defined(MODULE) || !defined(CONFIG_MODULE_UNLOAD)
+#  define __initexit		__init
+#else
+#  define __initexit
+#endif
+
+#endif	//  _H_SIGMA_GPIO_PXA_H
diff -Naur linux-3.4.11/drivers/misc/gpio/gpio-sysfs.c linux-HEAD/drivers/misc/gpio/gpio-sysfs.c
--- linux-3.4.11/drivers/misc/gpio/gpio-sysfs.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/gpio/gpio-sysfs.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,660 @@
+// $Id$    --*- c -*--
+
+// Copyright (C) 2006 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; version 2 of the License.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+
+#include "gpio-pxa.h"
+
+#include <linux/irq.h>
+#include <linux/jiffies.h>
+#include <linux/string.h>
+#include <linux/device.h>
+#include <linux/sysfs.h>
+#include <linux/sysdev.h>
+#include <linux/slab.h>
+
+#ifdef CONFIG_ELITO_GPIO_DEBUG_STATUS
+
+#ifdef CONFIG_PXA27x
+#include <mach/hardware.h>
+#include <mach/pxa2xx-regs.h>
+#include <mach/gpio.h>
+#include <plat/gpio.h>
+static ssize_t gpiosysfs_show_setup(struct class *dev,
+				    struct class_attribute *attr,
+				    char *buf)
+{
+	int		i;
+
+	sprintf(buf, "nr  dir af level\n");
+	for (i=0; i<=120; ++i) {
+		char	tmp[20];
+		sprintf(tmp, "%3i %s %i %i\n",
+			i,
+			GPDR(i) & GPIO_bit(i) ? "out" : "in ",
+			(GAFR(i) >> ((i&0xf)*2)) & 0x3,
+			GPLR(i) & GPIO_bit(i) ? 1 : 0);
+		strcat(buf, tmp);
+	}
+	return strlen(buf);
+}
+#endif
+
+#endif	// CONFIG_ELITO_GPIO_DEBUG_STATUS
+
+#ifdef CONFIG_ELITO_GPIO_DEBUG_STATUS_WRITE
+#ifdef CONFIG_PXA27x
+
+#define GPIO_IN			0x000
+#define GPIO_OUT		0x080
+#define GPIO_ALT_FN_1_IN	0x100
+#define GPIO_ALT_FN_1_OUT	0x180
+#define GPIO_ALT_FN_2_IN	0x200
+#define GPIO_ALT_FN_2_OUT	0x280
+#define GPIO_ALT_FN_3_IN	0x300
+#define GPIO_ALT_FN_3_OUT	0x380
+#define GPIO_MD_MASK_NR		0x07f
+#define GPIO_MD_MASK_DIR	0x080
+#define GPIO_MD_MASK_FN		0x300
+#define GPIO_DFLT_LOW		0x400
+#define GPIO_DFLT_HIGH		0x800
+
+static int pxa_gpio_mode(int gpio_mode)
+{
+	unsigned long flags;
+	int gpio = gpio_mode & GPIO_MD_MASK_NR;
+	int fn = (gpio_mode & GPIO_MD_MASK_FN) >> 8;
+	int gafr;
+
+	if (gpio > pxa_last_gpio)
+		return -EINVAL;
+
+	local_irq_save(flags);
+	if (gpio_mode & GPIO_DFLT_LOW)
+		GPCR(gpio) = GPIO_bit(gpio);
+	else if (gpio_mode & GPIO_DFLT_HIGH)
+		GPSR(gpio) = GPIO_bit(gpio);
+	if (gpio_mode & GPIO_MD_MASK_DIR)
+		GPDR(gpio) |= GPIO_bit(gpio);
+	else
+		GPDR(gpio) &= ~GPIO_bit(gpio);
+	gafr = GAFR(gpio) & ~(0x3 << (((gpio) & 0xf)*2));
+	GAFR(gpio) = gafr |  (fn  << (((gpio) & 0xf)*2));
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static ssize_t gpiosysfs_set_setup(struct class *dev,
+				   struct class_attribute *attr,
+				   char const *buf, size_t count)
+{
+	// Input format: GPIO,[LEVEL],[DIR],[AF]
+	int		data[4] = { -1, -1, -1, -1 };
+	int		mode  = 0;
+	int		state = 0;
+	char const	*ptr = buf;
+
+	if (*buf=='\n' || *buf==' ' || *buf=='\t')
+		return 1;
+
+	while (ptr!=0 && ptr<buf+count && state<4) {
+		char	*e;
+		data[state] = simple_strtoul(ptr, &e, 0);
+		if (e==ptr)
+			return -EINVAL;
+		switch (*e) {
+		case ','	:
+			ptr = e+1;
+			++state;
+			break;
+		case '\n'	:
+		case '\r'	:
+		case '\0'	:
+			++ptr;
+			count = ptr-buf;
+			break;
+		default:
+			return -EINVAL;
+		}
+	}
+
+	pr_debug("%s() -> read [%i,%i,%i,%i], state=%i\n",
+		 __FUNCTION__,
+		 data[0], data[1], data[2], data[3], state);
+
+
+	if (data[0]<0 || data[0]>120 || state>=4)
+		return -EINVAL;
+
+	switch (data[1]) {
+	case -1	:  break;
+	case 0	:  mode |= GPIO_DFLT_LOW;  break;
+	case 1	:  mode |= GPIO_DFLT_HIGH; break;
+	default :  return -EINVAL;
+	}
+
+
+	if (data[2]==-1)
+		data[2] = (GPDR(data[0]) & GPIO_bit(data[0])) ? 1 : 0;
+
+	switch (data[2]) {
+	case 0	:  mode |= GPIO_IN;  break;
+	case 1	:  mode |= GPIO_OUT; break;
+	default :  return -EINVAL;
+	}
+
+
+	if (data[3]==-1)
+		data[3] = (GAFR(data[0]) >> ((data[0] & 0xf)*2)) & 0x3;
+
+	switch (data[3]) {
+	case 0	:  break;
+	case 1	:  mode |= GPIO_ALT_FN_1_IN & GPIO_MD_MASK_FN; break;
+	case 2	:  mode |= GPIO_ALT_FN_2_IN & GPIO_MD_MASK_FN; break;
+	case 3	:  mode |= GPIO_ALT_FN_3_IN & GPIO_MD_MASK_FN; break;
+	default :  return -EINVAL;
+	}
+
+
+	printk("setting GPIO %i to mode 0x%03x\n", data[0], mode);
+	pxa_gpio_mode(data[0] | mode);
+
+	printk("GPLR0=%08x GPDR0=%08x GRER0=%08x GFER0=%08x GAFR0=[%08x,%08x]\n",
+	       GPLR0, GPDR0, GRER0, GFER0, GAFR0_U, GAFR0_L);
+
+	return count;
+}
+#endif
+
+#endif	// CONFIG_ELITO_GPIO_DEBUG_STATUS
+
+
+#define to_gpio(DEV) container_of(DEV, struct gpiosysfs_class, cls)
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+static ssize_t gpiosysfs_show_ptimer(struct class *dev, char *buf)
+{
+	struct gpiosysfs_class	*g = to_gpio(dev);
+
+	if (g==0 || g->gpio==0)
+		return -EINVAL;
+
+	return sprintf(buf, "%u\n", jiffies_to_msecs(g->gpio->ptimer_time));
+}
+
+static ssize_t gpiosysfs_set_ptimer(struct class *dev,
+				    char const *buf, size_t count)
+{
+	struct gpiosysfs_class	*g = to_gpio(dev);
+
+	if (g==0 || g->gpio==0)
+		return -EINVAL;
+
+	gpio_pxa_set_ptimer(g->gpio, msecs_to_jiffies(simple_strtoul(buf, 0, 0)));
+	return count;
+}
+#endif
+
+static ssize_t gpiosysfs_show_direction(struct device *dev, struct device_attribute *attr,
+					char *buf)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+
+	if (g==0)
+		return -ENODEV;
+
+	switch (g->dir) {
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	case gpiodirIN:		return sprintf(buf, "in\n");
+#endif
+	case gpiodirOUT:	return sprintf(buf, "out\n");
+	default:		return sprintf(buf, "unknown\n");
+	}
+}
+
+static ssize_t gpiosysfs_show_level(struct device *dev, struct device_attribute *attr,
+				    char *buf)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+	int			level;
+
+	if (g==0)
+		return -ENODEV;
+
+	switch (g->dir) {
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	case gpiodirIN:	{
+		struct gpio_event	event;
+		gpio_pxa_get_event(to_pinin(g), &event);
+
+		level = event.level;
+		break;
+	}
+#endif
+	case gpiodirOUT:	level = to_pinout(g)->level; break;
+	default:		return -EIO; break;
+	}
+
+	switch (level) {
+	case 0:		return sprintf(buf, "0\n");
+	default:	return sprintf(buf, "1\n");
+	}
+}
+
+static ssize_t gpiosysfs_set_level(struct device *dev, struct device_attribute *attr,
+				   char const *buf, size_t count)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+	int			tmp;
+
+	if (g==0)
+		return -ENODEV;
+
+	if (g->dir!=gpiodirOUT)
+		return -EPERM;
+
+	tmp = str2bool(buf, count);
+	if (tmp<0)
+		return tmp;
+
+	gpio_pxa_set_state(to_pinout(g), tmp ? gpioHI :gpioLO);
+	return count;
+}
+
+#ifdef CONFIG_PM
+static ssize_t gpiosysfs_show_suspend_level(struct device *dev, struct device_attribute *attr,
+					    char *buf)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+	int			level;
+
+	if (g==0)
+		return -ENODEV;
+
+	if (g->dir!=gpiodirOUT)
+		return -EPERM;
+
+	level = to_pinout(g)->suspend_level;
+
+	switch (level) {
+	case 0:		return sprintf(buf, "lo\n");
+	default:	return sprintf(buf, "hi\n");
+	}
+}
+
+static ssize_t gpiosysfs_set_suspend_level(struct device *dev, struct device_attribute *attr,
+					   char const *buf, size_t count)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+	int			tmp;
+
+	if (g==0)
+		return -ENODEV;
+
+	if (g->dir!=gpiodirOUT)
+		return -EPERM;
+
+	tmp = str2bool(buf, count);
+	if (tmp<0)
+		return tmp;
+
+	gpio_pxa_set_suspend_state(to_pinout(g), tmp ? gpioHI :gpioLO);
+	return count;
+}
+#endif
+
+static ssize_t gpiosysfs_show_negated(struct device *dev, struct device_attribute *attr,
+				      char *buf)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+
+	if (g==0)
+		return -ENODEV;
+
+	return sprintf(buf, "%u\n", g->negated ? 1 : 0);
+}
+
+static ssize_t gpiosysfs_set_negated(struct device *dev, struct device_attribute *attr,
+				     char const *buf, size_t count)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+	int			tmp;
+
+	if (g==0)
+		return -ENODEV;
+
+	tmp = str2bool(buf, count);
+	if (tmp<0)
+		return tmp;
+
+	gpio_pxa_set_negated(g, tmp);
+	return count;
+}
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+static ssize_t gpiosysfs_show_debounce(struct device *dev, struct device_attribute *attr,
+				       char *buf)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+
+	if (g==0)
+		return -ENODEV;
+
+	return sprintf(buf, "%u\n", jiffies_to_msecs(to_pinin(g)->debounce));
+}
+
+static ssize_t gpiosysfs_set_debounce(struct device *dev,
+				      struct device_attribute *attr,
+				      char const *buf, size_t count)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+
+	if (g==0) return -ENODEV;
+
+	gpio_pxa_set_debounce(to_pinin(g), msecs_to_jiffies(simple_strtoul(buf, 0, 0)));
+	return count;
+}
+
+static ssize_t gpiosysfs_show_edge(struct device *dev, struct device_attribute *attr,
+				   char *buf)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+	int			rc;
+	unsigned int		edge;
+	char const *		res;
+
+	if (g==0)
+		return -ENODEV;
+
+	rc = gpio_pxa_get_edge(to_pinin(g), &edge);
+	if (rc<0)
+		return rc;
+
+	if      (edge == IRQ_TYPE_EDGE_BOTH)     res="both";
+	else if (edge == IRQ_TYPE_EDGE_RISING)   res="rising";
+	else if (edge == IRQ_TYPE_EDGE_FALLING)  res="falling";
+	else					 res="disabled";
+
+	return sprintf(buf, "%s\n", res);
+}
+
+static ssize_t gpiosysfs_set_edge(struct device *dev, struct device_attribute *attr,
+				  char const *buf, size_t count)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+	unsigned int		edge;
+	int			rc;
+
+	if (g==0) return -ENODEV;
+
+	if      (strncmp(buf, "both",    min(count,4u))==0) edge = IRQ_TYPE_EDGE_BOTH;
+	else if (strncmp(buf, "rising",  min(count,6u))==0) edge = IRQ_TYPE_EDGE_RISING;
+	else if (strncmp(buf, "falling", min(count,7u))==0) edge = IRQ_TYPE_EDGE_FALLING;
+	else                                                edge = IRQ_TYPE_NONE;
+
+	rc = gpio_pxa_set_edge(to_pinin(g), edge);
+	if (rc<0)
+		return rc;
+	else
+		return count;
+}
+#endif
+
+static ssize_t gpiosysfs_show_id(struct device *dev, struct device_attribute *attr,
+				 char *buf)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+
+	if (g==0)
+		return -ENODEV;
+
+	return sprintf(buf, "%u\n", g->id);
+}
+
+
+
+#if 0
+static ssize_t gpiosysfs_show_trigger(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	struct gpio_pxa_pin		*g = dev ? dev_get_drvdata(dev) : 0;
+	struct gpio_pxa_pin_in * const	gpio = g ? &(g->in) : 0;
+	unsigned int			cur_seq;
+
+	if (g==0) return -ENODEV;
+
+	cur_seq = gpio->cur.event.seqnr;
+	do {
+		if (wait_event_interruptible(gpio->eventq,
+					     cur_seq!=gpio->cur.event.seqnr))
+			return -ERESTARTSYS;
+	} while (cur_seq!=gpio->cur.event.seqnr);
+
+	return sprintf(buf, "%u\n", gpio->cur.event.level);
+}
+#endif
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+static ssize_t gpiosysfs_set_trigger(struct device *dev,
+				     struct device_attribute *attr,
+				     char const *buf, size_t count)
+{
+	struct gpio_pxa_pin	*g = dev ? dev_get_drvdata(dev) : 0;
+	if (g==0) return -ENODEV;
+
+	gpio_pxa_trigger(to_pinin(g));
+
+	return count;
+}
+#endif
+
+static struct class_attribute gpiosysfs_attributes[] = {
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	__ATTR(ptimer,    0444, gpiosysfs_show_ptimer,     gpiosysfs_set_ptimer),
+#endif
+
+#if   defined(CONFIG_ELITO_GPIO_DEBUG_STATUS) &&  defined(CONFIG_ELITO_GPIO_DEBUG_STATUS_WRITE)
+	__ATTR(setup,     0600, gpiosysfs_show_setup,      gpiosysfs_set_setup),
+#elif defined(CONFIG_ELITO_GPIO_DEBUG_STATUS) && !defined(CONFIG_ELITO_GPIO_DEBUG_STATUS_WRITE)
+	__ATTR(setup,     0400, gpiosysfs_show_setup,      0),
+#endif
+	__ATTR_NULL,
+};
+
+
+static struct device_attribute gpiosysfs_dev_attributes[] = {
+	__ATTR(direction, 0444, gpiosysfs_show_direction, 0),
+	__ATTR(id,        0444, gpiosysfs_show_id,        0),
+	__ATTR(negated,   0644, gpiosysfs_show_negated,   gpiosysfs_set_negated),
+	__ATTR_NULL
+};
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+static struct device_attribute gpiosysfs_dev_in_attributes[] = {
+	__ATTR(level,     0400, gpiosysfs_show_level,     0),
+	__ATTR(debounce,  0644, gpiosysfs_show_debounce,  gpiosysfs_set_debounce),
+	__ATTR(trigger,   0200, 0,                        gpiosysfs_set_trigger),
+	__ATTR(edge,      0644, gpiosysfs_show_edge,      gpiosysfs_set_edge),
+	__ATTR_NULL,
+};
+#endif
+
+static struct device_attribute gpiosysfs_dev_out_attributes[] = {
+	__ATTR(level,         0600, gpiosysfs_show_level,             gpiosysfs_set_level),
+#ifdef CONFIG_PM
+	__ATTR(suspend_level, 0600, gpiosysfs_show_suspend_level,     gpiosysfs_set_suspend_level),
+#endif
+	__ATTR_NULL,
+};
+
+static struct device_attribute gpiosysfs_dev_all_attributes[] = {
+	__ATTR_NULL,
+};
+
+// stolen from drivers/base/class.c
+static int device_add_attrs(struct device * cd,
+			    struct device_attribute attrs[])
+{
+	int i;
+	int error = 0;
+
+	for (i = 0; attr_name(attrs[i]); i++) {
+		error = device_create_file(cd, attrs+i);
+		if (error)
+			goto Err;
+	}
+Done:
+	return error;
+Err:
+	while (--i >= 0)
+		device_remove_file(cd,attrs+i);
+	goto Done;
+}
+
+
+static void
+gpiosysfs_dev_release(struct device *dev)
+{
+//	class_device_remove_file(res, &class_device_attr_dev);
+}
+
+struct device * __devinit
+gpiosysfs_attach(struct gpio_pxa_pin *info)
+{
+	struct device	*res;
+	int		rc;
+
+	res = kzalloc(sizeof *res, GFP_KERNEL);
+	if (res==0)
+		return ERR_PTR(-ENOMEM);
+
+	res->class      =  &info->owner->sysfs_class->cls;
+	res->devt	=  info->dev->cdev.dev;
+	dev_set_drvdata(res, info);
+	kobject_set_name(&res->kobj, "%s", info->name);
+
+	rc = device_register(res);
+	if (rc<0)
+		goto err;
+
+#ifdef CONFIG_ELITO_GPIO_PXA_IN
+	if (info->dir==gpiodirIN) {
+		if ((rc=device_add_attrs(res, gpiosysfs_dev_in_attributes))<0)
+			goto err1;
+	}
+	else
+#endif
+	{
+		if ((rc=device_add_attrs(res, gpiosysfs_dev_out_attributes))<0)
+			goto err1;
+	}
+
+	return res;
+
+err1:
+	device_unregister(res);
+
+err:
+	kfree(res);
+	return ERR_PTR(rc);
+}
+
+static int __devinit
+gpiosysfs_create_all_device(struct device *dev,
+			    struct gpiosysfs_class *class)
+{
+	int			rc;
+	struct device_attribute	*attr;
+
+	dev->class      =  &class->cls;
+	dev->devt	=  class->gpio->dev->cdev.dev;;
+
+	dev_set_drvdata(dev, class->gpio);
+	kobject_set_name(&dev->kobj, "ALL");
+
+	rc = device_register(dev);
+	if (rc<0)
+		return rc;
+
+	for (attr=gpiosysfs_dev_attributes+0; attr_name(*attr); ++attr)
+		device_remove_file(dev, attr);
+
+	rc=device_add_attrs(dev, gpiosysfs_dev_all_attributes);
+	if (rc<0)
+		goto err;
+
+	return 0;
+
+err:
+	device_unregister(dev);
+	return rc;
+}
+
+struct gpiosysfs_class * __devinit
+gpiosysfs_create(struct gpio_pxa_pin_vector *vec)
+{
+	struct gpiosysfs_class	*res;
+	int			rc;
+
+	res = kzalloc(sizeof *res, GFP_KERNEL);
+	if (res==0)
+		return ERR_PTR(-ENOMEM);
+
+	res->gpio                = vec;
+#ifdef CONFIG_ELITO_GPIO_SYSFS
+	res->cls.name		 = "gpiox";
+#else
+	res->cls.name		 = "gpio";
+#endif
+	res->cls.owner		 = THIS_MODULE;
+	res->cls.class_attrs     = gpiosysfs_attributes+0;
+	res->cls.dev_attrs       = gpiosysfs_dev_attributes+0;
+	res->cls.dev_release	 = gpiosysfs_dev_release;
+
+	rc = class_register(&res->cls);
+	if (rc<0)
+		goto err0;
+
+	rc = gpiosysfs_create_all_device(&res->all, res);
+	if (rc<0)
+		goto err1;
+
+	return res;
+
+
+err1:
+	class_unregister(&res->cls);
+
+err0:
+	kfree(res);
+	return ERR_PTR(rc);
+}
+
+void
+gpiosysfs_detach(struct device *dev)
+{
+	device_unregister(dev);
+}
+
+void
+gpiosysfs_release(struct gpiosysfs_class *c)
+{
+	device_unregister(&c->all);
+	class_unregister(&c->cls);
+	kfree(c);
+}
diff -Naur linux-3.4.11/drivers/misc/gpio/Kconfig linux-HEAD/drivers/misc/gpio/Kconfig
--- linux-3.4.11/drivers/misc/gpio/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/gpio/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,24 @@
+config ELITO_GPIO
+	bool
+
+config ELITO_GPIO_DEBUG_STATUS
+	bool "enable /sys/class/gpio/setup debug interface"
+	depends on ELITO_GPIO && DEBUG_KERNEL && ARCH_PXA && !PXA3xx
+
+config ELITO_GPIO_DEBUG_STATUS_WRITE
+	bool "enable write access to the /sys/class/gpio/setup debug interface"
+	depends on ELITO_GPIO_DEBUG_STATUS
+
+
+config ELITO_GPIO_PXA
+	tristate "Device driver for GPIO in/output"
+	depends on ARCH_PXA
+	select ELITO_GPIO
+
+config ELITO_GPIO_PXA_IN
+	bool "Enable input functionality (deprecated)"
+	depends on ELITO_GPIO_PXA
+
+config ELITO_GPIO_DEBUG
+	bool "enabling debugging of the GPIO driver"
+	depends on ELITO_GPIO_PXA
diff -Naur linux-3.4.11/drivers/misc/gpio/Makefile linux-HEAD/drivers/misc/gpio/Makefile
--- linux-3.4.11/drivers/misc/gpio/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/gpio/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,12 @@
+ifneq ($(CONFIG_ELITO_GPIO_PXA),)
+obj-$(CONFIG_ELITO_GPIO_PXA)			+=  gpio-pxa.o
+
+ifeq ($(CONFIG_ELITO_GPIO_DEBUG),y)
+EXTRA_CFLAGS				+=	-DDEBUG
+endif
+
+gpio-pxa-y	:=		gpio-pxa-core.o \
+				gpio-dev.o	\
+				gpio-devall.o	\
+				gpio-sysfs.o
+endif
diff -Naur linux-3.4.11/drivers/misc/Kconfig linux-HEAD/drivers/misc/Kconfig
--- linux-3.4.11/drivers/misc/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/misc/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -498,6 +498,8 @@
 	  Maxim MAX8997 PMIC.
 	  The MAX8997 MUIC is a USB port accessory detector and switch.
 
+source "drivers/misc/gpio/Kconfig"
+source "drivers/misc/max730x-lib/Kconfig"
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
diff -Naur linux-3.4.11/drivers/misc/Makefile linux-HEAD/drivers/misc/Makefile
--- linux-3.4.11/drivers/misc/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/misc/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -7,10 +7,12 @@
 obj-$(CONFIG_AD525X_DPOT_I2C)	+= ad525x_dpot-i2c.o
 obj-$(CONFIG_AD525X_DPOT_SPI)	+= ad525x_dpot-spi.o
 obj-$(CONFIG_INTEL_MID_PTI)	+= pti.o
+obj-$(CONFIG_MAX730X_LIB)  	+= max730x-lib/
 obj-$(CONFIG_ATMEL_PWM)		+= atmel_pwm.o
 obj-$(CONFIG_ATMEL_SSC)		+= atmel-ssc.o
 obj-$(CONFIG_ATMEL_TCLIB)	+= atmel_tclib.o
 obj-$(CONFIG_BMP085)		+= bmp085.o
+obj-$(CONFIG_GPIO)		+= gpio/
 obj-$(CONFIG_ICS932S401)	+= ics932s401.o
 obj-$(CONFIG_LKDTM)		+= lkdtm.o
 obj-$(CONFIG_TIFM_CORE)       	+= tifm_core.o
diff -Naur linux-3.4.11/drivers/misc/max730x-lib/Kconfig linux-HEAD/drivers/misc/max730x-lib/Kconfig
--- linux-3.4.11/drivers/misc/max730x-lib/Kconfig	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/max730x-lib/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,3 @@
+config MAX730X_LIB
+	tristate
+	depends on I2C || SPI
diff -Naur linux-3.4.11/drivers/misc/max730x-lib/Makefile linux-HEAD/drivers/misc/max730x-lib/Makefile
--- linux-3.4.11/drivers/misc/max730x-lib/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/max730x-lib/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1 @@
+obj-$(CONFIG_MAX730X_LIB) += 	max730x.o
diff -Naur linux-3.4.11/drivers/misc/max730x-lib/max730x.c linux-HEAD/drivers/misc/max730x-lib/max730x.c
--- linux-3.4.11/drivers/misc/max730x-lib/max730x.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/max730x-lib/max730x.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,460 @@
+/*	--*- c -*--
+ * Copyright (C) 2008 Enrico Scholz <enrico.scholz@informatik.tu-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "max730x-priv.h"
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+
+static inline int p47_cont(void)
+{
+	/* Documentation says that 0x40 holds data bits 4-7 in D0-D3, but they
+	 * seem to be at D4-D7 */
+	return 1;
+}
+
+static uint8_t max730x_compress(uint8_t v)
+{
+	return (((v & 0x01) >> 0) |
+		((v & 0x04) >> 1) |
+		((v & 0x10) >> 2) |
+		((v & 0x40) >> 3));
+}
+
+static uint8_t max730x_uncompress(uint8_t v)
+{
+	return (((v & 0x01) << 0) |
+		((v & 0x02) << 2) |
+		((v & 0x04) << 4) |
+		((v & 0x08) << 6));
+}
+
+
+static void xxx_device_remove_files(struct device *dev, struct device_attribute attr[],
+				   size_t num_attr)
+{
+	while (num_attr-->0)
+		device_remove_file(dev, attr+num_attr);
+}
+
+static int xxx_device_create_files(struct device *dev, struct device_attribute attr[],
+				   size_t num_attr)
+{
+	size_t		i;
+	int		rc = 0;
+
+	for (i=0; i<num_attr && likely(rc==0); ++i)
+		rc = device_create_file(dev, attr+i);
+
+	if (rc)
+		xxx_device_create_files(dev, attr, i);
+
+	return rc;
+}
+
+static ssize_t parse_val_mask_pair(char const *buf, size_t len,
+				   uint32_t *val, uint32_t *mask)
+{
+	char		*endp;
+
+	*val = simple_strtoul(buf, &endp, 0);
+	if (!endp || *endp!='&')
+		*mask = ~0u;
+	else
+		*mask = simple_strtoul(endp+1, &endp, 0);
+
+	if (!endp || (*endp!='\0' && *endp!='\n'))
+		return -EINVAL;
+
+	while (*endp == '\n')
+		++endp;
+
+	return endp - buf;
+}
+
+#define to_max730x_device(X)	(dev_get_drvdata(X))
+#define to_max730x_priv(X)	(container_of(X, struct max730x_priv, max730x))
+
+static ssize_t max730x_sys_dir_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct max730x_device * const	mdev  = to_max730x_device(dev);
+	struct max730x_priv * const	mpriv = to_max730x_priv(mdev);
+	struct max730x_op * const	ops   = mpriv->ops;
+	uint8_t				tmp[8];
+	uint32_t			dir = 0;
+	size_t				i;
+	int				rc = 0;
+
+	for (i=4; i<32 && likely(rc==0); i+=4)
+		rc = ops->get(ops, 0x08 + i/4, tmp + i/4);
+
+	if (rc<0)
+		return rc;
+
+	tmp[0] = 0;
+	for (i=ARRAY_SIZE(tmp); i>0; --i) {
+		dir <<= 4;
+		dir  |= max730x_compress(tmp[i-1]>>1);
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%08x %08x\n", ~dir, mpriv->dir);
+}
+
+static ssize_t max730x_sys_dir_store(struct device *dev,
+				      struct device_attribute *attr,
+				      char const *buf,
+				      size_t len)
+{
+	struct max730x_device * const	mdev  = to_max730x_device(dev);
+	struct max730x_priv * const	mpriv = to_max730x_priv(mdev);
+	struct max730x_op * const	ops   = mpriv->ops;
+	uint32_t			val, mask;
+	uint32_t			new_dir;
+	ssize_t				res;
+	size_t				i;
+	int				rc = 0;
+
+	res = parse_val_mask_pair(buf, len, &val, &mask);
+	if (res<0)
+		return res;
+
+	val &= ~mask;
+	val  = ~val;
+
+	if (mask & 0x0f)
+		return -EINVAL;
+
+	new_dir = (mpriv->dir & ~mask) | val;
+
+	for (i=4; i<32 && likely(rc==0); i+=4) {
+		uint8_t		tmp = (new_dir>>i) & 0x0f;
+		if (tmp==0)
+			continue;
+
+		tmp = ((max730x_uncompress(tmp)<<1) |
+		       (max730x_uncompress((mpriv->pullup>>i) & 0x0f)));
+
+		rc = ops->set(ops, 0x08 + i/4, tmp);
+		if (likely(rc==0)) {
+			mpriv->dir &= ~(0x0fu << i);
+			mpriv->dir |=  (new_dir & (0x0fu << i));
+		}
+	}
+
+	if (rc<0)
+		return rc;
+
+	return res;
+}
+
+static ssize_t max730x_sys_pullup_show(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	struct max730x_device * const	mdev  = to_max730x_device(dev);
+	struct max730x_priv * const	mpriv = to_max730x_priv(mdev);
+	struct max730x_op * const	ops   = mpriv->ops;
+	uint8_t				tmp[8];
+	uint32_t			pullup = 0;
+	size_t				i;
+	int				rc = 0;
+
+	for (i=4; i<32 && likely(rc==0); i+=4)
+		rc = ops->get(ops, 0x08 + i/4, tmp + i/4);
+
+	if (rc<0)
+		return rc;
+
+	tmp[0] = 0;
+	for (i=ARRAY_SIZE(tmp); i>0; --i) {
+		pullup <<= 4;
+		pullup  |= max730x_compress(tmp[i-1]);
+	}
+
+	return snprintf(buf, PAGE_SIZE, "%08x %08x\n", pullup, mpriv->pullup);
+}
+
+static ssize_t max730x_sys_pullup_store(struct device *dev,
+					struct device_attribute *attr,
+					char const *buf,
+					size_t len)
+{
+	struct max730x_device * const	mdev  = to_max730x_device(dev);
+	struct max730x_priv * const	mpriv = to_max730x_priv(mdev);
+	struct max730x_op * const	ops   = mpriv->ops;
+	uint32_t			val, mask;
+	uint32_t			new_pullup;
+	ssize_t				res;
+	size_t				i;
+	int				rc = 0;
+
+	res = parse_val_mask_pair(buf, len, &val, &mask);
+	if (res<0)
+		return res;
+
+	val &= ~mask;
+	val  = ~val;
+
+	if (mask & 0x0f)
+		return -EINVAL;
+
+	new_pullup = (mpriv->pullup & ~mask) | val;
+
+	for (i=4; i<32 && likely(rc==0); i+=4) {
+		uint8_t		tmp = (new_pullup>>i) & 0x0f;
+		if (tmp==0)
+			continue;
+
+		tmp = ((max730x_uncompress(tmp)) |
+		       (max730x_uncompress((mpriv->pullup>>i) & 0x0f)<<1));
+
+		rc = ops->set(ops, 0x08 + i/4, tmp);
+		if (likely(rc==0)) {
+			mpriv->pullup &= ~(0x0fu << i);
+			mpriv->pullup |=  (new_pullup & (0x0fu << i));
+		}
+	}
+
+	if (rc<0)
+		return rc;
+
+	return res;
+}
+
+static ssize_t max730x_sys_value_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	struct max730x_device * const	mdev  = to_max730x_device(dev);
+	struct max730x_priv * const	mpriv = to_max730x_priv(mdev);
+	struct max730x_op * const	ops   = mpriv->ops;
+	uint8_t				tmp[4];
+	int				rc = 0;
+	size_t				i;
+
+	for (i=0; i<ARRAY_SIZE(tmp) && likely(rc==0); ++i)
+		rc = ops->get(ops, 0x40 + i*8, tmp+i);
+
+	if (rc<0)
+		return rc;
+
+	if (!p47_cont())
+		tmp[0] <<= 4;
+	return snprintf(buf, PAGE_SIZE, "%02x%02x%02x%02x %08x\n",
+			tmp[3], tmp[2], tmp[1], tmp[0],
+			mpriv->val);
+}
+
+static ssize_t max730x_sys_value_store(struct device *dev,
+				       struct device_attribute *attr,
+				       char const *buf,
+				       size_t len)
+{
+	struct max730x_device * const	mdev  = to_max730x_device(dev);
+	struct max730x_priv * const	mpriv = to_max730x_priv(mdev);
+	struct max730x_op * const	ops   = mpriv->ops;
+	uint32_t			val, mask;
+	size_t				i;
+	int				rc = 0;
+	ssize_t				res;
+
+	res = parse_val_mask_pair(buf, len, &val, &mask);
+	if (res<0)
+		return res;
+
+	for (i=4; i<32 && likely(rc==0); ++i) {
+		if (((mask>>i) & 0x1)==0)
+			continue;
+
+		rc = ops->set(ops, 0x20 + i, (val>>i) & 0x1);
+		if (rc==0) {
+			mpriv->val &= ~(1u<<i);
+			mpriv->val |=  (val & (1u<<i));
+		}
+	}
+
+	if (rc<0)
+		return rc;
+
+	return res;
+}
+
+static struct device_attribute		max730x_inp_attributes[] = {
+	__ATTR(dir,    0644, max730x_sys_dir_show,    max730x_sys_dir_store),
+	__ATTR(pullup, 0644, max730x_sys_pullup_show, max730x_sys_pullup_store),
+	__ATTR(value,  0600, max730x_sys_value_show,  max730x_sys_value_store)
+};
+
+static void max730x_free(struct max730x_device *mdev)
+{
+	struct max730x_priv	*dev = to_max730x_priv(mdev);
+
+	xxx_device_remove_files(dev->dev, max730x_inp_attributes,
+				ARRAY_SIZE(max730x_inp_attributes));
+	input_unregister_device(dev->input_dev);
+	kfree(dev);
+}
+
+static void *max730x_get_drvdata(struct max730x_device *mdev)
+{
+	struct max730x_priv		*mpriv = to_max730x_priv(mdev);
+	return mpriv->priv;
+}
+
+static int max730x_update(struct max730x_device *mdev)
+{
+	struct max730x_priv * const	mpriv = to_max730x_priv(mdev);
+	struct max730x_op * const	ops   = mpriv->ops;
+
+	unsigned int			i;
+	uint8_t				cfg = 0;
+	uint8_t				val = 0;
+	int				rc  = 0;
+
+	for (i=4; i<32 && likely(rc==0); ++i) {
+		int		sft = (i%8);
+		val &= ~(1u << sft);
+		val |= ((mpriv->val   & (1u<<i)) ? 1u : 0u) << sft;
+
+		/* handle ports 4-7 in a special way */
+		if (!p47_cont() && i==7)
+			val >>= 4;
+
+		if ((i+1)%8==0)
+			rc = ops->set(ops, 0x40 + i/8 * 8, val);
+	}
+
+	for (i=4; i<32 && likely(rc==0); ++i) {
+		int		sft = (i%4) << 1;
+		cfg &= ~(3u << sft);
+		cfg |= ((((mpriv->dir    & (1u<<i)) ? 0 : 2) << sft) |
+			(((mpriv->pullup & (1u<<i)) ? 1 : 0) << sft));
+
+		if ((i+1)%4==0)
+			rc = ops->set(ops, 0x08 + i/4, cfg);
+	}
+
+	if (unlikely(rc<0))
+		dev_warn(mpriv->dev, "failed to set registers\n");
+
+	return rc;
+}
+
+static int max730x_reset(struct max730x_device *mdev)
+{
+	struct max730x_priv				*dev  = to_max730x_priv(mdev);
+	struct max730x_platform_data const * const	pdata = dev->dev->platform_data;
+	struct max730x_op * const			ops   = dev->ops;
+	int						rc;
+
+	if (pdata) {
+		dev->dir    = pdata->dir;
+		dev->pullup = pdata->pullup;
+		dev->val    = pdata->val;
+	} else {
+		dev->dir    = 0;
+		dev->pullup = 0;
+		dev->val    = 0;
+	}
+
+	rc = mdev->update(mdev);
+	if (rc<0) {
+		ops->set(ops, 0x04, 0x00);  /* shutdown */
+		return rc;
+	}
+
+	rc = ops->set(ops, 0x04, 0x01);	/* normal operation */
+	return rc;
+}
+
+struct max730x_device * __devinit
+max730x_create(struct device *dev, struct max730x_op *ops, int irq)
+{
+	struct max730x_priv		*mdev;
+	uint8_t				reg;
+	int				rc;
+
+	mdev = kzalloc(sizeof *dev, GFP_KERNEL);
+	if (!dev)
+		return ERR_PTR(-ENOMEM);
+
+	mdev->max730x.reset       = max730x_reset;
+	mdev->max730x.update      = max730x_update;
+	mdev->max730x.free        = max730x_free;
+	mdev->max730x.get_drvdata = max730x_get_drvdata;
+
+	mdev->ops = ops;
+	mdev->dev = dev;
+	mdev->irq = irq;
+
+	rc = mdev->ops->get(mdev->ops, 0, &reg);
+	if (rc==0 && (reg & (1<<6))!=0) {
+		dev_err(dev, "mismatch in configuration register: %02x\n", reg);
+		rc = -ENXIO;
+	}
+
+	if (rc)
+		goto err;
+
+	mdev->input_dev = input_allocate_device();
+	if (!mdev->input_dev) {
+		dev_err(dev, "failed to allocate input device\n");
+		goto err;
+	}
+
+	strlcpy(mdev->phys, dev->bus_id, sizeof(mdev->phys));
+	strlcat(mdev->phys, "/input0",   sizeof(mdev->phys));
+
+	mdev->input_dev->name        = "MAX730x GPIO Expander";
+	mdev->input_dev->dev.parent  = dev;
+	input_set_drvdata(mdev->input_dev, mdev);
+
+	mdev->input_dev->evbit[0] = BIT(EV_KEY);
+
+	rc = input_register_device(mdev->input_dev);
+	if (rc) {
+		dev_err(dev, "failed to register input device: %d\n", rc);
+		goto err;
+	}
+
+	dev_set_drvdata(dev, mdev);
+	rc = xxx_device_create_files(dev, max730x_inp_attributes,
+				     ARRAY_SIZE(max730x_inp_attributes));
+	if (rc) {
+		dev_err(dev, "failed to register sysfs entries: %d\n", rc);
+		goto err1;
+	}
+
+	return &mdev->max730x;
+
+err1:
+	input_unregister_device(mdev->input_dev);
+	mdev->input_dev = NULL;
+
+err:
+	if (mdev->input_dev)
+		input_free_device(mdev->input_dev);
+
+	kfree(mdev);
+	return ERR_PTR(rc);
+}
+
+MODULE_LICENSE("GPL");
diff -Naur linux-3.4.11/drivers/misc/max730x-lib/max730x-priv.h linux-HEAD/drivers/misc/max730x-lib/max730x-priv.h
--- linux-3.4.11/drivers/misc/max730x-lib/max730x-priv.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/max730x-lib/max730x-priv.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,37 @@
+/*	--*- c -*--
+ * Copyright (C) 2008 Enrico Scholz <enrico.scholz@informatik.tu-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_DRIVERS_MISC_MAX730X_LIB_MAX730X_PRIV_H
+#define H_DRIVERS_MISC_MAX730X_LIB_MAX730X_PRIV_H
+
+#include <linux/max730x.h>
+
+struct max730x_priv {
+	struct max730x_device	max730x;
+	struct max730x_op	*ops;
+	struct device		*dev;
+	int			irq;
+	struct input_dev	*input_dev;
+
+	uint32_t		dir;
+	uint32_t		pullup;
+	uint32_t		val;
+
+	char			phys[32];
+	void			*priv;
+};
+
+#endif	/* H_DRIVERS_MISC_MAX730X_LIB_MAX730X_PRIV_H */
diff -Naur linux-3.4.11/drivers/misc/tracebuffer/Makefile linux-HEAD/drivers/misc/tracebuffer/Makefile
--- linux-3.4.11/drivers/misc/tracebuffer/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/tracebuffer/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1 @@
+obj-m		+=  tracebuffer.o
diff -Naur linux-3.4.11/drivers/misc/tracebuffer/tracebuffer.c linux-HEAD/drivers/misc/tracebuffer/tracebuffer.c
--- linux-3.4.11/drivers/misc/tracebuffer/tracebuffer.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/misc/tracebuffer/tracebuffer.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,145 @@
+/*	--*- c -*--
+ * Copyright (C) 2009 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+static unsigned char	trace_buffer[256];
+
+static unsigned long decode_address(void const *buf, size_t len)
+{
+	uint8_t const	*v = buf;
+
+	if (len < 4)
+		return -1;
+
+	return (v[3] << 24) | (v[2] << 16) | (v[1] << 8) | (v[0] << 0);
+}
+
+static void print_tracebuffer(void const *buf, size_t len, uint32_t chkpts[2])
+{
+	uint8_t const	*ptr;
+	uint8_t const	*end_ptr = buf + len;
+	size_t		idx;
+	uint32_t const	*chkpt = &chkpts[0];
+
+	print_hex_dump(KERN_INFO, "trace_buffer: ", DUMP_PREFIX_OFFSET,
+		       16, 1, buf, len, false);
+
+	for (idx = 0, ptr = buf; ptr < end_ptr; ++ptr, ++idx) {
+		printk(KERN_INFO "%3d[+%2d]: %02x = ", idx, *ptr & 0x0f, *ptr);
+		if ((*ptr & 0x80) == 0)
+			printk("exception %d\n", (*ptr & 0x7f) >> 4);
+		else if (*ptr == 0xff)
+			printk("roll-over\n");
+		else if (*ptr & 0x20)
+			printk("???\n");
+		else {
+			if (*ptr & 0x40) {
+				if (chkpt)
+					printk("checkpointed [%08x] ", *chkpt);
+				else
+					printk("checkpointed [???] ");
+
+				if (chkpt && chkpt < chkpts + 2 - 1)
+					++chkpt;
+				else
+					chkpt = NULL;
+			}
+
+			if (*ptr & 0x10) {
+				printk("indirect branch %08lx\n",
+				       decode_address(ptr + 1, end_ptr - ptr - 1));
+				ptr += 4;
+			} else
+				printk("direct branch\n");
+		}
+	}
+}
+
+static int __init tracebuffer_init(void)
+{
+	uint32_t		new_dcsr;
+	uint32_t		dcsr;
+	uint32_t		chkpt[2];
+	size_t			i;
+	char const * const	MOE_REASON[] = {
+		[0] = "reset",
+		[1] = "I Breakpoint",
+		[2] = "D Breakpoint",
+		[3] = "BKPT",
+		[4] = "JTAG",
+		[5] = "Vector Trap",
+		[6] = "Trace Buffer full",
+		[7] = "rsrvd"
+	};
+
+
+
+	printk(KERN_INFO "trace-buffer -- %s %s", __DATE__, __TIME__);
+
+	asm volatile("mrc	p14, 0, %0, c10, c0, 0" : "=r"(dcsr));
+
+	new_dcsr  = dcsr;
+	new_dcsr &= ~(1 << 0);
+	new_dcsr |= (1u << 31);
+
+	asm volatile("mcr	p14, 0, %[dcsr],   c10, c0, 0\n"
+		     "mrc	p14, 0, %[chkpt0], c12, c0, 0\n"
+		     "mrc	p14, 0, %[chkpt1], c13, c0, 0\n"
+		     : [chkpt0] "=r" (chkpt[0]), [chkpt1] "=r" (chkpt[1])
+		     : [dcsr] "r" (new_dcsr));
+
+	for (i = 0; i < ARRAY_SIZE(trace_buffer); ++i) {
+		uint32_t	tmp;
+
+		asm volatile("mrc	p14, 0, %0, c11, c0, 0" : "=r" (tmp));
+
+		trace_buffer[ARRAY_SIZE(trace_buffer) - i - 1] = tmp & 0xff;
+	}
+
+	new_dcsr |= (1u << 31) | (1u << 0);
+	new_dcsr &= ~(1u << 1);		/* enable wrap-around mode */
+
+	asm volatile("mcr	p14, 0, %0, c10, c0, 0" : : "r"(new_dcsr));
+	add_taint(TAINT_MACHINE_CHECK);
+
+	printk(KERN_INFO
+	       "DCSR=%08x [%s%s%s%s%s%s%s%s%s%s%s%s%s%sMOE=%s], "
+	       "CHKPT=[%08x, %08x]\n",
+	       dcsr,
+	       dcsr & (1u<<31) ? "GE," : "",
+	       dcsr & (1u<<30) ? "H,"  : "",
+	       dcsr & (1u<<29) ? "B,"  : "",
+	       dcsr & (1u<<23) ? "TF," : "",
+	       dcsr & (1u<<22) ? "TI," : "",
+	       dcsr & (1u<<20) ? "TD," : "",
+	       dcsr & (1u<<19) ? "TA," : "",
+	       dcsr & (1u<<18) ? "TS," : "",
+	       dcsr & (1u<<17) ? "TU," : "",
+	       dcsr & (1u<<16) ? "TR," : "",
+	       dcsr & (1u<< 6) ? "TT," : "",
+	       dcsr & (1u<< 5) ? "SA," : "",
+	       dcsr & (1u<< 1) ? "M,"  : "",
+	       dcsr & (1u<< 0) ? "E,"  : "",
+	       MOE_REASON[(dcsr & (7 << 2)) >> 2],
+	       chkpt[0], chkpt[1]);
+
+	print_tracebuffer(trace_buffer, sizeof trace_buffer, chkpt);
+
+	return -EAGAIN;
+}
+
+module_init(tracebuffer_init);
+MODULE_LICENSE("GPL");
diff -Naur linux-3.4.11/drivers/mmc/core/debugfs.c linux-HEAD/drivers/mmc/core/debugfs.c
--- linux-3.4.11/drivers/mmc/core/debugfs.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/mmc/core/debugfs.c	2015-11-18 09:04:24.000000000 +0000
@@ -159,6 +159,21 @@
 	.release	= single_release,
 };
 
+static int mmc_rescan_open(struct inode *inode, struct file *file)
+{
+	struct mmc_host	*host  = inode->i_private;
+	mmc_detect_change(host, msecs_to_jiffies(10));
+	printk(KERN_INFO "%s: rescan triggered\n", mmc_hostname(host));
+	return -EBUSY;
+}
+
+static const struct file_operations mmc_rescan_fops = {
+	.open		= mmc_rescan_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
 static int mmc_clock_opt_get(void *data, u64 *val)
 {
 	struct mmc_host *host = data;
@@ -201,7 +216,8 @@
 
 	host->debugfs_root = root;
 
-	if (!debugfs_create_file("ios", S_IRUSR, root, host, &mmc_ios_fops))
+	if (!debugfs_create_file("ios", S_IRUSR, root, host, &mmc_ios_fops) ||
+	    !debugfs_create_file("rescan", S_IWUSR, root, host, &mmc_rescan_fops))
 		goto err_node;
 
 	if (!debugfs_create_file("clock", S_IRUSR | S_IWUSR, root, host,
diff -Naur linux-3.4.11/drivers/mmc/host/mxs-mmc.c linux-HEAD/drivers/mmc/host/mxs-mmc.c
--- linux-3.4.11/drivers/mmc/host/mxs-mmc.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/mmc/host/mxs-mmc.c	2015-11-18 09:04:24.000000000 +0000
@@ -157,6 +157,9 @@
 	enum dma_transfer_direction	slave_dirn;
 	u32				ssp_pio_words[SSP_PIO_NUM];
 
+	struct regulator		*vddio;
+	int				pwr_enabled;
+
 	unsigned int			version;
 	unsigned char			bus_width;
 	spinlock_t			lock;
@@ -182,8 +185,8 @@
 {
 	struct mxs_mmc_host *host = mmc_priv(mmc);
 
-	return !(readl(host->base + HW_SSP_STATUS) &
-		 BM_SSP_STATUS_CARD_DETECT);
+	return (readl(host->base + HW_SSP_STATUS) &
+		BM_SSP_STATUS_CARD_DETECT);
 }
 
 static void mxs_mmc_reset(struct mxs_mmc_host *host)
@@ -610,6 +613,26 @@
 		__func__, clock_divide, clock_rate, ssp_clk, ssp_sck, rate);
 }
 
+static void mxs_mmc_power(struct mxs_mmc_host *host, bool pwr_on)
+{
+	int		rc;
+
+	if ((pwr_on && host->pwr_enabled) ||
+	    (!pwr_on && !host->pwr_enabled))
+		return;			/* noop */
+
+	if (pwr_on)
+		rc = regulator_enable(host->vddio);
+	else
+		rc = regulator_disable(host->vddio);
+
+	if (rc < 0)
+		dev_warn(mmc_dev(host->mmc), "failed to %s power: %d\n",
+			 pwr_on ? "enable" : "disable", rc);
+	else
+		host->pwr_enabled = pwr_on;
+}
+
 static void mxs_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
 	struct mxs_mmc_host *host = mmc_priv(mmc);
@@ -621,8 +644,21 @@
 	else
 		host->bus_width = 0;
 
+	if (host->vddio != NULL) {
+		switch (ios->power_mode) {
+		case MMC_POWER_UP:
+		case MMC_POWER_ON:
+			mxs_mmc_power(host, true);
+			break;
+		case MMC_POWER_OFF:
+			mxs_mmc_power(host, false);
+			break;
+		}
+	}
+
 	if (ios->clock)
 		mxs_mmc_set_clk_rate(host, ios->clock);
+
 }
 
 static void mxs_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)
@@ -703,12 +739,28 @@
 	}
 
 	host = mmc_priv(mmc);
+
+	host->vddio = regulator_get(&pdev->dev, "VDDIO-SD");
+	if (host->vddio == NULL ||
+	    (IS_ERR(host->vddio) && PTR_ERR(host->vddio) == -ENODEV))
+		host->vddio = NULL;
+	else if (IS_ERR(host->vddio)) {
+		ret = PTR_ERR(host->vddio);
+		host->vddio = NULL;
+		dev_err(&pdev->dev, "failed to get VDDIO regulator: %d\n",
+			ret);
+		goto out_mmc_free;
+	} else
+		dev_info(&pdev->dev, "using regulator to control VDDIO-SD\n");
+
 	host->base = ioremap(r->start, resource_size(r));
 	if (!host->base) {
 		ret = -ENOMEM;
 		goto out_mmc_free;
 	}
 
+
+
 	/* only major verion does matter */
 	host->version = readl(host->base + HW_SSP_VERSION) >>
 			BP_SSP_VERSION_MAJOR;
@@ -735,6 +787,7 @@
 	if (!host->dmach) {
 		dev_err(mmc_dev(host->mmc),
 			"%s: failed to request dma\n", __func__);
+		ret = -ENOENT;
 		goto out_clk_put;
 	}
 
@@ -788,6 +841,7 @@
 out_iounmap:
 	iounmap(host->base);
 out_mmc_free:
+	regulator_put(host->vddio);
 	mmc_free_host(mmc);
 out_release_mem:
 	release_mem_region(iores->start, resource_size(iores));
@@ -812,8 +866,11 @@
 	clk_disable_unprepare(host->clk);
 	clk_put(host->clk);
 
+	mxs_mmc_power(host, false);
+
 	iounmap(host->base);
 
+	regulator_put(host->vddio);
 	mmc_free_host(mmc);
 
 	release_mem_region(res->start, resource_size(res));
@@ -871,3 +928,4 @@
 MODULE_DESCRIPTION("FREESCALE MXS MMC peripheral");
 MODULE_AUTHOR("Freescale Semiconductor");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:mxs-mmc");
diff -Naur linux-3.4.11/drivers/mmc/host/sdhci.c linux-HEAD/drivers/mmc/host/sdhci.c
--- linux-3.4.11/drivers/mmc/host/sdhci.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/mmc/host/sdhci.c	2015-11-18 09:04:24.000000000 +0000
@@ -74,7 +74,7 @@
 
 	pr_debug(DRIVER_NAME ": Sys addr: 0x%08x | Version:  0x%08x\n",
 		sdhci_readl(host, SDHCI_DMA_ADDRESS),
-		sdhci_readw(host, SDHCI_HOST_VERSION));
+		sdhci_readl(host, SDHCI_HOST_VERSION - 2) >> 16);
 	pr_debug(DRIVER_NAME ": Blk size: 0x%08x | Blk cnt:  0x%08x\n",
 		sdhci_readw(host, SDHCI_BLOCK_SIZE),
 		sdhci_readw(host, SDHCI_BLOCK_COUNT));
@@ -987,6 +987,14 @@
 		mdelay(1);
 	}
 
+	/*
+	 * we cannot talk to controller for 8 bus cycles according to sdio spec
+	 * at lowest speed this is 100,000 HZ per cycle or 800,000 cycles
+	 * which is quite a LONG TIME on a fast cpu -- so delay if needed
+	 */
+	if (host->ops->platform_specific_delay)
+		host->ops->platform_specific_delay(host);
+
 	mod_timer(&host->timer, jiffies + 10 * HZ);
 
 	host->cmd = cmd;
@@ -1356,6 +1364,12 @@
 	if (host->ops->platform_send_init_74_clocks)
 		host->ops->platform_send_init_74_clocks(host, ios->power_mode);
 
+#ifdef CONFIG_MMC_CLKGATE
+	if ((mmc->caps & MMC_CAP_HW_CLOCK_GATING)
+		&& host->ops->platform_hw_clk_gate)
+			host->ops->platform_hw_clk_gate(host);
+#endif
+
 	/*
 	 * If your platform has 8-bit width support but is not a v3 controller,
 	 * or if it requires special setup code, you should implement that in
@@ -2608,7 +2622,7 @@
 
 	sdhci_reset(host, SDHCI_RESET_ALL);
 
-	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);
+	host->version = sdhci_readl(host, SDHCI_HOST_VERSION - 2) >> 16;
 	host->version = (host->version & SDHCI_SPEC_VER_MASK)
 				>> SDHCI_SPEC_VER_SHIFT;
 	if (host->version > SDHCI_SPEC_300) {
@@ -2724,7 +2738,14 @@
 	 * Set host parameters.
 	 */
 	mmc->ops = &sdhci_ops;
-	mmc->f_max = host->max_clk;
+
+	if (host->ops->get_f_max_clock) {
+		mmc->f_max = host->ops->get_f_max_clock(host);
+		if (mmc->f_max > host->max_clk)
+			mmc->f_max = host->max_clk;
+	} else
+		mmc->f_max = host->max_clk;
+
 	if (host->ops->get_min_clock)
 		mmc->f_min = host->ops->get_min_clock(host);
 	else if (host->version >= SDHCI_SPEC_300) {
diff -Naur linux-3.4.11/drivers/mmc/host/sdhci.h linux-HEAD/drivers/mmc/host/sdhci.h
--- linux-3.4.11/drivers/mmc/host/sdhci.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/mmc/host/sdhci.h	2015-11-18 09:04:24.000000000 +0000
@@ -275,6 +275,9 @@
 	void	(*platform_reset_exit)(struct sdhci_host *host, u8 mask);
 	int	(*set_uhs_signaling)(struct sdhci_host *host, unsigned int uhs);
 	void	(*hw_reset)(struct sdhci_host *host);
+	unsigned int	(*get_f_max_clock)(struct sdhci_host *host);
+	void	(*platform_specific_delay)(struct sdhci_host *host);
+	void	(*platform_hw_clk_gate)(struct sdhci_host *host);
 	void	(*platform_suspend)(struct sdhci_host *host);
 	void	(*platform_resume)(struct sdhci_host *host);
 };
diff -Naur linux-3.4.11/drivers/mmc/host/sdhci-pxav2.c linux-HEAD/drivers/mmc/host/sdhci-pxav2.c
--- linux-3.4.11/drivers/mmc/host/sdhci-pxav2.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/mmc/host/sdhci-pxav2.c	2015-11-18 09:04:24.000000000 +0000
@@ -22,6 +22,7 @@
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/module.h>
+#include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/gpio.h>
 #include <linux/mmc/card.h>
@@ -72,6 +73,7 @@
 			writew(tmp, host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);
 		}
 
+#ifdef CONFIG_MMC_CLKGATE
 		if (pdata && (pdata->flags & PXA_FLAG_ENABLE_CLOCK_GATING)) {
 			tmp = readw(host->ioaddr + SD_FIFO_PARAM);
 			tmp &= ~CLK_GATE_SETTING_BITS;
@@ -82,6 +84,12 @@
 			tmp |= CLK_GATE_SETTING_BITS;
 			writew(tmp, host->ioaddr + SD_FIFO_PARAM);
 		}
+#endif
+
+		tmp = readw(host->ioaddr + SD_FIFO_PARAM);
+		/* Errata 5.37 */
+		tmp |= DIS_PAD_SD_CLK_GATE;
+		writew(tmp, host->ioaddr + SD_FIFO_PARAM);
 	}
 }
 
@@ -108,6 +116,67 @@
 	return 0;
 }
 
+/*
+ * we cannot talk to controller for 8 bus cycles according to sdio spec
+ * at lowest speed this is 100,000 HZ per cycle or 800,000 cycles
+ * which is quite a LONG TIME on a fast cpu -- so delay if needed
+ */
+static void pxav2_platform_specific_delay(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_pxa *pxa = pltfm_host->priv;
+
+	mdelay(pxa->delay_in_ms);
+	udelay(pxa->delay_in_us);
+	ndelay(pxa->delay_in_ns);
+}
+
+static void pxav2_set_clock(struct sdhci_host *host, unsigned int clock)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_pxa *pxa = pltfm_host->priv;
+
+	if (clock != 0) {
+		pxa->delay_in_ns = (1000000000/clock);
+
+		/* need to delay 12 clocks for 8787/8786 */
+		/* need to delay 8 clocks for controller -- so just use 12 */
+
+		pxa->delay_in_ns = pxa->delay_in_ns * 12;
+
+		pxa->delay_in_ms = pxa->delay_in_ns / 1000000;
+		pxa->delay_in_ns = pxa->delay_in_ns % 1000000;
+		pxa->delay_in_us = pxa->delay_in_ns / 1000;
+		pxa->delay_in_ns = pxa->delay_in_ns % 1000;
+	} else {
+		pxa->delay_in_ns = 0;
+		pxa->delay_in_us = 0;
+		pxa->delay_in_ms = 0;
+	}
+}
+
+static void pxav2_gen_init_74_clocks(struct sdhci_host *host, u8 power_mode)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_pxa *pxa = pltfm_host->priv;
+	struct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));
+	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
+
+	if (pxa->power_mode == MMC_POWER_UP && power_mode == MMC_POWER_ON) {
+		if (pdata && pdata->clk_74)
+			pdata->clk_74();
+	}
+
+	pxa->power_mode = power_mode;
+}
+
+static irqreturn_t pxav2_card_detect_irq(int irq, void *host_)
+{
+	struct sdhci_host	*host = host_;
+	mmc_detect_change(host->mmc, msecs_to_jiffies(200));
+	return IRQ_HANDLED;
+}
+
 static u32 pxav2_get_max_clock(struct sdhci_host *host)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
@@ -115,10 +184,25 @@
 	return clk_get_rate(pltfm_host->clk);
 }
 
+static u32 pxav2_get_f_max_clock(struct sdhci_host *host)
+{
+	struct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));
+	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
+
+	if (pdata->max_speed)
+		return pdata->max_speed;
+	else
+		return pxav2_get_max_clock(host);
+}
+
 static struct sdhci_ops pxav2_sdhci_ops = {
 	.get_max_clock = pxav2_get_max_clock,
+	.get_f_max_clock = pxav2_get_f_max_clock,
 	.platform_reset_exit = pxav2_set_private_registers,
 	.platform_8bit_width = pxav2_mmc_set_width,
+	.set_clock = pxav2_set_clock,
+	.platform_specific_delay = pxav2_platform_specific_delay,
+	.platform_send_init_74_clocks = pxav2_gen_init_74_clocks,
 };
 
 static int __devinit sdhci_pxav2_probe(struct platform_device *pdev)
@@ -150,11 +234,16 @@
 		goto err_clk_get;
 	}
 	pltfm_host->clk = clk;
-	clk_enable(clk);
+	clk_prepare_enable(clk);
 
 	host->quirks = SDHCI_QUIRK_BROKEN_ADMA
+		| SDHCI_QUIRK_32BIT_DMA_ADDR
+		| SDHCI_QUIRK_32BIT_DMA_SIZE
+		| SDHCI_QUIRK_NO_BUSY_IRQ
 		| SDHCI_QUIRK_BROKEN_TIMEOUT_VAL
-		| SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN;
+		| SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN
+		| SDHCI_QUIRK_NO_HISPD_BIT /* Errata 5.61 */
+		;
 
 	if (pdata) {
 		if (pdata->flags & PXA_FLAG_CARD_PERMANENT) {
@@ -173,6 +262,9 @@
 			host->mmc->caps |= pdata->host_caps;
 		if (pdata->pm_caps)
 			host->mmc->pm_caps |= pdata->pm_caps;
+
+		if (pdata->init)
+			pdata->init(&pdev->dev, pxav2_card_detect_irq, host);
 	}
 
 	host->ops = &pxav2_sdhci_ops;
@@ -188,7 +280,7 @@
 	return 0;
 
 err_add_host:
-	clk_disable(clk);
+	clk_disable_unprepare(clk);
 	clk_put(clk);
 err_clk_get:
 	sdhci_pltfm_free(pdev);
@@ -198,13 +290,19 @@
 
 static int __devexit sdhci_pxav2_remove(struct platform_device *pdev)
 {
+	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
 	struct sdhci_host *host = platform_get_drvdata(pdev);
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_pxa *pxa = pltfm_host->priv;
 
 	sdhci_remove_host(host, 1);
 
-	clk_disable(pltfm_host->clk);
+	if (pdata) {
+		if (pdata->remove)
+			pdata->remove(&pdev->dev, host);
+	}
+
+	clk_disable_unprepare(pltfm_host->clk);
 	clk_put(pltfm_host->clk);
 	sdhci_pltfm_free(pdev);
 	kfree(pxa);
diff -Naur linux-3.4.11/drivers/mmc/host/sdhci-pxav3.c linux-HEAD/drivers/mmc/host/sdhci-pxav3.c
--- linux-3.4.11/drivers/mmc/host/sdhci-pxav3.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/mmc/host/sdhci-pxav3.c	2015-11-18 09:04:24.000000000 +0000
@@ -219,6 +219,9 @@
 			host->mmc->caps |= pdata->host_caps;
 		if (pdata->pm_caps)
 			host->mmc->pm_caps |= pdata->pm_caps;
+
+		if (pdata->init)
+			pdata->init(&pdev->dev, NULL, NULL);
 	}
 
 	host->ops = &pxav3_sdhci_ops;
@@ -244,12 +247,18 @@
 
 static int __devexit sdhci_pxav3_remove(struct platform_device *pdev)
 {
+	struct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;
 	struct sdhci_host *host = platform_get_drvdata(pdev);
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct sdhci_pxa *pxa = pltfm_host->priv;
 
 	sdhci_remove_host(host, 1);
 
+	if (pdata) {
+		if (pdata->remove)
+			pdata->remove(&pdev->dev, NULL);
+	}
+
 	clk_disable(pltfm_host->clk);
 	clk_put(pltfm_host->clk);
 	sdhci_pltfm_free(pdev);
diff -Naur linux-3.4.11/drivers/mtd/nand/gpmi-nand/gpmi-nand.c linux-HEAD/drivers/mtd/nand/gpmi-nand/gpmi-nand.c
--- linux-3.4.11/drivers/mtd/nand/gpmi-nand/gpmi-nand.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/mtd/nand/gpmi-nand/gpmi-nand.c	2015-11-18 09:04:24.000000000 +0000
@@ -20,6 +20,7 @@
  */
 #include <linux/clk.h>
 #include <linux/slab.h>
+#include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/mtd/gpmi-nand.h>
@@ -95,7 +96,7 @@
 	 * bytes now. But it can't be too large, because we have to save
 	 * enough space for BCH.
 	 */
-	geo->metadata_size = 10;
+	geo->metadata_size = 12;
 
 	/* The default for the length of Galois Field. */
 	geo->gf_len = 13;
@@ -531,10 +532,10 @@
 	 * (although, with less-than-optimal performance).
 	 */
 	struct nand_timing  safe_timing = {
-		.data_setup_in_ns        = 80,
-		.data_hold_in_ns         = 60,
-		.address_setup_in_ns     = 25,
-		.gpmi_sample_delay_in_ns =  6,
+		.data_setup_in_ns        = 12,
+		.data_hold_in_ns         =  5,
+		.address_setup_in_ns     = 15,
+		.gpmi_sample_delay_in_ns =  3,
 		.tREA_in_ns              = -1,
 		.tRLOH_in_ns             = -1,
 		.tRHOH_in_ns             = -1,
diff -Naur linux-3.4.11/drivers/mtd/nand/pxa3xx_nand.c linux-HEAD/drivers/mtd/nand/pxa3xx_nand.c
--- linux-3.4.11/drivers/mtd/nand/pxa3xx_nand.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/mtd/nand/pxa3xx_nand.c	2015-11-18 09:04:24.000000000 +0000
@@ -1315,5 +1315,6 @@
 
 module_platform_driver(pxa3xx_nand_driver);
 
+MODULE_ALIAS("platform:pxa3xx-nand");
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("PXA3xx NAND controller driver");
diff -Naur linux-3.4.11/drivers/net/can/sja1000/Kconfig linux-HEAD/drivers/net/can/sja1000/Kconfig
--- linux-3.4.11/drivers/net/can/sja1000/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/net/can/sja1000/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -19,6 +19,23 @@
 	  boards from Phytec (http://www.phytec.de) like the PCM027,
 	  PCM038.
 
+config CAN_SJA1000_ADDRESSING_DIRECT
+        bool "Direct Addressing of SJA1000"
+        depends on CAN_SJA1000_PLATFORM
+	default y
+	---help---
+	  Enable direct addressing of SJA1000 chip.  This means, data
+	  is written directly to a register
+
+config CAN_SJA1000_ADDRESSING_INDIRECT
+        bool "Indirect Addressing of SJA1000"
+        depends on CAN_SJA1000_PLATFORM
+	default y
+	---help---
+	  Enable indirect addressing of SJA1000 chip.  This means,
+	  register address will be written first to a special memory
+	  address and then the data to another fixed memory address.
+
 config CAN_SJA1000_OF_PLATFORM
 	tristate "Generic OF Platform Bus based SJA1000 driver"
 	depends on PPC_OF
diff -Naur linux-3.4.11/drivers/net/can/sja1000/sja1000.h linux-HEAD/drivers/net/can/sja1000/sja1000.h
--- linux-3.4.11/drivers/net/can/sja1000/sja1000.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/net/can/sja1000/sja1000.h	2015-11-18 09:04:24.000000000 +0000
@@ -45,6 +45,7 @@
 #ifndef SJA1000_DEV_H
 #define SJA1000_DEV_H
 
+#include <linux/spinlock_types.h>
 #include <linux/irqreturn.h>
 #include <linux/can/dev.h>
 #include <linux/can/platform/sja1000.h>
@@ -156,8 +157,8 @@
 	struct sk_buff *echo_skb;
 
 	/* the lower-layer is responsible for appropriate locking */
-	u8 (*read_reg) (const struct sja1000_priv *priv, int reg);
-	void (*write_reg) (const struct sja1000_priv *priv, int reg, u8 val);
+	u8 (*read_reg) (struct sja1000_priv *priv, int reg);
+	void (*write_reg) (struct sja1000_priv *priv, int reg, u8 val);
 	void (*pre_irq) (const struct sja1000_priv *priv);
 	void (*post_irq) (const struct sja1000_priv *priv);
 
@@ -171,6 +172,12 @@
 	u16 flags;		/* custom mode flags */
 	u8 ocr;			/* output control register */
 	u8 cdr;			/* clock divider register */
+
+#ifdef CONFIG_CAN_SJA1000_ADDRESSING_INDIRECT
+	spinlock_t		addr_lock;
+	unsigned long		offset_data;
+	unsigned long		offset_addr;
+#endif
 };
 
 struct net_device *alloc_sja1000dev(int sizeof_priv);
diff -Naur linux-3.4.11/drivers/net/can/sja1000/sja1000_platform.c linux-HEAD/drivers/net/can/sja1000/sja1000_platform.c
--- linux-3.4.11/drivers/net/can/sja1000/sja1000_platform.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/net/can/sja1000/sja1000_platform.c	2015-11-18 09:04:24.000000000 +0000
@@ -24,6 +24,7 @@
 #include <linux/pci.h>
 #include <linux/platform_device.h>
 #include <linux/irq.h>
+#include <linux/spinlock.h>
 #include <linux/can/dev.h>
 #include <linux/can/platform/sja1000.h>
 #include <linux/io.h>
@@ -36,37 +37,82 @@
 MODULE_DESCRIPTION("Socket-CAN driver for SJA1000 on the platform bus");
 MODULE_LICENSE("GPL v2");
 
-static u8 sp_read_reg8(const struct sja1000_priv *priv, int reg)
+MODULE_ALIAS("platform:sja1000_platform");
+
+/* some macros which are used to optimize away unused code */
+#ifdef CONFIG_CAN_SJA1000_ADDRESSING_INDIRECT
+#  define sp_enable_indirect()	(1)
+#else
+#  define sp_enable_indirect()	(0)
+#endif
+
+#ifdef CONFIG_CAN_SJA1000_ADDRESSING_DIRECT
+#  define sp_enable_direct()	(1)
+#else
+#  define sp_enable_direct()	(0)
+#endif
+
+static u8 sp_read_reg8_indirect(struct sja1000_priv *priv, int reg)
+{
+#ifdef CONFIG_CAN_SJA1000_ADDRESSING_INDIRECT
+	unsigned long		flags;
+	u8			ret;
+
+	spin_lock_irqsave(&priv->addr_lock, flags);
+	iowrite8(reg, priv->reg_base + priv->offset_addr);
+	ret = ioread8(priv->reg_base + priv->offset_data);
+	spin_unlock_irqrestore(&priv->addr_lock, flags);
+
+	return ret;
+#else
+	BUG();
+#endif
+}
+
+static void sp_write_reg8_indirect(struct sja1000_priv *priv,
+				   int reg, u8 val)
+{
+#ifdef CONFIG_CAN_SJA1000_ADDRESSING_INDIRECT
+	unsigned long		flags;
+
+	spin_lock_irqsave(&priv->addr_lock, flags);
+	iowrite8(reg, priv->reg_base + priv->offset_addr);
+	iowrite8(val, priv->reg_base + priv->offset_data);
+	spin_unlock_irqrestore(&priv->addr_lock, flags);
+#endif
+}
+
+static u8 sp_read_reg8(struct sja1000_priv *priv, int reg)
 {
 	return ioread8(priv->reg_base + reg);
 }
 
-static void sp_write_reg8(const struct sja1000_priv *priv, int reg, u8 val)
+static void sp_write_reg8(struct sja1000_priv *priv, int reg, u8 val)
 {
 	iowrite8(val, priv->reg_base + reg);
 }
 
-static u8 sp_read_reg16(const struct sja1000_priv *priv, int reg)
+static u8 sp_read_reg16(struct sja1000_priv *priv, int reg)
 {
 	return ioread8(priv->reg_base + reg * 2);
 }
 
-static void sp_write_reg16(const struct sja1000_priv *priv, int reg, u8 val)
+static void sp_write_reg16(struct sja1000_priv *priv, int reg, u8 val)
 {
 	iowrite8(val, priv->reg_base + reg * 2);
 }
 
-static u8 sp_read_reg32(const struct sja1000_priv *priv, int reg)
+static u8 sp_read_reg32(struct sja1000_priv *priv, int reg)
 {
 	return ioread8(priv->reg_base + reg * 4);
 }
 
-static void sp_write_reg32(const struct sja1000_priv *priv, int reg, u8 val)
+static void sp_write_reg32(struct sja1000_priv *priv, int reg, u8 val)
 {
 	iowrite8(val, priv->reg_base + reg * 4);
 }
 
-static int sp_probe(struct platform_device *pdev)
+static int __devinit sp_probe(struct platform_device *pdev)
 {
 	int err;
 	void __iomem *addr;
@@ -74,6 +120,7 @@
 	struct sja1000_priv *priv;
 	struct resource *res_mem, *res_irq;
 	struct sja1000_platform_data *pdata;
+	int is_direct;
 
 	pdata = pdev->dev.platform_data;
 	if (!pdata) {
@@ -89,6 +136,26 @@
 		goto exit;
 	}
 
+	if (pdata->offset_data >= resource_size(res_mem) ||
+	    pdata->offset_addr >= resource_size(res_mem)) {
+		err = -EINVAL;
+		goto exit;
+	}
+
+	is_direct = (pdata->offset_data==0 && pdata->offset_addr==0);
+
+	if (!sp_enable_indirect() && !is_direct) {
+		/* indirect addressing requested but not enabled */
+		err = -EINVAL;
+		goto exit;
+	}
+
+	if (!sp_enable_direct() && is_direct) {
+		/* direct addressing requested but not enabled */
+		err = -EINVAL;
+		goto exit;
+	}
+
 	if (!request_mem_region(res_mem->start, resource_size(res_mem),
 				DRV_NAME)) {
 		err = -EBUSY;
@@ -116,6 +183,28 @@
 	priv->ocr = pdata->ocr;
 	priv->cdr = pdata->cdr;
 
+#ifdef CONFIG_CAN_SJA1000_ADDRESSING_INDIRECT
+	priv->offset_data = pdata->offset_data;
+	priv->offset_addr = pdata->offset_addr;
+	spin_lock_init(&priv->addr_lock);
+#endif
+
+	if (sp_enable_indirect() && !is_direct) {
+		switch (res_mem->flags & IORESOURCE_MEM_TYPE_MASK) {
+		case IORESOURCE_MEM_32BIT:
+		case IORESOURCE_MEM_16BIT:
+			/* TODO: implement me! */
+			WARN_ON(1);
+			err = -EINVAL;
+			goto exit_free;
+
+		case IORESOURCE_MEM_8BIT:
+		default:
+			priv->read_reg  = sp_read_reg8_indirect;
+			priv->write_reg = sp_write_reg8_indirect;
+			break;
+		}
+	} else {
 	switch (res_mem->flags & IORESOURCE_MEM_TYPE_MASK) {
 	case IORESOURCE_MEM_32BIT:
 		priv->read_reg = sp_read_reg32;
@@ -131,6 +220,7 @@
 		priv->write_reg = sp_write_reg8;
 		break;
 	}
+	}
 
 	dev_set_drvdata(&pdev->dev, dev);
 	SET_NETDEV_DEV(dev, &pdev->dev);
@@ -156,7 +246,7 @@
 	return err;
 }
 
-static int sp_remove(struct platform_device *pdev)
+static int __devexit sp_remove(struct platform_device *pdev)
 {
 	struct net_device *dev = dev_get_drvdata(&pdev->dev);
 	struct sja1000_priv *priv = netdev_priv(dev);
@@ -178,7 +268,7 @@
 
 static struct platform_driver sp_driver = {
 	.probe = sp_probe,
-	.remove = sp_remove,
+	.remove = __devexit_p(sp_remove),
 	.driver = {
 		.name = DRV_NAME,
 		.owner = THIS_MODULE,
diff -Naur linux-3.4.11/drivers/net/ethernet/davicom/dm9000.c linux-HEAD/drivers/net/ethernet/davicom/dm9000.c
--- linux-3.4.11/drivers/net/ethernet/davicom/dm9000.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/net/ethernet/davicom/dm9000.c	2015-11-18 09:04:24.000000000 +0000
@@ -1581,6 +1581,10 @@
 			ndev->dev_addr[i] = ior(db, i+DM9000_PAR);
 	}
 
+	if (pdata && pdata->fill_ether_addr &&
+	    !is_valid_ether_addr(ndev->dev_addr))
+		pdata->fill_ether_addr(ndev->dev_addr);
+
 	if (!is_valid_ether_addr(ndev->dev_addr)) {
 		dev_warn(db->dev, "%s: Invalid ethernet MAC address. Please "
 			 "set using ifconfig\n", ndev->name);
diff -Naur linux-3.4.11/drivers/net/ethernet/freescale/fec.c linux-HEAD/drivers/net/ethernet/freescale/fec.c
--- linux-3.4.11/drivers/net/ethernet/freescale/fec.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/net/ethernet/freescale/fec.c	2015-11-18 09:04:24.000000000 +0000
@@ -1026,6 +1026,7 @@
 	struct fec_enet_private *fep = netdev_priv(ndev);
 	const struct platform_device_id *id_entry =
 				platform_get_device_id(fep->pdev);
+	struct fec_platform_data *pdata = pdev->dev.platform_data;
 	int err = -ENXIO, i;
 
 	/*
@@ -1094,6 +1095,10 @@
 	for (i = 0; i < PHY_MAX_ADDR; i++)
 		fep->mii_bus->irq[i] = PHY_POLL;
 
+	/* TODO: allow irq 0 */
+	if (pdata && pdata->phy_irq && pdata->phy_addr < PHY_MAX_ADDR)
+		fep->mii_bus->irq[pdata->phy_addr] = pdata->phy_irq;
+
 	if (mdiobus_register(fep->mii_bus))
 		goto err_out_free_mdio_irq;
 
@@ -1523,13 +1528,7 @@
 	return -ENODEV;
 }
 
-static inline void fec_reset_phy(struct platform_device *pdev)
-{
-	/*
-	 * In case of platform probe, the reset has been done
-	 * by machine code.
-	 */
-}
+extern void fec_reset_phy(struct platform_device *pdev);
 #endif /* CONFIG_OF */
 
 static int __devinit
diff -Naur linux-3.4.11/drivers/net/ethernet/marvell/pxa168_eth.c linux-HEAD/drivers/net/ethernet/marvell/pxa168_eth.c
--- linux-3.4.11/drivers/net/ethernet/marvell/pxa168_eth.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/net/ethernet/marvell/pxa168_eth.c	2015-11-18 09:04:24.000000000 +0000
@@ -167,8 +167,9 @@
 #define LINK_UP			(1 << 3)
 
 /* Bit definitions for work to be done */
-#define WORK_LINK		(1 << 0)
-#define WORK_TX_DONE		(1 << 1)
+enum {
+	WORK_LINK,
+};
 
 /*
  * Misc definitions.
@@ -216,7 +217,7 @@
 
 	struct net_device *dev;
 	struct napi_struct napi;
-	u8 work_todo;
+	unsigned long work_todo;
 	int skb_size;
 
 	/* Size of Tx Ring per queue */
@@ -722,7 +723,6 @@
 
 	netif_tx_lock(dev);
 
-	pep->work_todo &= ~WORK_TX_DONE;
 	while (pep->tx_desc_count > 0) {
 		tx_index = pep->tx_used_desc_q;
 		desc = &pep->p_tx_desc_area[tx_index];
@@ -866,14 +866,12 @@
 		return IRQ_NONE;
 
 	wrl(pep, INT_CAUSE, ~icr);
-	if (icr & (ICR_TXBUF_H | ICR_TXBUF_L)) {
-		pep->work_todo |= WORK_TX_DONE;
+	if (icr & (ICR_TXBUF_H | ICR_TXBUF_L))
 		ret = 1;
-	}
 	if (icr & ICR_RXBUF)
 		ret = 1;
 	if (icr & ICR_MII_CH) {
-		pep->work_todo |= WORK_LINK;
+		set_bit(WORK_LINK, &pep->work_todo);
 		ret = 1;
 	}
 	return ret;
@@ -918,7 +916,7 @@
 	if (unlikely(!pxa168_eth_collect_events(pep, dev)))
 		return IRQ_NONE;
 	/* Disable interrupts */
-	wrl(pep, INT_MASK, 0);
+	wrl(pep, INT_MASK, ICR_MII_CH);
 	napi_schedule(&pep->napi);
 	return IRQ_HANDLED;
 }
@@ -1228,10 +1226,9 @@
 	struct net_device *dev = pep->dev;
 	int work_done = 0;
 
-	if (unlikely(pep->work_todo & WORK_LINK)) {
-		pep->work_todo &= ~(WORK_LINK);
+	if (unlikely(test_and_clear_bit(WORK_LINK, &pep->work_todo)))
 		handle_link_event(pep);
-	}
+
 	/*
 	 * We call txq_reclaim every time since in NAPI interupts are disabled
 	 * and due to this we miss the TX_DONE interrupt,which is not updated in
diff -Naur linux-3.4.11/drivers/net/ethernet/smsc/smc911x.c linux-HEAD/drivers/net/ethernet/smsc/smc911x.c
--- linux-3.4.11/drivers/net/ethernet/smsc/smc911x.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/net/ethernet/smsc/smc911x.c	2015-11-18 09:04:24.000000000 +0000
@@ -1800,13 +1800,14 @@
  * o  actually GRAB the irq.
  * o  GRAB the region
  */
-static int __devinit smc911x_probe(struct net_device *dev)
+static int __devinit smc911x_probe(struct net_device *dev,
+				   struct smc91x_platdata *pd,
+				   unsigned long irq_flags)
 {
 	struct smc911x_local *lp = netdev_priv(dev);
 	int i, retval;
 	unsigned int val, chip_id, revision;
 	const char *version_string;
-	unsigned long irq_flags;
 
 	DBG(SMC_DEBUG_FUNC, "%s: --> %s\n", dev->name, __func__);
 
@@ -1910,6 +1911,13 @@
 	/* Get the MAC address */
 	SMC_GET_MAC_ADDR(lp, dev->dev_addr);
 
+	if (pd && pd->fill_ether_addr &&
+	    !is_valid_ether_addr(dev->dev_addr)) {
+		printk(KERN_INFO "%s: no mac configured; falling back to platform setup\n",
+		       dev->name);
+		pd->fill_ether_addr(dev->dev_addr);
+	}
+
 	/* now, reset the chip, and put it into a known state */
 	smc911x_reset(dev);
 
@@ -1966,12 +1974,6 @@
 	lp->ctl_rfduplx = 1;
 	lp->ctl_rspeed = 100;
 
-#ifdef SMC_DYNAMIC_BUS_CONFIG
-	irq_flags = lp->cfg.irq_flags;
-#else
-	irq_flags = IRQF_SHARED | SMC_IRQ_SENSE;
-#endif
-
 	/* Grab the IRQ */
 	retval = request_irq(dev->irq, smc911x_interrupt,
 			     irq_flags, dev->name, dev);
@@ -2033,6 +2035,15 @@
 	return retval;
 }
 
+static inline unsigned long ioresource_to_irqf(unsigned long flag)
+{
+	return (((flag & IORESOURCE_IRQ_HIGHLEVEL) ? IRQF_TRIGGER_HIGH    : 0) |
+		((flag & IORESOURCE_IRQ_LOWEDGE)   ? IRQF_TRIGGER_LOW     : 0) |
+		((flag & IORESOURCE_IRQ_HIGHEDGE)  ? IRQF_TRIGGER_RISING  : 0) |
+		((flag & IORESOURCE_IRQ_LOWEDGE)   ? IRQF_TRIGGER_FALLING : 0) |
+		((flag & IORESOURCE_IRQ_SHAREABLE) ? IRQF_SHARED          : 0));
+}
+
 /*
  * smc911x_init(void)
  *
@@ -2044,13 +2055,15 @@
 {
 	struct net_device *ndev;
 	struct resource *res;
+	struct resource *irq_res;
 	struct smc911x_local *lp;
 	unsigned int *addr;
 	int ret;
 
 	DBG(SMC_DEBUG_FUNC, "--> %s\n",  __func__);
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res || !irq_res) {
 		ret = -ENODEV;
 		goto out;
 	}
@@ -2071,7 +2084,7 @@
 	SET_NETDEV_DEV(ndev, &pdev->dev);
 
 	ndev->dma = (unsigned char)-1;
-	ndev->irq = platform_get_irq(pdev, 0);
+	ndev->irq = irq_res->start;
 	lp = netdev_priv(ndev);
 	lp->netdev = ndev;
 #ifdef SMC_DYNAMIC_BUS_CONFIG
@@ -2094,7 +2107,7 @@
 	platform_set_drvdata(pdev, ndev);
 	lp->base = addr;
 	ndev->base_addr = res->start;
-	ret = smc911x_probe(ndev);
+	ret = smc911x_probe(ndev, pd, ioresource_to_irqf(irq_res->flags));
 	if (ret != 0) {
 		platform_set_drvdata(pdev, NULL);
 		iounmap(addr);
diff -Naur linux-3.4.11/drivers/net/ethernet/smsc/smc911x.h linux-HEAD/drivers/net/ethernet/smsc/smc911x.h
--- linux-3.4.11/drivers/net/ethernet/smsc/smc911x.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/net/ethernet/smsc/smc911x.h	2015-11-18 09:04:24.000000000 +0000
@@ -29,7 +29,7 @@
 #ifndef _SMC911X_H_
 #define _SMC911X_H_
 
-#include <linux/smc911x.h>
+#include <linux/smc91x.h>
 /*
  * Use the DMA feature on PXA chips
  */
@@ -112,7 +112,7 @@
 #endif
 	void __iomem *base;
 #ifdef SMC_DYNAMIC_BUS_CONFIG
-	struct smc911x_platdata cfg;
+	struct smc91x_platdata cfg;
 #endif
 };
 
@@ -125,10 +125,10 @@
 {
 	void __iomem *ioaddr = lp->base + reg;
 
-	if (lp->cfg.flags & SMC911X_USE_32BIT)
+	if (lp->cfg.flags & SMC91X_USE_32BIT)
 		return readl(ioaddr);
 
-	if (lp->cfg.flags & SMC911X_USE_16BIT)
+	if (lp->cfg.flags & SMC91X_USE_16BIT)
 		return readw(ioaddr) | (readw(ioaddr + 2) << 16);
 
 	BUG();
@@ -139,12 +139,12 @@
 {
 	void __iomem *ioaddr = lp->base + reg;
 
-	if (lp->cfg.flags & SMC911X_USE_32BIT) {
+	if (lp->cfg.flags & SMC91X_USE_32BIT) {
 		writel(value, ioaddr);
 		return;
 	}
 
-	if (lp->cfg.flags & SMC911X_USE_16BIT) {
+	if (lp->cfg.flags & SMC91X_USE_16BIT) {
 		writew(value & 0xffff, ioaddr);
 		writew(value >> 16, ioaddr + 2);
 		return;
@@ -158,12 +158,12 @@
 {
 	void __iomem *ioaddr = lp->base + reg;
 
-	if (lp->cfg.flags & SMC911X_USE_32BIT) {
+	if (lp->cfg.flags & SMC91X_USE_32BIT) {
 		readsl(ioaddr, addr, count);
 		return;
 	}
 
-	if (lp->cfg.flags & SMC911X_USE_16BIT) {
+	if (lp->cfg.flags & SMC91X_USE_16BIT) {
 		readsw(ioaddr, addr, count * 2);
 		return;
 	}
@@ -176,12 +176,12 @@
 {
 	void __iomem *ioaddr = lp->base + reg;
 
-	if (lp->cfg.flags & SMC911X_USE_32BIT) {
+	if (lp->cfg.flags & SMC91X_USE_32BIT) {
 		writesl(ioaddr, addr, count);
 		return;
 	}
 
-	if (lp->cfg.flags & SMC911X_USE_16BIT) {
+	if (lp->cfg.flags & SMC91X_USE_16BIT) {
 		writesw(ioaddr, addr, count * 2);
 		return;
 	}
diff -Naur linux-3.4.11/drivers/net/ethernet/smsc/smc91x.c linux-HEAD/drivers/net/ethernet/smsc/smc91x.c
--- linux-3.4.11/drivers/net/ethernet/smsc/smc91x.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/net/ethernet/smsc/smc91x.c	2015-11-18 09:04:24.000000000 +0000
@@ -1864,7 +1864,7 @@
  * o  GRAB the region
  */
 static int __devinit smc_probe(struct net_device *dev, void __iomem *ioaddr,
-			    unsigned long irq_flags)
+			       unsigned long irq_flags)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	static int version_printed = 0;
diff -Naur linux-3.4.11/drivers/net/irda/pxaficp_ir.c linux-HEAD/drivers/net/irda/pxaficp_ir.c
--- linux-3.4.11/drivers/net/irda/pxaficp_ir.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/net/irda/pxaficp_ir.c	2015-11-18 09:04:24.000000000 +0000
@@ -178,7 +178,12 @@
 			gpio_set_value(si->pdata->gpio_pwdown,
 					!(mode & IR_OFF) ^
 					!si->pdata->gpio_pwdown_inverted);
+
+#if defined(CONFIG_PXA25x) || defined(CONFIG_PXA27x)
 		pxa2xx_transceiver_mode(si->dev, mode);
+#else
+		printk_once(KERN_ERR "%s: pxa2xx_transceiver_mode() not implemented for this arch\n", __func__);
+#endif
 	}
 }
 
diff -Naur linux-3.4.11/drivers/net/phy/smsc.c linux-HEAD/drivers/net/phy/smsc.c
--- linux-3.4.11/drivers/net/phy/smsc.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/net/phy/smsc.c	2015-11-18 09:04:24.000000000 +0000
@@ -26,10 +26,20 @@
 
 static int smsc_phy_config_intr(struct phy_device *phydev)
 {
-	int rc = phy_write (phydev, MII_LAN83C185_IM,
-			((PHY_INTERRUPT_ENABLED == phydev->interrupts)
-			? MII_LAN83C185_ISF_INT_PHYLIB_EVENTS
-			: 0));
+	unsigned int	irqs = 0;
+	int rc;
+
+	if (phydev->interrupts != PHY_INTERRUPT_ENABLED)
+		irqs = 0;
+	else if (phydev->link)
+		irqs = (MII_LAN83C185_ISF_INT7 |
+			MII_LAN83C185_ISF_INT6 |
+			MII_LAN83C185_ISF_INT4);
+	else
+		irqs = (MII_LAN83C185_ISF_INT7 |
+			MII_LAN83C185_ISF_INT6);
+
+	rc = phy_write (phydev, MII_LAN83C185_IM, irqs);
 
 	return rc < 0 ? rc : 0;
 }
@@ -55,6 +65,84 @@
 
 	return smsc_phy_ack_interrupt (phydev);
 }
+static int lan87xx_config_init(struct phy_device *phydev)
+{
+        /*
+         * Make sure the EDPWRDOWN bit is NOT set. Setting this bit on
+         * LAN8710/LAN8720 PHY causes the PHY to misbehave, likely due
+         * to a bug on the chip.
+         *
+         * When the system is powered on with the network cable being
+         * disconnected all the way until after ifconfig ethX up is
+         * issued for the LAN port with this PHY, connecting the cable
+         * afterwards does not cause LINK change detection, while the
+         * expected behavior is the Link UP being detected.
+         */
+        int rc = phy_read(phydev, MII_LAN83C185_CTRL_STATUS);
+        if (rc < 0)
+                return rc;
+
+        rc &= ~MII_LAN83C185_EDPWRDOWN;
+
+        rc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS, rc);
+        if (rc < 0)
+                return rc;
+        return smsc_phy_ack_interrupt(phydev);
+}
+
+
+/*
+ * The LAN87xx suffers from rare absence of the ENERGYON-bit when Ethernet cable
+ * plugs in while LAN87xx is in Energy Detect Power-Down mode. This leads to
+ * unstable detection of plugging in Ethernet cable.
+ * This workaround disables Energy Detect Power-Down mode and waiting for
+ * response on link pulses to detect presence of plugged Ethernet cable.
+ * The Energy Detect Power-Down mode is enabled again in the end of procedure to
+ * save approximately 220 mW of power if cable is unplugged.
+ */
+static int lan87xx_read_status(struct phy_device *phydev)
+{
+	int err = genphy_read_status(phydev);
+	int i;
+	if (!phydev->link) {
+		/* Disable EDPD to wake up PHY */ //Christian Niclaus: We already deactivated EDPD in config_init function.
+		/*int rc = phy_read(phydev, MII_LAN83C185_CTRL_STATUS);
+		if (rc < 0)
+			return rc;
+
+		rc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS,
+			       rc & ~MII_LAN83C185_EDPWRDOWN);
+		if (rc < 0)
+			return rc;
+		*/
+		int rc = err;
+		/* Wait max 640 ms to detect energy */
+		for (i = 0; i < 64; i++) {
+			/* Sleep to allow link test pulses to be sent */
+			msleep(10);
+			rc = phy_read(phydev, MII_LAN83C185_CTRL_STATUS);
+			if (rc < 0)
+				return rc;
+			if (rc & MII_LAN83C185_ENERGYON)
+				err =  rc; //Christian Niclaus: Return actual status, not the up to 640ms old status read genphy_read_status. Fixes problem with some switches.
+				break;
+		}
+
+		/* Re-enable EDPD */
+		/*rc = phy_read(phydev, MII_LAN83C185_CTRL_STATUS);
+		if (rc < 0)
+			return rc;
+
+		rc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS,
+			       rc | MII_LAN83C185_EDPWRDOWN);
+		if (rc < 0)
+			return rc;
+		*/ //Christian Niclaus: Commented out because this reverts deactivation in fuction lan87xx_config_init. If commented in, it slows down link detection.
+
+	}
+
+	return err;
+}
 
 static int lan911x_config_init(struct phy_device *phydev)
 {
@@ -120,9 +208,10 @@
 
 	/* basic functions */
 	.config_aneg	= genphy_config_aneg,
-	.read_status	= genphy_read_status,
-	.config_init	= smsc_phy_config_init,
-
+	//.read_status	= genphy_read_status,
+	.read_status	= lan87xx_read_status,
+	//.config_init	= smsc_phy_config_init,
+    .config_init    = lan87xx_config_init,
 	/* IRQ related */
 	.ack_interrupt	= smsc_phy_ack_interrupt,
 	.config_intr	= smsc_phy_config_intr,
@@ -168,8 +257,10 @@
 
 	/* basic functions */
 	.config_aneg	= genphy_config_aneg,
-	.read_status	= genphy_read_status,
-	.config_init	= smsc_phy_config_init,
+	//.read_status	= genphy_read_status,
+	.read_status	= lan87xx_read_status,
+    .config_init    = lan87xx_config_init,
+	//.config_init	= smsc_phy_config_init,
 
 	/* IRQ related */
 	.ack_interrupt	= smsc_phy_ack_interrupt,
diff -Naur linux-3.4.11/drivers/pcmcia/pxa2xx_base.c linux-HEAD/drivers/pcmcia/pxa2xx_base.c
--- linux-3.4.11/drivers/pcmcia/pxa2xx_base.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/pcmcia/pxa2xx_base.c	2015-11-18 09:04:24.000000000 +0000
@@ -190,18 +190,8 @@
 			       struct cpufreq_freqs *freqs)
 {
 	switch (val) {
-	case CPUFREQ_PRECHANGE:
-		if (freqs->new > freqs->old) {
-			debug(skt, 2, "new frequency %u.%uMHz > %u.%uMHz, "
-			       "pre-updating\n",
-			       freqs->new / 1000, (freqs->new / 100) % 10,
-			       freqs->old / 1000, (freqs->old / 100) % 10);
-			pxa2xx_pcmcia_set_timing(skt);
-		}
-		break;
-
 	case CPUFREQ_POSTCHANGE:
-		if (freqs->new < freqs->old) {
+		if (freqs->new != freqs->old) {
 			debug(skt, 2, "new frequency %u.%uMHz < %u.%uMHz, "
 			       "post-updating\n",
 			       freqs->new / 1000, (freqs->new / 100) % 10,
@@ -313,8 +303,14 @@
 
 	/* Initialize processor specific parameters */
 	for (i = 0; i < ops->nr; i++) {
+		struct platform_device *parent_pdev = NULL;
+		size_t			res_idx;
+
 		skt = &sinfo->skt[i];
 
+		if (parent_pdev)
+			skt->parent_resource = &parent_pdev->resource[res_idx];
+
 		skt->nr = ops->first + i;
 		skt->clk = clk;
 		soc_pcmcia_init_one(skt, ops, &dev->dev);
diff -Naur linux-3.4.11/drivers/pcmcia/soc_common.c linux-HEAD/drivers/pcmcia/soc_common.c
--- linux-3.4.11/drivers/pcmcia/soc_common.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/pcmcia/soc_common.c	2015-11-18 09:04:24.000000000 +0000
@@ -714,32 +714,39 @@
 	release_resource(&skt->res_attr);
 	release_resource(&skt->res_mem);
 	release_resource(&skt->res_io);
-	release_resource(&skt->res_skt);
+
+	if (!skt->parent_resource)
+		release_resource(&skt->res_skt);
 }
 EXPORT_SYMBOL(soc_pcmcia_remove_one);
 
 int soc_pcmcia_add_one(struct soc_pcmcia_socket *skt)
 {
 	int ret;
+	struct resource		*parent_resource = skt->parent_resource;
 
 	init_timer(&skt->poll_timer);
 	skt->poll_timer.function = soc_common_pcmcia_poll_event;
 	skt->poll_timer.data = (unsigned long)skt;
 	skt->poll_timer.expires = jiffies + SOC_PCMCIA_POLL_PERIOD;
 
-	ret = request_resource(&iomem_resource, &skt->res_skt);
-	if (ret)
-		goto out_err_1;
+	if (!parent_resource) {
+		ret = request_resource(&iomem_resource, &skt->res_skt);
+		if (ret)
+			goto out_err_1;
+
+		parent_resource = &skt->res_skt;
+	}
 
-	ret = request_resource(&skt->res_skt, &skt->res_io);
+	ret = request_resource(parent_resource, &skt->res_io);
 	if (ret)
 		goto out_err_2;
 
-	ret = request_resource(&skt->res_skt, &skt->res_mem);
+	ret = request_resource(parent_resource, &skt->res_mem);
 	if (ret)
 		goto out_err_3;
 
-	ret = request_resource(&skt->res_skt, &skt->res_attr);
+	ret = request_resource(parent_resource, &skt->res_attr);
 	if (ret)
 		goto out_err_4;
 
@@ -805,7 +812,8 @@
  out_err_3:
 	release_resource(&skt->res_io);
  out_err_2:
-	release_resource(&skt->res_skt);
+	if (!skt->parent_resource)
+		release_resource(&skt->res_skt);
  out_err_1:
 
 	return ret;
diff -Naur linux-3.4.11/drivers/pcmcia/soc_common.h linux-HEAD/drivers/pcmcia/soc_common.h
--- linux-3.4.11/drivers/pcmcia/soc_common.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/pcmcia/soc_common.h	2015-11-18 09:04:24.000000000 +0000
@@ -44,6 +44,8 @@
 	unsigned short		spd_mem[MAX_WIN];
 	unsigned short		spd_attr[MAX_WIN];
 
+	struct resource		*parent_resource;
+
 	struct resource		res_skt;
 	struct resource		res_io;
 	struct resource		res_mem;
diff -Naur linux-3.4.11/drivers/regulator/lp3972.c linux-HEAD/drivers/regulator/lp3972.c
--- linux-3.4.11/drivers/regulator/lp3972.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/regulator/lp3972.c	2015-11-18 09:04:24.000000000 +0000
@@ -14,18 +14,24 @@
 #include <linux/i2c.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
+#include <linux/gpio.h>
 #include <linux/regulator/driver.h>
 #include <linux/regulator/lp3972.h>
 #include <linux/slab.h>
 
 struct lp3972 {
 	struct device *dev;
+	struct gpio_chip gpio;
 	struct mutex io_lock;
 	struct i2c_client *i2c;
 	int num_regulators;
 	struct regulator_dev **rdev;
 };
 
+#define to_lp3972_gpio(_gpio) \
+	container_of(_gpio, struct lp3972, gpio)
+
+
 /* LP3972 Control Registers */
 #define LP3972_SCR_REG		0x07
 #define LP3972_OVER1_REG	0x10
@@ -235,7 +241,7 @@
 	if (ret == 0) {
 		ret = lp3972_i2c_write(lp3972->i2c, reg, 1, &tmp);
 		dev_dbg(lp3972->dev, "reg write 0x%02x -> 0x%02x\n", (int)reg,
-			(unsigned)val & 0xff);
+			(unsigned)tmp & 0xff);
 	}
 	mutex_unlock(&lp3972->io_lock);
 
@@ -575,6 +581,108 @@
 	return err;
 }
 
+static int lp3972_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	struct lp3972	*lp3972 = to_lp3972_gpio(chip);
+
+	if (WARN_ON(offset >= 2))
+		return -EINVAL;
+
+	return lp3972_set_bits(lp3972, LP3972_SCR2_REG,
+			       (3 << (offset*2)), (2 << (offset*2)));
+}
+
+static int lp3972_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int val)
+{
+	struct lp3972	*lp3972 = to_lp3972_gpio(chip);
+
+	if (WARN_ON(offset >= 2))
+		return -EINVAL;
+
+	return lp3972_set_bits(lp3972, LP3972_SCR2_REG,
+			       (3 << (offset*2)),
+			       (val ? 3 : 1) << (offset*2));
+}
+
+static int lp3972_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct lp3972	*lp3972 = to_lp3972_gpio(chip);
+	int		v;
+
+	if (WARN_ON(offset >= 2))
+		v = 0;
+	else {
+		v   = lp3972_reg_read(lp3972, LP3972_SCR2_REG);
+		v >>= offset * 2;
+		v  &= 0x3;
+
+		if (v == 2)
+			v = (lp3972_reg_read(lp3972, LP3972_ISRA_REG) &
+			     (1 << (offset+4)));
+		else
+			v = v != 1;
+	}
+
+	return v;
+}
+
+static void lp3972_gpio_set(struct gpio_chip *chip, unsigned offset, int val)
+{
+	lp3972_gpio_direction_output(chip, offset, val);
+}
+
+static int lp3972_gpio_request(struct gpio_chip *chip, unsigned offset)
+{
+	struct lp3972	*lp3972 = to_lp3972_gpio(chip);
+
+	if (offset == 0)
+		lp3972_set_bits(lp3972, LP3972_SCR2_REG, 0x80, 0);
+
+	return 0;
+}
+
+static void lp3972_gpio_free(struct gpio_chip *chip, unsigned offset)
+{
+	struct lp3972	*lp3972 = to_lp3972_gpio(chip);
+
+	if (WARN_ON(offset >= 2))
+		return;
+
+	/* set High-Z on free */
+	lp3972_set_bits(lp3972, LP3972_SCR2_REG, (3 << (offset*2)), 0);
+
+	if (offset == 0) {
+		lp3972_set_bits(lp3972, LP3972_SCR2_REG, 0x80, 0x80);
+	}
+}
+
+static int __devinit setup_gpios(struct lp3972 *lp3972,
+				 struct lp3972_platform_data const *pdata)
+{
+	struct gpio_chip	*gc = &lp3972->gpio;
+	int			rc;
+
+	gc->label = dev_name(lp3972->dev);
+	gc->owner = THIS_MODULE;
+	gc->dev   = lp3972->dev;
+	gc->base  = pdata->gpio_base;
+	gc->ngpio = 2;
+	gc->can_sleep = 1;
+
+	gc->direction_input  = lp3972_gpio_direction_input;
+	gc->direction_output = lp3972_gpio_direction_output;
+	gc->request          = lp3972_gpio_request;
+	gc->free             = lp3972_gpio_free;
+	gc->get              = lp3972_gpio_get;
+	gc->set              = lp3972_gpio_set;
+
+	rc = gpiochip_add(&lp3972->gpio);
+	if (rc < 0)
+		dev_err(lp3972->dev, "gpiochip_add() failed: %d\n", rc);
+
+	return rc;
+}
+
 static int __devinit lp3972_i2c_probe(struct i2c_client *i2c,
 			    const struct i2c_device_id *id)
 {
@@ -609,13 +717,22 @@
 		goto err_detect;
 	}
 
-	ret = setup_regulators(lp3972, pdata);
+	if (gpio_is_valid(pdata->gpio_base) && pdata->gpio_base != 0)
+		ret = setup_gpios(lp3972, pdata);
+
 	if (ret < 0)
 		goto err_detect;
 
+	ret = setup_regulators(lp3972, pdata);
+	if (ret < 0)
+		goto err_gpio;
+
 	i2c_set_clientdata(i2c, lp3972);
 	return 0;
 
+err_gpio:
+	WARN_ON(gpiochip_remove(&lp3972->gpio) < 0);
+
 err_detect:
 	kfree(lp3972);
 	return ret;
@@ -625,6 +742,13 @@
 {
 	struct lp3972 *lp3972 = i2c_get_clientdata(i2c);
 	int i;
+	int rc = 0;
+
+	if (lp3972->gpio.dev)
+		rc = gpiochip_remove(&lp3972->gpio);
+
+	if (rc < 0)
+		return rc;
 
 	for (i = 0; i < lp3972->num_regulators; i++)
 		regulator_unregister(lp3972->rdev[i]);
diff -Naur linux-3.4.11/drivers/rtc/Kconfig linux-HEAD/drivers/rtc/Kconfig
--- linux-3.4.11/drivers/rtc/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/rtc/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -997,6 +997,10 @@
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-stmp3xxx.
 
+config RTC_DRV_STMP_WATCHDOG
+        bool "Enable STMP3xxx/i.MX23/i.MX28 watchdog"
+	depends on RTC_DRV_STMP && WATCHDOG
+
 config RTC_DRV_PCAP
 	tristate "PCAP RTC"
 	depends on EZX_PCAP
diff -Naur linux-3.4.11/drivers/rtc/rtc-pcf8563.c linux-HEAD/drivers/rtc/rtc-pcf8563.c
--- linux-3.4.11/drivers/rtc/rtc-pcf8563.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/rtc/rtc-pcf8563.c	2015-11-18 09:04:24.000000000 +0000
@@ -173,6 +173,146 @@
 	return 0;
 }
 
+static int pcf8563_get_mask_value(uint8_t bcd, uint8_t mask)
+{
+	if (bcd & 0x80)
+		return -1;
+
+	bcd &= ~0x80;
+	bcd &= mask;
+
+	return bcd2bin(bcd);
+}
+
+static void pcf8563_set_mask_value(uint8_t *cur, uint8_t mask, int v)
+{
+	*cur = ((*cur & ~mask) |
+		(v<0 ? 0x80 : (bin2bcd(v) & mask)));
+}
+
+static int pcf8563_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct i2c_client	*client = to_i2c_client(dev);
+	int			rc;
+
+	unsigned char		buf[7] = {
+		[0] = PCF8563_REG_ST2,
+		[3] = PCF8563_REG_AMN
+	};
+
+	struct i2c_msg		in_msgs[] = {
+		{ client->addr,        0,  1, buf+0 },	/* setup read ptr */
+		{ client->addr, I2C_M_RD,  1, buf+0 },	/* setup read ptr */
+		{ client->addr,        0,  1, buf+3 },	/* setup read ptr */
+		{ client->addr, I2C_M_RD,  4, buf+3 },	/* setup read ptr */
+	};
+
+	struct i2c_msg		out_msgs[] = {
+		{ client->addr,        0,  2, buf+0 },	/* alarm enable/disable */
+		{ client->addr,        0,  5, buf+2 },  /* alarm values */
+	};
+
+
+	/* read registers */
+	rc = i2c_transfer(client->adapter, in_msgs, 2);
+	if (rc != 2) {
+		dev_err(&client->dev, "%s: read error: %i\n", __FUNCTION__, rc);
+		return rc>=0 ? -EIO : rc;
+	}
+
+	rc = i2c_transfer(client->adapter, in_msgs+2, 2);
+	if (rc != 2) {
+		dev_err(&client->dev, "%s: read error: %i\n", __FUNCTION__, rc);
+		return rc>=0 ? -EIO : rc;
+	}
+
+	pr_debug("%s():%u: buf=[%02x,%02x,%02x,%02x, %02x,%02x,%02x]\n",
+		 __FUNCTION__, __LINE__,
+		 buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
+
+	if (buf[1] & PCF8563_SC_LV) {
+		dev_info(&client->dev,
+			"low voltage detected, date/time is not reliable.\n");
+		return -EIO;
+	}
+
+	// clear ALARM/TIMER block and set AE when needed
+	buf[1] = (buf[0] & 0x10) | (alrm->enabled ? (1<<1) : 0);
+	buf[0] = PCF8563_REG_ST2;
+
+	buf[2] = PCF8563_REG_AMN;
+	pcf8563_set_mask_value(buf+3, 0xff, alrm->time.tm_min);
+	pcf8563_set_mask_value(buf+4, 0xbf, alrm->time.tm_hour);
+	pcf8563_set_mask_value(buf+5, 0xbf, alrm->time.tm_mday);
+	pcf8563_set_mask_value(buf+6, 0x87, alrm->time.tm_wday);
+
+	pr_debug("%s():%u: buf=[%02x,%02x,%02x,%02x, %02x,%02x,%02x]\n",
+		 __FUNCTION__, __LINE__,
+		 buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
+
+	rc = i2c_transfer(client->adapter, out_msgs, ARRAY_SIZE(out_msgs));
+	if (rc != ARRAY_SIZE(out_msgs)) {
+		dev_err(&client->dev, "%s: failed to set alarm values\n", __FUNCTION__);
+		return rc>=0 ? -EIO : rc;
+	}
+
+	return 0;
+}
+
+static int pcf8563_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct i2c_client	*client = to_i2c_client(dev);
+	int			rc;
+
+	unsigned char		buf[6] = {
+		[0] = PCF8563_REG_ST2,
+		[2] = PCF8563_REG_AMN
+	};
+
+	struct i2c_msg		msgs[] = {
+		{ client->addr,        0,  1, buf+0 },	/* setup read ptr */
+		{ client->addr, I2C_M_RD,  1, buf+0 },	/* setup read ptr */
+		{ client->addr,        0,  1, buf+2 },	/* setup read ptr */
+		{ client->addr, I2C_M_RD,  4, buf+2 },	/* setup read ptr */
+	};
+
+	/* read registers */
+	rc = i2c_transfer(client->adapter, msgs,   2);
+	if (rc != 2) {
+		dev_err(&client->dev, "%s: read error: %i\n", __FUNCTION__, rc);
+		return rc>=0 ? -EIO : rc;
+	}
+
+	rc = i2c_transfer(client->adapter, msgs+2, 2);
+	if (rc != 2) {
+		dev_err(&client->dev, "%s: read error: %i\n", __FUNCTION__, rc);
+		return rc>=0 ? -EIO : rc;
+	}
+
+	pr_debug("%s():%u: buf=[%02x,%02x,%02x,%02x, %02x,%02x]\n",
+		 __FUNCTION__, __LINE__,
+		 buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
+
+	if (buf[1] & PCF8563_SC_LV)
+		dev_info(&client->dev,
+			"low voltage detected, date/time is not reliable.\n");
+
+	alrm->enabled = (buf[0] & (1<<1)) ? 1 : 0;
+	alrm->pending = (buf[0] & (1<<3)) ? 1 : 0;
+	alrm->time.tm_sec   = 0;
+	alrm->time.tm_min   = pcf8563_get_mask_value(buf[2], 0x7f);
+	alrm->time.tm_hour  = pcf8563_get_mask_value(buf[3], 0x3f);
+	alrm->time.tm_mday  = pcf8563_get_mask_value(buf[4], 0x3f);
+	alrm->time.tm_mon   = -1;
+	alrm->time.tm_year  = -1;
+	alrm->time.tm_wday  = pcf8563_get_mask_value(buf[5], 0x07);
+	alrm->time.tm_yday  = -1;
+	alrm->time.tm_isdst = -1;
+
+	return 0;
+}
+
+
 static int pcf8563_rtc_read_time(struct device *dev, struct rtc_time *tm)
 {
 	return pcf8563_get_datetime(to_i2c_client(dev), tm);
@@ -186,6 +326,8 @@
 static const struct rtc_class_ops pcf8563_rtc_ops = {
 	.read_time	= pcf8563_rtc_read_time,
 	.set_time	= pcf8563_rtc_set_time,
+	.set_alarm      = pcf8563_rtc_set_alarm,
+	.read_alarm     = pcf8563_rtc_read_alarm,
 };
 
 static int pcf8563_probe(struct i2c_client *client,
@@ -207,6 +349,7 @@
 	dev_info(&client->dev, "chip found, driver version " DRV_VERSION "\n");
 
 	i2c_set_clientdata(client, pcf8563);
+	device_set_wakeup_capable(&client->dev, 1);
 
 	pcf8563->rtc = rtc_device_register(pcf8563_driver.driver.name,
 				&client->dev, &pcf8563_rtc_ops, THIS_MODULE);
diff -Naur linux-3.4.11/drivers/rtc/rtc-pxa.c linux-HEAD/drivers/rtc/rtc-pxa.c
--- linux-3.4.11/drivers/rtc/rtc-pxa.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/rtc/rtc-pxa.c	2015-11-18 09:04:24.000000000 +0000
@@ -360,6 +360,7 @@
 	}
 
 	rtsr_clear_bits(pxa_rtc, RTSR_PIALE | RTSR_RDALE1 | RTSR_HZE);
+	device_init_wakeup(dev, 1);
 
 	pxa_rtc->rtc = rtc_device_register("pxa-rtc", &pdev->dev, &pxa_rtc_ops,
 					   THIS_MODULE);
@@ -369,8 +370,6 @@
 		goto err_rtc_reg;
 	}
 
-	device_init_wakeup(dev, 1);
-
 	return 0;
 
 err_rtc_reg:
diff -Naur linux-3.4.11/drivers/rtc/rtc-rs5c372.c linux-HEAD/drivers/rtc/rtc-rs5c372.c
--- linux-3.4.11/drivers/rtc/rtc-rs5c372.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/rtc/rtc-rs5c372.c	2015-11-18 09:04:24.000000000 +0000
@@ -96,6 +96,7 @@
 	unsigned		time24:1;
 	unsigned		has_irq:1;
 	unsigned		smbus:1;
+	unsigned		good_osc:1;
 	char			buf[17];
 	char			*regs;
 };
@@ -182,6 +183,11 @@
 	if (status < 0)
 		return status;
 
+	if (!rs5c->good_osc) {
+		dev_dbg(&client->dev, "oscillator not up; time must be set manually\n");
+		return -EIO;
+	}
+
 	tm->tm_sec = bcd2bin(rs5c->regs[RS5C372_REG_SECS] & 0x7f);
 	tm->tm_min = bcd2bin(rs5c->regs[RS5C372_REG_MINS] & 0x7f);
 	tm->tm_hour = rs5c_reg2hr(rs5c, rs5c->regs[RS5C372_REG_HOURS]);
@@ -205,6 +211,8 @@
 	return rtc_valid_tm(tm);
 }
 
+static int rs5c_oscillator_setup(struct rs5c372 *rs5c372);
+
 static int rs5c372_set_datetime(struct i2c_client *client, struct rtc_time *tm)
 {
 	struct rs5c372	*rs5c = i2c_get_clientdata(client);
@@ -217,6 +225,20 @@
 		tm->tm_sec, tm->tm_min, tm->tm_hour,
 		tm->tm_mday, tm->tm_mon, tm->tm_year, tm->tm_wday);
 
+	if (!rs5c->good_osc) {
+		int		rc = rs5c_get_regs(rs5c);
+
+		if (rc < 0)
+			return rc;
+
+		rc = rs5c_oscillator_setup(rs5c);
+		if (rc < 0) {
+			dev_err(&client->dev, "failed to setup oscillator: %d\n",
+				rc);
+			return rc;
+		}
+	}
+
 	addr   = RS5C_ADDR(RS5C372_REG_SECS);
 	buf[0] = bin2bcd(tm->tm_sec);
 	buf[1] = bin2bcd(tm->tm_min);
@@ -499,20 +521,23 @@
 
 static struct i2c_driver rs5c372_driver;
 
+static void rs5c_check_oscillator(struct rs5c372 *rs5c372)
+{
+	if (rs5c372->type == rtc_r2025sd)
+		rs5c372->good_osc =
+			!(rs5c372->regs[RS5C_REG_CTRL2] & R2025_CTRL2_XST);
+	else
+		rs5c372->good_osc =
+			!(rs5c372->regs[RS5C_REG_CTRL2] & RS5C_CTRL2_XSTP);
+}
+
 static int rs5c_oscillator_setup(struct rs5c372 *rs5c372)
 {
 	unsigned char buf[2];
 	int addr, i, ret = 0;
 
-	if (rs5c372->type == rtc_r2025sd) {
-		if (!(rs5c372->regs[RS5C_REG_CTRL2] & R2025_CTRL2_XST))
-			return ret;
-		rs5c372->regs[RS5C_REG_CTRL2] &= ~R2025_CTRL2_XST;
-	} else {
-		if (!(rs5c372->regs[RS5C_REG_CTRL2] & RS5C_CTRL2_XSTP))
-			return ret;
-		rs5c372->regs[RS5C_REG_CTRL2] &= ~RS5C_CTRL2_XSTP;
-	}
+	if (rs5c372->good_osc)
+		return 0;
 
 	addr   = RS5C_ADDR(RS5C_REG_CTRL1);
 	buf[0] = rs5c372->regs[RS5C_REG_CTRL1];
@@ -543,8 +568,11 @@
 			return ret;
 	}
 
-	rs5c372->regs[RS5C_REG_CTRL1] = buf[0];
-	rs5c372->regs[RS5C_REG_CTRL2] = buf[1];
+	ret = rs5c_get_regs(rs5c372);
+	if (unlikely(ret < 0))
+		return ret;
+
+	rs5c_check_oscillator(rs5c372);
 
 	return 0;
 }
@@ -617,19 +645,9 @@
 		goto exit_kfree;
 	}
 
-	/* if the oscillator lost power and no other software (like
-	 * the bootloader) set it up, do it here.
-	 *
-	 * The R2025S/D does this a little differently than the other
-	 * parts, so we special case that..
-	 */
-	err = rs5c_oscillator_setup(rs5c372);
-	if (unlikely(err < 0)) {
-		dev_err(&client->dev, "setup error\n");
-		goto exit_kfree;
-	}
+	rs5c_check_oscillator(rs5c372);
 
-	if (rs5c372_get_datetime(client, &tm) < 0)
+	if (!rs5c372->good_osc || rs5c372_get_datetime(client, &tm) < 0)
 		dev_warn(&client->dev, "clock needs to be set\n");
 
 	dev_info(&client->dev, "%s found, %s, driver version " DRV_VERSION "\n",
diff -Naur linux-3.4.11/drivers/rtc/rtc-stmp3xxx.c linux-HEAD/drivers/rtc/rtc-stmp3xxx.c
--- linux-3.4.11/drivers/rtc/rtc-stmp3xxx.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/rtc/rtc-stmp3xxx.c	2015-11-18 09:04:24.000000000 +0000
@@ -25,37 +25,48 @@
 #include <linux/interrupt.h>
 #include <linux/rtc.h>
 #include <linux/slab.h>
+#include <linux/watchdog.h>
 
 #include <mach/common.h>
 
+#define BIT_SET	0x4
+#define BIT_CLR	0x8
+
 #define STMP3XXX_RTC_CTRL			0x0
 #define STMP3XXX_RTC_CTRL_SET			0x4
 #define STMP3XXX_RTC_CTRL_CLR			0x8
 #define STMP3XXX_RTC_CTRL_ALARM_IRQ_EN		0x00000001
 #define STMP3XXX_RTC_CTRL_ONEMSEC_IRQ_EN	0x00000002
 #define STMP3XXX_RTC_CTRL_ALARM_IRQ		0x00000004
+#define STMP3XXX_RTC_CTRL_WATCHDOG_EN		(1 << 4)
 
 #define STMP3XXX_RTC_STAT			0x10
 #define STMP3XXX_RTC_STAT_STALE_SHIFT		16
 #define STMP3XXX_RTC_STAT_RTC_PRESENT		0x80000000
+#define STMP3XXX_RTC_STAT_WDG_PRESENT		(1u << 29)
 
 #define STMP3XXX_RTC_SECONDS			0x30
 
 #define STMP3XXX_RTC_ALARM			0x40
-
+#define STMP3XXX_RTC_WATCHDOG			0x50
 #define STMP3XXX_RTC_PERSISTENT0		0x60
 #define STMP3XXX_RTC_PERSISTENT0_SET		0x64
 #define STMP3XXX_RTC_PERSISTENT0_CLR		0x68
 #define STMP3XXX_RTC_PERSISTENT0_ALARM_WAKE_EN	0x00000002
 #define STMP3XXX_RTC_PERSISTENT0_ALARM_EN	0x00000004
 #define STMP3XXX_RTC_PERSISTENT0_ALARM_WAKE	0x00000080
+#define STMP3XXX_RTC_PERSISTENT0_EXTERNAL_RESET	(1u << 21)
+#define STMP3XXX_RTC_PERSISTENT0_THERMAL_RESET	(1u << 20)
 
 struct stmp3xxx_rtc_data {
 	struct rtc_device *rtc;
+	struct watchdog_device wdg;
 	void __iomem *io;
 	int irq_alarm;
 };
 
+#define wdg_to_rtc(_wd) container_of(_wd, struct stmp3xxx_rtc_data, wdg)
+
 static void stmp3xxx_wait_time(struct stmp3xxx_rtc_data *rtc_data)
 {
 	/*
@@ -162,6 +173,10 @@
 
 	writel(STMP3XXX_RTC_CTRL_ALARM_IRQ_EN,
 			rtc_data->io + STMP3XXX_RTC_CTRL_CLR);
+
+	if (rtc_data->wdg.ops != NULL)
+		watchdog_unregister_device(&rtc_data->wdg);
+
 	free_irq(rtc_data->irq_alarm, &pdev->dev);
 	rtc_device_unregister(rtc_data->rtc);
 	platform_set_drvdata(pdev, NULL);
@@ -171,6 +186,147 @@
 	return 0;
 }
 
+static struct watchdog_info const	stmp3xxx_wdg_info = {
+	.options	= WDIOF_KEEPALIVEPING | WDIOF_SETTIMEOUT,
+	.identity	= "STMP3XXX",
+};
+
+static int stmp3xxx_wdg_start(struct watchdog_device *wdg)
+{
+	struct stmp3xxx_rtc_data	*rtc_data = wdg_to_rtc(wdg);
+
+	writel(wdg->timeout*1000, rtc_data->io + STMP3XXX_RTC_WATCHDOG);
+	writel(STMP3XXX_RTC_CTRL_WATCHDOG_EN,
+	       rtc_data->io + STMP3XXX_RTC_WATCHDOG + BIT_SET);
+
+	return 0;
+}
+
+static int stmp3xxx_wdg_stop(struct watchdog_device *wdg)
+{
+	struct stmp3xxx_rtc_data	*rtc_data = wdg_to_rtc(wdg);
+
+	writel(STMP3XXX_RTC_CTRL_WATCHDOG_EN,
+	       rtc_data->io + STMP3XXX_RTC_WATCHDOG + BIT_CLR);
+
+	return 0;
+}
+
+static unsigned int stmp3xxx_wdg_status(struct watchdog_device *wdg)
+{
+	struct stmp3xxx_rtc_data	*rtc_data = wdg_to_rtc(wdg);
+	unsigned int	ret = 0;
+	unsigned int	ctrl = readl(rtc_data->io + STMP3XXX_RTC_CTRL);
+
+	if (ctrl & STMP3XXX_RTC_CTRL_WATCHDOG_EN)
+		ret |= (1 << WDOG_ACTIVE);
+
+	return ret;
+}
+
+static int stmp3xxx_wdg_ping(struct watchdog_device *wdg)
+{
+	struct stmp3xxx_rtc_data	*rtc_data = wdg_to_rtc(wdg);
+
+	writel(wdg->timeout*1000, rtc_data->io + STMP3XXX_RTC_WATCHDOG);
+	return 0;
+}
+
+static int stmp3xxx_wdg_set_timeout(struct watchdog_device *wdg,
+				    unsigned int timeout)
+{
+	/* watchdog_dev makes the max/min checks */
+	wdg->timeout = timeout;
+
+	return 0;
+}
+
+static unsigned int stmp3xxx_wdg_get_timeleft(struct watchdog_device *wdg)
+{
+	struct stmp3xxx_rtc_data	*rtc_data = wdg_to_rtc(wdg);
+
+	return readl(rtc_data->io + STMP3XXX_RTC_WATCHDOG) / 1000;
+}
+
+static struct watchdog_ops const	stmp3xxx_wdg_ops = {
+	.owner		= THIS_MODULE,
+	.start		= stmp3xxx_wdg_start,
+	.stop		= stmp3xxx_wdg_stop,
+	.ping		= stmp3xxx_wdg_ping,
+	.status		= stmp3xxx_wdg_status,
+	.set_timeout	= stmp3xxx_wdg_set_timeout,
+	.get_timeleft	= stmp3xxx_wdg_get_timeleft,
+};
+
+static int stmp3xxx_rtc_probe_watchdog(struct platform_device *pdev,
+				       struct stmp3xxx_rtc_data *rtc)
+{
+	int		rc;
+	unsigned int	pers0;
+
+#if !defined(CONFIG_RTC_DRV_STMP_WATCHDOG)
+	return 0;
+#endif
+
+	if (!(readl(rtc->io + STMP3XXX_RTC_STAT) &
+	      STMP3XXX_RTC_STAT_WDG_PRESENT))
+		return 0;
+
+	pers0 = readl(rtc->io + STMP3XXX_RTC_PERSISTENT0);
+
+	rtc->wdg.info        = &stmp3xxx_wdg_info;
+	rtc->wdg.ops         = &stmp3xxx_wdg_ops;
+	rtc->wdg.timeout     = 60;
+	rtc->wdg.min_timeout = 1;
+	rtc->wdg.max_timeout = 0xffffffffu / 1000u;
+
+	if (pers0 & STMP3XXX_RTC_PERSISTENT0_EXTERNAL_RESET)
+		rtc->wdg.bootstatus |= WDIOF_CARDRESET;
+
+	if (pers0 & STMP3XXX_RTC_PERSISTENT0_THERMAL_RESET)
+		rtc->wdg.bootstatus |= WDIOF_OVERHEAT;
+
+	rc = watchdog_register_device(&rtc->wdg);
+	if (rc < 0) {
+		dev_warn(&pdev->dev, "failed to register watchdog: %d\n", rc);
+		goto out;
+	}
+
+	rc = device_move(rtc->wdg.dev, &pdev->dev, DPM_ORDER_NONE);
+	if (rc < 0) {
+		dev_warn(rtc->wdg.dev, "failed to reassign parent: %d\n", rc);
+		goto out;
+	}
+
+	writel(STMP3XXX_RTC_PERSISTENT0_EXTERNAL_RESET |
+	       STMP3XXX_RTC_PERSISTENT0_THERMAL_RESET,
+	       rtc->io + STMP3XXX_RTC_PERSISTENT0 + BIT_CLR);
+
+	if (stmp3xxx_wdg_status(&rtc->wdg) & (1 << WDOG_ACTIVE))
+		dev_info(rtc->wdg.dev,
+			 "watchdog initialized, %u seconds remaining\n",
+			 stmp3xxx_wdg_get_timeleft(&rtc->wdg));
+	else
+		dev_info(rtc->wdg.dev, "watchdog initialized\n");
+
+	rc = 0;
+
+out:
+	return rc;
+}
+
+static int stmp3xxx_rtc_reset_block(void __iomem *io)
+{
+	unsigned int	ctrl = readl(io + STMP3XXX_RTC_CTRL);
+	int		rc = 0;
+
+	/* do not reset the RTC when it has been initialized */
+	if ((ctrl & ((1u << 31)|(1u << 30))) != 0)
+		rc = mxs_reset_block(io);
+
+	return rc;
+}
+
 static int stmp3xxx_rtc_probe(struct platform_device *pdev)
 {
 	struct stmp3xxx_rtc_data *rtc_data;
@@ -206,7 +362,7 @@
 
 	platform_set_drvdata(pdev, rtc_data);
 
-	mxs_reset_block(rtc_data->io);
+	stmp3xxx_rtc_reset_block(rtc_data->io);
 	writel(STMP3XXX_RTC_PERSISTENT0_ALARM_EN |
 			STMP3XXX_RTC_PERSISTENT0_ALARM_WAKE_EN |
 			STMP3XXX_RTC_PERSISTENT0_ALARM_WAKE,
@@ -231,6 +387,12 @@
 		goto out_irq_alarm;
 	}
 
+	err = stmp3xxx_rtc_probe_watchdog(pdev, rtc_data);
+	if (err < 0) {
+		free_irq(rtc_data->irq_alarm, &pdev->dev);
+		goto out_irq_alarm;
+	}
+
 	return 0;
 
 out_irq_alarm:
@@ -253,7 +415,7 @@
 {
 	struct stmp3xxx_rtc_data *rtc_data = platform_get_drvdata(dev);
 
-	mxs_reset_block(rtc_data->io);
+	stmp3xxx_rtc_reset_block(rtc_data->io);
 	writel(STMP3XXX_RTC_PERSISTENT0_ALARM_EN |
 			STMP3XXX_RTC_PERSISTENT0_ALARM_WAKE_EN |
 			STMP3XXX_RTC_PERSISTENT0_ALARM_WAKE,
diff -Naur linux-3.4.11/drivers/spi/Kconfig linux-HEAD/drivers/spi/Kconfig
--- linux-3.4.11/drivers/spi/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/spi/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -275,8 +275,8 @@
 
 config SPI_PXA2XX
 	tristate "PXA2xx SSP SPI master"
-	depends on (ARCH_PXA || (X86_32 && PCI)) && EXPERIMENTAL
-	select PXA_SSP if ARCH_PXA
+	depends on (ARCH_PXA || ARCH_MMP || (X86_32 && PCI)) && EXPERIMENTAL
+	select PXA_SSP if ARCH_PXA || ARCH_MMP
 	help
 	  This enables using a PXA2xx or Sodaville SSP port as a SPI master
 	  controller. The driver can be configured to use any SSP port and
@@ -285,6 +285,9 @@
 config SPI_PXA2XX_PCI
 	def_bool SPI_PXA2XX && X86_32 && PCI
 
+config SPI_PXA2XX_MMP
+	def_bool SPI_PXA2XX && ARCH_MMP
+
 config SPI_RSPI
 	tristate "Renesas RSPI controller"
 	depends on SUPERH
diff -Naur linux-3.4.11/drivers/spi/Makefile linux-HEAD/drivers/spi/Makefile
--- linux-3.4.11/drivers/spi/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/spi/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -63,3 +63,4 @@
 obj-$(CONFIG_SPI_TXX9)			+= spi-txx9.o
 obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
 
+obj-$(CONFIG_SPI_EQ3SPI)		+= spi-eq3-gpio.o
diff -Naur linux-3.4.11/drivers/spi/spi-eq3-gpio.c linux-HEAD/drivers/spi/spi-eq3-gpio.c
--- linux-3.4.11/drivers/spi/spi-eq3-gpio.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/spi/spi-eq3-gpio.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,36 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <mach/mxs.h>
+#include <mach/eq3-ccu2.h>
+
+#define spidelay(_x)	ndelay(_x)
+
+#define DRIVER_NAME		"eq3spi"
+#define	SPI_MISO_GPIO		IC200_MISO_GPIO
+#define	SPI_MOSI_GPIO		IC200_MOSI_GPIO
+#define	SPI_SCK_GPIO		IC200_SCK_GPIO
+#define SPI_N_CHIPSEL		SPI_GPIO_NO_CHIPSELECT
+
+#undef gpio_direction_output
+#undef gpio_direction_input
+
+#define gpio_direction_output(_gp, _mode) (0)
+#define gpio_direction_input(_gp) (0)
+
+#include "spi-gpio.c"
diff -Naur linux-3.4.11/drivers/spi/spi-gpio.c linux-HEAD/drivers/spi/spi-gpio.c
--- linux-3.4.11/drivers/spi/spi-gpio.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/spi/spi-gpio.c	2015-11-18 09:04:24.000000000 +0000
@@ -126,7 +126,9 @@
  * reaching even one Mbit/sec (except when we can inline bitops), so for now
  * we'll just assume we never need additional per-bit slowdowns.
  */
+#ifndef spidelay
 #define spidelay(nsecs)	do {} while (0)
+#endif
 
 #include "spi-bitbang-txrx.h"
 
@@ -279,7 +281,7 @@
 	/* NOTE:  SPI_*_GPIO symbols may reference "pdata" */
 
 	if (SPI_MOSI_GPIO != SPI_GPIO_NO_MOSI) {
-		value = spi_gpio_alloc(SPI_MOSI_GPIO, label, false);
+		value = spi_gpio_alloc(SPI_MOSI_GPIO, "SPI MOSI", false);
 		if (value)
 			goto done;
 	} else {
@@ -288,7 +290,7 @@
 	}
 
 	if (SPI_MISO_GPIO != SPI_GPIO_NO_MISO) {
-		value = spi_gpio_alloc(SPI_MISO_GPIO, label, true);
+		value = spi_gpio_alloc(SPI_MISO_GPIO, "SPI MISO", true);
 		if (value)
 			goto free_mosi;
 	} else {
@@ -296,7 +298,7 @@
 		*res_flags |= SPI_MASTER_NO_RX;
 	}
 
-	value = spi_gpio_alloc(SPI_SCK_GPIO, label, false);
+	value = spi_gpio_alloc(SPI_SCK_GPIO, "SPI SCK", false);
 	if (value)
 		goto free_miso;
 
diff -Naur linux-3.4.11/drivers/spi/spi-pxa2xx.c linux-HEAD/drivers/spi/spi-pxa2xx.c
--- linux-3.4.11/drivers/spi/spi-pxa2xx.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/spi/spi-pxa2xx.c	2015-11-18 09:04:24.000000000 +0000
@@ -35,6 +35,11 @@
 #include <asm/irq.h>
 #include <asm/delay.h>
 
+#ifndef CONFIG_ARCH_MMP
+static inline bool cpu_is_pxa168() {
+	return false;
+}
+#endif
 
 MODULE_AUTHOR("Stephen Street");
 MODULE_DESCRIPTION("PXA2xx SSP SPI Controller");
@@ -919,7 +924,12 @@
 
 static unsigned int ssp_get_clk_div(struct ssp_device *ssp, int rate)
 {
-	unsigned long ssp_clk = clk_get_rate(ssp->clk);
+	unsigned long ssp_clk;
+
+	if (WARN_ON(cpu_is_pxa168()))
+		return 0;
+
+	ssp_clk = clk_get_rate(ssp->clk);
 
 	if (ssp->type == PXA25x_SSP || ssp->type == CE4100_SSP)
 		return ((ssp_clk / (2 * rate) - 1) & 0xff) << 8;
@@ -1021,6 +1031,7 @@
 	/* Change speed and bit per word on a per transfer */
 	cr0 = chip->cr0;
 	if (transfer->speed_hz || transfer->bits_per_word) {
+		int		rc;
 
 		bits = chip->bits_per_word;
 		speed = chip->speed_hz;
@@ -1031,7 +1042,22 @@
 		if (transfer->bits_per_word)
 			bits = transfer->bits_per_word;
 
-		clk_div = ssp_get_clk_div(ssp, speed);
+		switch (drv_data->ssp_type) {
+		case PXA168_SSP:
+			rc = clk_set_rate(ssp->clk, speed);
+			if (rc < 0 && printk_ratelimit()) {
+				dev_warn(&message->spi->dev,
+					 "failed to set spi clock to %lu: %d\n",
+					 (unsigned long)speed, rc);
+				return;
+			}
+			clk_div = 0;
+			break;
+
+		default:
+			clk_div = ssp_get_clk_div(ssp, speed);
+			break;
+		}
 
 		if (bits <= 8) {
 			drv_data->n_bytes = 1;
@@ -1369,7 +1395,24 @@
 		}
 	}
 
-	clk_div = ssp_get_clk_div(ssp, spi->max_speed_hz);
+	switch (drv_data->ssp_type) {
+	case PXA168_SSP: {
+		int	rc;
+		rc = clk_set_rate(ssp->clk, spi->max_speed_hz);
+		if (rc < 0 && printk_ratelimit()) {
+			dev_warn(&spi->dev,
+				 "failed to set spi clock to %lu: %d\n",
+				 (unsigned long)spi->max_speed_hz, rc);
+			return rc;
+		}
+		clk_div = 0;
+		break;
+	}
+	default:
+		clk_div = ssp_get_clk_div(ssp, spi->max_speed_hz);
+		break;
+	}
+
 	chip->speed_hz = spi->max_speed_hz;
 
 	chip->cr0 = clk_div
@@ -1383,16 +1426,28 @@
 			| (((spi->mode & SPI_CPOL) != 0) ? SSCR1_SPO : 0);
 
 	/* NOTE:  PXA25x_SSP _could_ use external clocking ... */
-	if (!pxa25x_ssp_comp(drv_data))
-		dev_dbg(&spi->dev, "%ld Hz actual, %s\n",
-			clk_get_rate(ssp->clk)
-				/ (1 + ((chip->cr0 & SSCR0_SCR(0xfff)) >> 8)),
-			chip->enable_dma ? "DMA" : "PIO");
-	else
+	switch (drv_data->ssp_type) {
+	case PXA25x_SSP:
+	case CE4100_SSP:
 		dev_dbg(&spi->dev, "%ld Hz actual, %s\n",
 			clk_get_rate(ssp->clk) / 2
 				/ (1 + ((chip->cr0 & SSCR0_SCR(0x0ff)) >> 8)),
 			chip->enable_dma ? "DMA" : "PIO");
+		break;
+
+	case PXA168_SSP:
+		dev_dbg(&spi->dev, "%ld Hz actual, %s\n",
+			clk_get_rate(ssp->clk),
+			chip->enable_dma ? "DMA" : "PIO");
+		break;
+
+	default:
+		dev_dbg(&spi->dev, "%ld Hz actual, %s\n",
+			clk_get_rate(ssp->clk)
+				/ (1 + ((chip->cr0 & SSCR0_SCR(0xfff)) >> 8)),
+			chip->enable_dma ? "DMA" : "PIO");
+		break;
+	}
 
 	if (spi->bits_per_word <= 8) {
 		chip->n_bytes = 1;
@@ -1533,6 +1588,7 @@
 	struct spi_master *master;
 	struct driver_data *drv_data;
 	struct ssp_device *ssp;
+	uint32_t clk_div;
 	int status;
 
 	platform_info = dev->platform_data;
@@ -1625,14 +1681,24 @@
 	}
 
 	/* Enable SOC clock */
-	clk_enable(ssp->clk);
+	clk_prepare_enable(ssp->clk);
 
 	/* Load default SSP configuration */
 	write_SSCR0(0, drv_data->ioaddr);
 	write_SSCR1(SSCR1_RxTresh(RX_THRESH_DFLT) |
 				SSCR1_TxTresh(TX_THRESH_DFLT),
 				drv_data->ioaddr);
-	write_SSCR0(SSCR0_SCR(2)
+
+	switch (drv_data->ssp_type) {
+	case PXA168_SSP:
+		clk_div = 0;
+		break;
+	default:
+		clk_div = SSCR0_SCR(2);
+		break;
+	}
+
+	write_SSCR0(clk_div
 			| SSCR0_Motorola
 			| SSCR0_DataSize(8),
 			drv_data->ioaddr);
@@ -1666,7 +1732,7 @@
 	destroy_queue(drv_data);
 
 out_error_clock_enabled:
-	clk_disable(ssp->clk);
+	clk_disable_unprepare(ssp->clk);
 
 out_error_dma_alloc:
 	if (drv_data->tx_channel != -1)
@@ -1709,7 +1775,7 @@
 
 	/* Disable the SSP at the peripheral and SOC level */
 	write_SSCR0(0, drv_data->ioaddr);
-	clk_disable(ssp->clk);
+	clk_disable_unprepare(ssp->clk);
 
 	/* Release DMA */
 	if (drv_data->master_info->enable_dma) {
@@ -1753,7 +1819,7 @@
 	if (status != 0)
 		return status;
 	write_SSCR0(0, drv_data->ioaddr);
-	clk_disable(ssp->clk);
+	clk_disable_unprepare(ssp->clk);
 
 	return 0;
 }
@@ -1772,7 +1838,7 @@
 			DRCMR_MAPVLD | drv_data->tx_channel;
 
 	/* Enable the SSP clock */
-	clk_enable(ssp->clk);
+	clk_prepare_enable(ssp->clk);
 
 	/* Start the queue running */
 	status = start_queue(drv_data);
diff -Naur linux-3.4.11/drivers/tty/serial/Kconfig linux-HEAD/drivers/tty/serial/Kconfig
--- linux-3.4.11/drivers/tty/serial/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/tty/serial/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -380,6 +380,10 @@
 	  your boot loader (lilo or loadlin) about how to pass options to the
 	  kernel at boot time.)
 
+config SERIAL_RS485_PXA
+       bool "rs485 driver of pxa hardware"
+       depends on GPIOLIB && ARCH_PXA
+
 config SERIAL_SA1100
 	bool "SA1100 serial port support"
 	depends on ARM && ARCH_SA1100
diff -Naur linux-3.4.11/drivers/tty/serial/Makefile linux-HEAD/drivers/tty/serial/Makefile
--- linux-3.4.11/drivers/tty/serial/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/tty/serial/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -21,6 +21,7 @@
 obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
 obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
 obj-$(CONFIG_SERIAL_PXA) += pxa.o
+obj-$(CONFIG_SERIAL_RS485_PXA) += rs485-pxa.o
 obj-$(CONFIG_SERIAL_PNX8XXX) += pnx8xxx_uart.o
 obj-$(CONFIG_SERIAL_SA1100) += sa1100.o
 obj-$(CONFIG_SERIAL_BCM63XX) += bcm63xx_uart.o
diff -Naur linux-3.4.11/drivers/tty/serial/mxs-auart.c linux-HEAD/drivers/tty/serial/mxs-auart.c
--- linux-3.4.11/drivers/tty/serial/mxs-auart.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/tty/serial/mxs-auart.c	2015-11-18 09:04:24.000000000 +0000
@@ -14,10 +14,15 @@
  * http://www.gnu.org/copyleft/gpl.html
  */
 
+#if defined(CONFIG_SERIAL_MXS_AUART_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/console.h>
+#include <linux/sysrq.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/slab.h>
@@ -90,14 +95,27 @@
 #define AUART_LINECTRL_PEN			(1 << 1)
 #define AUART_LINECTRL_BRK			(1 << 0)
 
+#define AUART_INTR_ABDIEN			(1 << 27)
+#define AUART_INTR_OEIEN			(1 << 26)
+#define AUART_INTR_BEIEN			(1 << 25)
+#define AUART_INTR_PEIEN			(1 << 24)
+#define AUART_INTR_FEIEN			(1 << 23)
 #define AUART_INTR_RTIEN			(1 << 22)
 #define AUART_INTR_TXIEN			(1 << 21)
 #define AUART_INTR_RXIEN			(1 << 20)
 #define AUART_INTR_CTSMIEN			(1 << 17)
+#define AUART_INTR_ABDIS			(1 << 11)
+#define AUART_INTR_OEIS				(1 << 10)
+#define AUART_INTR_BEIS				(1 << 9)
+#define AUART_INTR_PEIS				(1 << 8)
+#define AUART_INTR_FEIS				(1 << 7)
 #define AUART_INTR_RTIS				(1 << 6)
 #define AUART_INTR_TXIS				(1 << 5)
 #define AUART_INTR_RXIS				(1 << 4)
+#define AUART_INTR_DSRMIS			(1 << 3)
+#define AUART_INTR_DCDMIS			(1 << 2)
 #define AUART_INTR_CTSMIS			(1 << 1)
+#define AUART_INTR_RIMIS			(1 << 0)
 
 #define AUART_STAT_BUSY				(1 << 29)
 #define AUART_STAT_CTS				(1 << 28)
@@ -117,8 +135,6 @@
 	unsigned int flags;
 	unsigned int ctrl;
 
-	unsigned int irq;
-
 	struct clk *clk;
 	struct device *dev;
 };
@@ -127,39 +143,49 @@
 
 #define to_auart_port(u) container_of(u, struct mxs_auart_port, port)
 
+static inline void mxs_auart_stop_txie(struct uart_port *u)
+{
+	writel(AUART_INTR_TXIEN, u->membase + AUART_INTR_CLR);
+}
+
 static inline void mxs_auart_tx_chars(struct mxs_auart_port *s)
 {
 	struct circ_buf *xmit = &s->port.state->xmit;
 
-	while (!(readl(s->port.membase + AUART_STAT) &
-		 AUART_STAT_TXFF)) {
-		if (s->port.x_char) {
-			s->port.icount.tx++;
-			writel(s->port.x_char,
-				     s->port.membase + AUART_DATA);
-			s->port.x_char = 0;
-			continue;
-		}
-		if (!uart_circ_empty(xmit) && !uart_tx_stopped(&s->port)) {
-			s->port.icount.tx++;
-			writel(xmit->buf[xmit->tail],
-				     s->port.membase + AUART_DATA);
-			xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
-		} else
+	if (s->port.x_char) {
+		writeb(s->port.x_char, s->port.membase + AUART_DATA);
+		s->port.icount.tx++;
+		s->port.x_char = 0;
+		return;
+	}
+
+	if (uart_tx_stopped(&s->port)) {
+		mxs_auart_stop_tx(&s->port);
+		return;
+	}
+
+	if (uart_circ_empty(xmit)) {
+		mxs_auart_stop_txie(&s->port);
+		return;
+	}
+
+	while (!(readl(s->port.membase + AUART_STAT) & AUART_STAT_TXFF)) {
+		s->port.icount.tx++;
+		writeb(xmit->buf[xmit->tail], s->port.membase + AUART_DATA);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+
+		if (uart_circ_empty(xmit))
 			break;
 	}
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
 		uart_write_wakeup(&s->port);
 
-	if (uart_circ_empty(&(s->port.state->xmit)))
-		writel(AUART_INTR_TXIEN,
-			     s->port.membase + AUART_INTR_CLR);
-	else
-		writel(AUART_INTR_TXIEN,
-			     s->port.membase + AUART_INTR_SET);
 
-	if (uart_tx_stopped(&s->port))
-		mxs_auart_stop_tx(&s->port);
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&s->port);
+
+	if (uart_circ_empty(xmit))
+		mxs_auart_stop_txie(&s->port);
 }
 
 static void mxs_auart_rx_char(struct mxs_auart_port *s)
@@ -367,6 +393,13 @@
 	ctrl |= AUART_LINECTRL_BAUD_DIVFRAC(div & 0x3F);
 	ctrl |= AUART_LINECTRL_BAUD_DIVINT(div >> 6);
 
+	uart_update_timeout(u, termios->c_cflag, baud);
+
+	if (UART_ENABLE_MS(u, termios->c_cflag))
+		writel(AUART_INTR_CTSMIEN, u->membase + AUART_INTR_SET);
+	else
+		writel(AUART_INTR_CTSMIEN, u->membase + AUART_INTR_CLR);
+
 	writel(ctrl, u->membase + AUART_LINECTRL);
 	writel(ctrl2, u->membase + AUART_CTRL2);
 
@@ -381,11 +414,15 @@
 
 	istatus = istat = readl(s->port.membase + AUART_INTR);
 
+	writel(istatus & 0xffffu, s->port.membase + AUART_INTR_CLR);
+
 	if (istat & AUART_INTR_CTSMIS) {
 		uart_handle_cts_change(&s->port, stat & AUART_STAT_CTS);
 		writel(AUART_INTR_CTSMIS,
 				s->port.membase + AUART_INTR_CLR);
 		istat &= ~AUART_INTR_CTSMIS;
+
+		wake_up_interruptible(&s->port.state->port.delta_msr_wait);
 	}
 
 	if (istat & (AUART_INTR_RTIS | AUART_INTR_RXIS)) {
@@ -398,12 +435,6 @@
 		istat &= ~AUART_INTR_TXIS;
 	}
 
-	writel(istatus & (AUART_INTR_RTIS
-		| AUART_INTR_TXIS
-		| AUART_INTR_RXIS
-		| AUART_INTR_CTSMIS),
-			s->port.membase + AUART_INTR_CLR);
-
 	return IRQ_HANDLED;
 }
 
@@ -412,6 +443,12 @@
 	int i;
 	unsigned int reg;
 
+	while ((readl(u->membase + AUART_CTRL2) & AUART_CTRL2_UARTEN) &&
+	       (readl(u->membase + AUART_STAT) & AUART_STAT_BUSY))
+		schedule();
+
+	writel(AUART_CTRL2_TXE, u->membase + AUART_CTRL0_CLR);
+
 	writel(AUART_CTRL0_SFTRST, u->membase + AUART_CTRL0_CLR);
 
 	for (i = 0; i < 10000; i++) {
@@ -426,15 +463,23 @@
 static int mxs_auart_startup(struct uart_port *u)
 {
 	struct mxs_auart_port *s = to_auart_port(u);
+	int rc;
 
 	clk_prepare_enable(s->clk);
 
 	writel(AUART_CTRL0_CLKGATE, u->membase + AUART_CTRL0_CLR);
 
-	writel(AUART_CTRL2_UARTEN, u->membase + AUART_CTRL2_SET);
+	writel((0x7ff << 16), u->membase + AUART_CTRL0_CLR);
+	writel(3, u->membase + AUART_CTRL0_SET);
 
-	writel(AUART_INTR_RXIEN | AUART_INTR_RTIEN | AUART_INTR_CTSMIEN,
-			u->membase + AUART_INTR);
+	/* disable + clear interrupts */
+	writel(0, u->membase + AUART_INTR);
+
+	rc = request_irq(u->irq, mxs_auart_irq_handle, 0, dev_name(s->dev), s);
+	if (rc)
+		goto out;
+
+	writel(AUART_CTRL2_UARTEN, u->membase + AUART_CTRL2_SET);
 
 	/*
 	 * Enable fifo so all four bytes of a DMA word are written to
@@ -442,7 +487,20 @@
 	 */
 	writel(AUART_LINECTRL_FEN, u->membase + AUART_LINECTRL_SET);
 
-	return 0;
+	writel(AUART_INTR_OEIEN |
+	       AUART_INTR_BEIEN |
+	       AUART_INTR_FEIEN |
+	       AUART_INTR_RTIEN |
+	       AUART_INTR_RXIEN,
+	       u->membase + AUART_INTR);
+
+	rc = 0;
+
+out:
+	if (rc < 0)
+		clk_disable(s->clk);
+
+	return rc;
 }
 
 static void mxs_auart_shutdown(struct uart_port *u)
@@ -456,12 +514,13 @@
 	writel(AUART_INTR_RXIEN | AUART_INTR_RTIEN | AUART_INTR_CTSMIEN,
 			u->membase + AUART_INTR_CLR);
 
+	free_irq(u->irq, s);
 	clk_disable_unprepare(s->clk);
 }
 
 static unsigned int mxs_auart_tx_empty(struct uart_port *u)
 {
-	if (readl(u->membase + AUART_STAT) & AUART_STAT_TXFE)
+	if (!(readl(u->membase + AUART_STAT) & AUART_STAT_BUSY))
 		return TIOCSER_TEMT;
 	else
 		return 0;
@@ -474,11 +533,16 @@
 	/* enable transmitter */
 	writel(AUART_CTRL2_TXE, u->membase + AUART_CTRL2_SET);
 
+	/* clear + enable TX interrupts */
+	writel(AUART_INTR_TXIS,  s->port.membase + AUART_INTR_CLR);
+	writel(AUART_INTR_TXIEN, s->port.membase + AUART_INTR_SET);
+
 	mxs_auart_tx_chars(s);
 }
 
 static void mxs_auart_stop_tx(struct uart_port *u)
 {
+	mxs_auart_stop_txie(u);
 	writel(AUART_CTRL2_TXE, u->membase + AUART_CTRL2_CLR);
 }
 
@@ -499,7 +563,7 @@
 
 static void mxs_auart_enable_ms(struct uart_port *port)
 {
-	/* just empty */
+	writel(AUART_INTR_CTSMIEN, port->membase + AUART_INTR_SET);
 }
 
 static struct uart_ops mxs_auart_ops = {
@@ -664,7 +728,7 @@
 
 static struct uart_driver auart_driver = {
 	.owner		= THIS_MODULE,
-	.driver_name	= "ttyAPP",
+	.driver_name	= "iMX AUART",
 	.dev_name	= "ttyAPP",
 	.major		= 0,
 	.minor		= 0,
@@ -708,15 +772,12 @@
 	s->port.uartclk = clk_get_rate(s->clk);
 	s->port.type = PORT_IMX;
 	s->port.dev = s->dev = get_device(&pdev->dev);
+	s->port.flags = UPF_IOREMAP;
+	s->port.irq = platform_get_irq(pdev, 0);
 
 	s->flags = 0;
 	s->ctrl = 0;
 
-	s->irq = platform_get_irq(pdev, 0);
-	s->port.irq = s->irq;
-	ret = request_irq(s->irq, mxs_auart_irq_handle, 0, dev_name(&pdev->dev), s);
-	if (ret)
-		goto out_free_clk;
 
 	platform_set_drvdata(pdev, s);
 
@@ -737,7 +798,7 @@
 
 out_free_irq:
 	auart_port[pdev->id] = NULL;
-	free_irq(s->irq, s);
+
 out_free_clk:
 	clk_put(s->clk);
 out_free:
@@ -755,7 +816,6 @@
 	auart_port[pdev->id] = NULL;
 
 	clk_put(s->clk);
-	free_irq(s->irq, s);
 	kfree(s);
 
 	return 0;
diff -Naur linux-3.4.11/drivers/tty/serial/pxa.c linux-HEAD/drivers/tty/serial/pxa.c
--- linux-3.4.11/drivers/tty/serial/pxa.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/tty/serial/pxa.c	2015-11-18 09:04:24.000000000 +0000
@@ -46,6 +46,10 @@
 #include <linux/slab.h>
 
 #define PXA_NAME_LEN		8
+#define DEV_MAJOR		204
+#define DEV_MINOR		5
+
+#include "rs485.h"
 
 struct uart_pxa_port {
 	struct uart_port        port;
@@ -55,8 +59,21 @@
 	unsigned int            lsr_break_flag;
 	struct clk		*clk;
 	char			name[PXA_NAME_LEN];
+
+#ifdef CONFIG_RS485
+	struct rs485_device	*rs485;
+#endif
 };
 
+static struct rs485_device *get_rs485(struct uart_pxa_port *up)
+{
+#ifdef CONFIG_RS485
+	return up->rs485;
+#else
+	return NULL;
+#endif
+}
+
 static inline unsigned int serial_in(struct uart_pxa_port *up, int offset)
 {
 	offset <<= 2;
@@ -85,6 +102,9 @@
 		up->ier &= ~UART_IER_THRI;
 		serial_out(up, UART_IER, up->ier);
 	}
+
+	if (get_rs485(up))
+		rs485_send_event(get_rs485(up), RS485_EVENT_SHUTDOWN);
 }
 
 static void serial_pxa_stop_rx(struct uart_port *port)
@@ -181,12 +201,19 @@
 	serial_out(up, UART_IER, up->ier);
 }
 
+static void enable_rs485_xmit(struct rs485_device *rs485)
+{
+	if (rs485)
+		rs485_send_event(rs485, RS485_EVENT_XMIT);
+}
+
 static void transmit_chars(struct uart_pxa_port *up)
 {
 	struct circ_buf *xmit = &up->port.state->xmit;
 	int count;
 
 	if (up->port.x_char) {
+		enable_rs485_xmit(get_rs485(up));
 		serial_out(up, UART_TX, up->port.x_char);
 		up->port.icount.tx++;
 		up->port.x_char = 0;
@@ -197,14 +224,17 @@
 		return;
 	}
 
-	count = up->port.fifosize / 2;
-	do {
+	count = up->port.fifosize;
+
+	enable_rs485_xmit(get_rs485(up));
+	while ((serial_in(up, UART_LSR) & UART_LSR_THRE) &&
+	       --count > 0) {
 		serial_out(up, UART_TX, xmit->buf[xmit->tail]);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
 		up->port.icount.tx++;
 		if (uart_circ_empty(xmit))
 			break;
-	} while (--count > 0);
+	};
 
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
 		uart_write_wakeup(&up->port);
@@ -358,11 +388,24 @@
 }
 #endif
 
+static int __maybe_unused serial_pxa_rs485_child_match(struct device *dev,
+						       void *data)
+{
+	struct platform_device	*pdev;
+
+	if (dev->bus != &platform_bus_type)
+		return 0;
+
+	pdev = to_platform_device(dev);
+	return strcmp(pdev->name, "rs485") == 0;
+}
+
 static int serial_pxa_startup(struct uart_port *port)
 {
 	struct uart_pxa_port *up = (struct uart_pxa_port *)port;
 	unsigned long flags;
 	int retval;
+	struct device *rs485_dev;
 
 	if (port->line == 3) /* HWUART */
 		up->mcr |= UART_MCR_AFE;
@@ -378,6 +421,26 @@
 	if (retval)
 		return retval;
 
+#ifdef CONFIG_RS485
+	rs485_dev = device_find_child(port->dev, NULL,
+				      serial_pxa_rs485_child_match);
+
+	if (rs485_dev)
+		up->rs485 = rs485_attach(to_platform_device(rs485_dev),
+					 up->port.membase + (UART_LSR << 2));
+	else
+		up->rs485 = NULL;
+
+	if (IS_ERR(up->rs485)) {
+		retval = PTR_ERR(up->rs485);
+		dev_warn(port->dev, "failed to attach rs485 device: %d\n",
+			 retval);
+
+		free_irq(up->port.irq, up);
+		return retval;
+	}
+#endif
+
 	/*
 	 * Clear the FIFO buffers and disable them.
 	 * (they will be reenabled in set_termios())
@@ -429,6 +492,9 @@
 	struct uart_pxa_port *up = (struct uart_pxa_port *)port;
 	unsigned long flags;
 
+	if (get_rs485(up))
+		rs485_detach(get_rs485(up));
+
 	free_irq(up->port.irq, up);
 
 	/*
@@ -515,6 +581,9 @@
 	 */
 	uart_update_timeout(port, termios->c_cflag, baud);
 
+	if (get_rs485(up))
+		rs485_update_timeout(get_rs485(up), termios->c_cflag, baud);
+
 	up->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;
 	if (termios->c_iflag & INPCK)
 		up->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;
@@ -713,7 +782,7 @@
 }
 
 static struct console serial_pxa_console = {
-	.name		= "ttyS",
+	.name		= "ttySA",
 	.write		= serial_pxa_console_write,
 	.device		= uart_console_device,
 	.setup		= serial_pxa_console_setup,
@@ -750,9 +819,9 @@
 static struct uart_driver serial_pxa_reg = {
 	.owner		= THIS_MODULE,
 	.driver_name	= "PXA serial",
-	.dev_name	= "ttyS",
-	.major		= TTY_MAJOR,
-	.minor		= 64,
+	.dev_name	= "ttySA",
+	.major		= DEV_MAJOR,
+	.minor		= DEV_MINOR,
 	.nr		= 4,
 	.cons		= PXA_CONSOLE,
 };
diff -Naur linux-3.4.11/drivers/tty/serial/rs485.h linux-HEAD/drivers/tty/serial/rs485.h
--- linux-3.4.11/drivers/tty/serial/rs485.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/tty/serial/rs485.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,45 @@
+/*	--*- c -*--
+ * Copyright (C) 2009 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_LINUX_DRIVERS_SERIAL_RS485_H
+#define H_LINUX_DRIVERS_SERIAL_RS485_H
+
+#include <linux/kernel.h>
+
+enum rs485_event {
+	RS485_EVENT_RESET,
+	RS485_EVENT_XMIT,
+	RS485_EVENT_SHUTDOWN,
+
+	RS485_EVENT_INTERNAL = 0x100,
+	RS485_EVENT_EMPTY,
+	RS485_EVENT_TIMEOUT,
+};
+
+struct rs485_device;
+
+struct platform_device;
+struct rs485_device *	rs485_attach(struct platform_device *,
+				     uint8_t __iomem *lsr);
+void			rs485_detach(struct rs485_device *);
+void			rs485_send_event(struct rs485_device *,
+					 enum rs485_event event);
+void			rs485_update_timeout(struct rs485_device *,
+					     unsigned int cflag,
+					     unsigned int baud);
+
+
+#endif	/* H_LINUX_DRIVERS_SERIAL_RS485_H */
diff -Naur linux-3.4.11/drivers/tty/serial/rs485-pxa.c linux-HEAD/drivers/tty/serial/rs485-pxa.c
--- linux-3.4.11/drivers/tty/serial/rs485-pxa.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/tty/serial/rs485-pxa.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,414 @@
+/*	--*- c -*--
+ * Copyright (C) 2009 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "rs485.h"
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+
+#include <linux/serial_rs485.h>
+#include <linux/serial_reg.h>
+
+#include <asm/termbits.h>
+#include <asm/io.h>
+
+#include <mach/regs-ost.h>
+#include <mach/regs-uart.h>
+
+enum rs485_state {
+	RS485_STATE_RECV,
+	RS485_STATE_XMIT,
+	RS485_STATE_LAST,
+};
+
+struct rs485_device {
+	unsigned int		gpio_txe;
+	unsigned int		gpio_rxen;
+	unsigned int		irq;
+
+	struct kref		kref;
+	enum rs485_state	state;
+
+	unsigned int		timer;
+	uint32_t __iomem	*oscr;
+	uint32_t __iomem	*osmr;
+	uint32_t __iomem	*omcr;
+
+	uint8_t __iomem		*lsr;	       /* LSR register */
+	unsigned int		char_duration; /* character length in 1 MHz clocks */
+
+	struct device		*dev;
+	spinlock_t		lock;
+};
+
+static irqreturn_t rs485_timer_irq(int irq, void *rs485_v)
+{
+	struct rs485_device		*rs485 = rs485_v;
+	unsigned long			flags;
+	irqreturn_t			rc = IRQ_NONE;
+
+	/* TODO: what's with FEr#99? */
+
+
+	/* lock whole operation to workaround FEr#25 */
+	spin_lock_irqsave(&rs485->lock, flags);
+
+	if (!(OSSR & (1 << rs485->timer)))
+		goto out;
+
+	OSSR = (1 << rs485->timer);
+
+	switch (rs485->state) {
+	case RS485_STATE_LAST:
+		if (readb(rs485->lsr) & UART_LSR_TEMT)
+			rs485_send_event(rs485, RS485_EVENT_TIMEOUT);
+		break;
+
+	default:
+		break;
+	}
+
+	rc = IRQ_HANDLED;
+
+out:
+	spin_unlock_irqrestore(&rs485->lock, flags);
+	return rc;
+}
+
+static void rs485_release(struct kref *kref)
+{
+	struct rs485_device	*rs485;
+
+	rs485 = container_of(kref, struct rs485_device, kref);
+
+	if (rs485->irq)
+		free_irq(rs485->irq, rs485);
+
+	if (rs485->gpio_txe) {
+		gpio_direction_output(rs485->gpio_txe, 0);
+		gpio_free(rs485->gpio_txe);
+	}
+
+	if (rs485->gpio_rxen) {
+		gpio_direction_output(rs485->gpio_rxen, 1);
+		gpio_free(rs485->gpio_rxen);
+	}
+
+	kfree(rs485);
+}
+
+static int __devinit rs485_probe(struct platform_device *pdev)
+{
+	struct rs485_platform_data	*pdata = pdev->dev.platform_data;
+	int				rc;
+	unsigned int			irq;
+	struct rs485_device		*rs485;
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform data\n");
+		return -ENXIO;
+	}
+
+	if (pdata->timer < 4 || pdata->timer > 11) {
+		dev_err(&pdev->dev, "invalid timer %d\n", pdata->timer);
+		return -EINVAL;
+	}
+
+	rs485 = kzalloc(sizeof *rs485, GFP_KERNEL);
+	if (!rs485) {
+		dev_err(&pdev->dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&rs485->lock);
+	kref_init(&rs485->kref);
+	rs485->dev   = &pdev->dev;
+	rs485->timer = pdata->timer;
+
+	rs485->oscr  = (void __iomem *)(io_p2v(0x40a00040 + (rs485->timer - 4) * 4));
+	rs485->osmr  = (void __iomem *)(io_p2v(0x40a00080 + (rs485->timer - 4) * 4));
+	rs485->omcr  = (void __iomem *)(io_p2v(0x40a000c0 + (rs485->timer - 4) * 4));
+
+	BUG_ON(gpio_cansleep(pdata->gpio_txe));
+	BUG_ON(gpio_cansleep(pdata->gpio_rxen));
+
+	rc = gpio_request(pdata->gpio_txe, "rs485 TXE");
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to request rs485 TXE gpio\n");
+		goto err;
+	}
+	rs485->gpio_txe = pdata->gpio_txe;
+
+	rc = gpio_request(pdata->gpio_rxen, "rs485 nRXE");
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to request rs485 nRXE gpio\n");
+		goto err;
+	}
+	rs485->gpio_rxen = pdata->gpio_rxen;
+
+	irq = platform_get_irq(pdev, 0);
+	rc  = request_irq(irq, rs485_timer_irq, IRQF_SHARED, "rs485 timer", rs485);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to request irq for rs485 timer: %d\n",
+			rc);
+		goto err;
+	}
+	rs485->irq = irq;
+
+	gpio_direction_output(rs485->gpio_txe,  0);
+	gpio_direction_output(rs485->gpio_rxen, 0);
+
+	platform_set_drvdata(pdev, rs485);
+
+	dev_info(&pdev->dev, "registered driver with gpios %d & %d\n",
+		 rs485->gpio_txe, rs485->gpio_rxen);
+	return 0;
+
+err:
+	kref_put(&rs485->kref, rs485_release);
+
+	return rc;
+}
+
+struct rs485_device * rs485_attach(struct platform_device *pdev,
+				   uint8_t __iomem *lsr)
+{
+	struct rs485_device		*rs485 = platform_get_drvdata(pdev);
+
+	dev_dbg(&pdev->dev, "%s(%p)\n", __func__, lsr);
+	if (!rs485) {
+		dev_err(&pdev->dev, "no rs485 device available");
+		return ERR_PTR(-ENXIO);
+	}
+
+	/* TODO: locking */
+	if (rs485->lsr && rs485->lsr != lsr) {
+		dev_warn(&pdev->dev, "rs485 already used with other LSR (%p vs %p)\n",
+			 rs485->lsr, lsr);
+		return ERR_PTR(-EBUSY);
+	}
+	rs485->lsr = lsr;
+
+	kref_get(&rs485->kref);
+	return rs485;
+
+}
+EXPORT_SYMBOL_GPL(rs485_attach);
+
+void rs485_detach(struct rs485_device *rs485)
+{
+	dev_dbg(rs485->dev, "%s()\n", __func__);
+
+	rs485_send_event(rs485, RS485_EVENT_RESET);
+	writel(0, rs485->omcr);
+
+	kref_put(&rs485->kref, rs485_release);
+
+	/* TODO: reset of LSR? */
+}
+EXPORT_SYMBOL_GPL(rs485_detach);
+
+static void rs485_enable_timer(struct rs485_device *rs485)
+{
+	writel((4 << 0) |	/* 1 MHz */
+	       (1 << 3) |	/* Reset OSCR on match*/
+	       (1 << 6) |	/* periodic timer */
+	       (1 << 7),	/* match against OSCRx */
+	       rs485->omcr);
+
+	writel(rs485->char_duration,
+	       rs485->osmr);
+	writel(0, rs485->oscr);
+
+	OIER |=  (1 << rs485->timer);
+	OSSR  =  (1 << rs485->timer);
+}
+
+static void rs485_disable_timer(struct rs485_device *rs485)
+{
+	writel(0, rs485->omcr);
+
+	OIER &= ~(1 << rs485->timer);
+	OSSR  =  (1 << rs485->timer);
+}
+
+void rs485_send_event(struct rs485_device *rs485,
+		      enum rs485_event const event)
+{
+	enum rs485_state	new_state;
+	unsigned long		flags;
+
+	if (!(event & RS485_EVENT_INTERNAL))
+		spin_lock_irqsave(&rs485->lock, flags);
+
+	new_state = rs485->state;
+	switch (event) {
+	case RS485_EVENT_RESET:
+		new_state = RS485_STATE_RECV;
+		break;
+
+	case RS485_EVENT_XMIT:
+		new_state = RS485_STATE_XMIT;
+		break;
+
+	case RS485_EVENT_SHUTDOWN:
+		switch (rs485->state) {
+		case RS485_STATE_XMIT:
+		case RS485_STATE_LAST:
+			if (readb(rs485->lsr) & UART_LSR_TEMT)
+				new_state = RS485_STATE_RECV;
+			else
+				new_state = RS485_STATE_LAST;
+			break;
+		default:
+			break;
+		}
+		break;
+
+	case RS485_EVENT_TIMEOUT:
+		BUG_ON(rs485->state != RS485_STATE_LAST );
+		new_state = RS485_STATE_RECV;
+		break;
+
+	default:
+		BUG();
+	}
+
+	if (rs485->state == new_state)
+		goto out;
+
+	dev_dbg(rs485->dev, "state %d -> %d (%d)\n", rs485->state, new_state, event);
+
+	switch (new_state) {
+	case RS485_STATE_RECV:
+		rs485_disable_timer(rs485);
+
+		gpio_set_value(rs485->gpio_rxen, 0);
+		gpio_set_value(rs485->gpio_txe,  0);
+		break;
+
+	case RS485_STATE_XMIT:
+		switch (rs485->state) {
+		case RS485_STATE_RECV:
+			/* RS485_STATE_XMIT can not happen here */
+			gpio_set_value(rs485->gpio_rxen, 1);
+			gpio_set_value(rs485->gpio_txe,  1);
+			break;
+		default:
+			/* comes back from LAST */
+			rs485_disable_timer(rs485);
+			break;
+		}
+
+		break;
+
+	case RS485_STATE_LAST:
+		switch (rs485->state) {
+		case RS485_STATE_XMIT:
+			rs485_enable_timer(rs485);
+			break;
+		default:
+			break;
+		}
+		break;
+	}
+
+	rs485->state = new_state;
+
+out:
+	if (!(event & RS485_EVENT_INTERNAL))
+		spin_unlock_irqrestore(&rs485->lock, flags);
+
+}
+EXPORT_SYMBOL_GPL(rs485_send_event);
+
+
+void rs485_update_timeout(struct rs485_device *rs485,
+			  unsigned int cflag, unsigned int baud)
+{
+	unsigned int bits;
+
+	/* byte size and parity */
+	switch (cflag & CSIZE) {
+	case CS5:
+		bits = 7;
+		break;
+	case CS6:
+		bits = 8;
+		break;
+	case CS7:
+		bits = 9;
+		break;
+	default:
+		bits = 10;
+		break; /* CS8 */
+	}
+
+	if (cflag & CSTOPB)
+		bits++;
+	if (cflag & PARENB)
+		bits++;
+
+	rs485->char_duration = DIV_ROUND_UP(1000000 * bits, baud);
+
+	dev_dbg(rs485->dev, "set char_duration to %u (%u bits, %u baud)\n",
+		rs485->char_duration, bits, baud);
+}
+EXPORT_SYMBOL_GPL(rs485_update_timeout);
+
+static int __devexit rs485_remove(struct platform_device *pdev)
+{
+	struct rs485_device		*rs485 = platform_get_drvdata(pdev);
+
+	kref_put(&rs485->kref, rs485_release);
+
+	return 0;
+}
+
+static struct platform_driver		rs485_driver = {
+	.probe		= rs485_probe,
+	.remove		= __devexit_p(rs485_remove),
+
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "rs485"
+	}
+};
+MODULE_ALIAS("platform:rs485");
+
+static int __init rs485_init(void)
+{
+	int		rc;
+
+	rc = platform_driver_register(&rs485_driver);
+	if (rc < 0) {
+		pr_err("error %d while registering rs485 driver\n", rc);
+		return rc;
+	}
+
+	return 0;
+}
+
+static void __exit rs485_exit(void)
+{
+	platform_driver_unregister(&rs485_driver);
+}
+
+module_init(rs485_init);
+module_exit(rs485_exit);
+MODULE_LICENSE("GPL");
diff -Naur linux-3.4.11/drivers/usb/gadget/fsl_mxc_udc.c linux-HEAD/drivers/usb/gadget/fsl_mxc_udc.c
--- linux-3.4.11/drivers/usb/gadget/fsl_mxc_udc.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/gadget/fsl_mxc_udc.c	2015-11-18 09:04:24.000000000 +0000
@@ -110,7 +110,7 @@
 	}
 }
 
-void fsl_udc_clk_release(void)
+void fsl_udc_clk_release(struct platform_device *pdev)
 {
 	if (mxc_usb_clk) {
 		clk_disable(mxc_usb_clk);
diff -Naur linux-3.4.11/drivers/usb/gadget/fsl_mxs_udc.c linux-HEAD/drivers/usb/gadget/fsl_mxs_udc.c
--- linux-3.4.11/drivers/usb/gadget/fsl_mxs_udc.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/usb/gadget/fsl_mxs_udc.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,263 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/fsl_devices.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/usb/gadget.h>
+
+#include <mach/mxs.h>
+#include <mach/common.h>
+#include <mach/mxs_ehci.h>
+
+#include "fsl_usb2_udc.h"
+
+struct mxs_udc_device {
+	struct mxs_usb_phy			*phy;
+	struct mxs_usb_phy_user			phy_user;
+	struct fsl_usb2_platform_data const	*pdata;
+	int					wakeup_irq;
+};
+
+inline static void mxs_writel(unsigned int val,
+			      struct mxs_udc_device *udc,
+			      unsigned int reg)
+{
+	mxs_ehci_writel(val, udc->pdata->regs + reg);
+}
+
+inline static unsigned int mxs_readl(struct mxs_udc_device *udc,
+				     unsigned int reg)
+{
+	return readl(udc->pdata->regs + reg);
+}
+
+static irqreturn_t mxs_udc_wakeup_irq(int irq, void *udc_v)
+{
+	struct mxs_udc_device	*udc = udc_v;
+	uint32_t		reg_otgsc;
+	uint32_t		reg_ctrl;
+
+	reg_otgsc = mxs_readl(udc, 0x184);
+	reg_ctrl  = readl(udc->phy->addr + MXS_USBPHY_CTRL);
+
+	trace_printk("OTGSC=%08x, CTRL=%08x\n",
+		     reg_otgsc, reg_ctrl);
+
+#if 0
+	if ((reg_ctrl & (MXS_USBPHY_CTRL_RESUME_IRQ |
+			 MXS_USBPHY_CTRL_WAKEUP_IRQ)) &&
+	    (reg_otgsc & ((1u << 8) |
+			  (1u << )))) ;
+#endif
+	writel(reg_ctrl & (MXS_USBPHY_CTRL_RESUME_IRQ |
+			   MXS_USBPHY_CTRL_WAKEUP_IRQ),
+	       udc->phy->addr + MXS_USBPHY_CTRL_clr);
+
+	return IRQ_HANDLED;
+}
+
+static int mxs_udc_init_clk(struct device *dev, char const *name,
+			    struct clk **dst_clk)
+{
+	struct clk	*c;
+	int		rc;
+
+	if (!name) {
+		c  = NULL;
+		rc = 0;
+	} else {
+		c = clk_get(dev, name);
+
+		if (IS_ERR(c)) {
+			rc = PTR_ERR(c);
+			c  = NULL;
+			goto out;
+		}
+
+		rc = clk_prepare_enable(c);
+		if (rc < 0) {
+			clk_put(c);
+			c = NULL;
+			goto out;
+		}
+	}
+
+out:
+	if (rc < 0) {
+		dev_err(dev, "failed to get '%s' clk: %d\n", name, rc);
+		*dst_clk = NULL;
+	} else
+		*dst_clk = c;
+
+	return rc;
+}
+
+int fsl_udc_clk_init(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data	*pdata = pdev->dev.platform_data;
+	struct mxs_udc_device		*udc = pdata->priv;
+	char const	*clk_name = NULL;
+	bool		have_phy_clk = false;
+	int		rc;
+
+	if (cpu_is_mx28()) {
+		switch (pdev->id) {
+		case 0:
+			clk_name = "usb0";
+			break;
+
+		default:
+			dev_err(&pdev->dev, "Unsupported controller %d\n",
+				pdev->id);
+			rc = -ENOENT;
+			goto out;
+		}
+	} else {
+		rc = -ENOENT;
+		goto out;
+	}
+
+	rc = mxs_udc_init_clk(&pdev->dev, clk_name, &pdata->clk);
+	if (rc < 0)
+		goto out;
+
+	rc = mxs_usb_phy_clk_enable(udc->phy);
+	if (rc < 0)
+		goto out;
+
+	have_phy_clk = true;
+
+	mxs_writel(0, udc, 0x148); /* disable interrupts */
+	rc = mxs_usb_phy_reset(udc->phy, 0);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to reset PHY: %d\n", rc);
+		goto out;
+	}
+
+	if (pdata->operating_mode == FSL_USB2_DR_DEVICE) {
+		mxs_usb_phy_enable(udc->phy);
+	}
+
+out:
+	if (rc < 0) {
+		if (have_phy_clk)
+			mxs_usb_phy_clk_disable(udc->phy);
+
+		if (pdata->clk) {
+			clk_disable_unprepare(pdata->clk);
+			clk_put(pdata->clk);
+		}
+
+		pdata->clk = NULL;
+	}
+
+	return rc;
+}
+
+void fsl_udc_clk_finalize(struct platform_device *pdev)
+{
+}
+
+void fsl_udc_clk_release(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data	*pdata = pdev->dev.platform_data;
+	struct mxs_udc_device		*udc = pdata->priv;
+
+	mxs_usb_phy_clk_disable(udc->phy);
+
+	if (pdata->clk) {
+		clk_disable_unprepare(pdata->clk);
+		clk_put(pdata->clk);
+	}
+
+	pdata->clk = NULL;
+}
+
+
+int fsl_udc_map_platform(struct platform_device *pdev)
+{
+	struct mxs_udc_device		*udc;
+	struct fsl_usb2_platform_data	*pdata = pdev->dev.platform_data;
+	int				rc;
+	int				wakeup_irq = -1;
+
+	BUG_ON(pdata->regs == NULL);
+
+	udc = kzalloc(sizeof *udc, GFP_KERNEL);
+	if (!udc) {
+		dev_err(&pdev->dev, "failed to allocate fsl udc device\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	udc->pdata = pdata;
+	udc->wakeup_irq = -1;
+	udc->phy_user.mode = MXS_USB_PHY_MODE_CLIENT;
+	udc->phy = mxs_usb_phy_get(pdev->id, &udc->phy_user);
+
+	if (IS_ERR(udc->phy)) {
+		rc = PTR_ERR(udc->phy);
+		dev_err(&pdev->dev, "failed to get phy: %d\n", rc);
+		goto out;
+	}
+
+	wakeup_irq = platform_get_irq(pdev, 1);
+	if (wakeup_irq >= 0) {
+		rc = request_irq(wakeup_irq, mxs_udc_wakeup_irq,
+				  IRQF_SHARED, "UDC wakeup", udc);
+		if (rc < 0) {
+			dev_err(&pdev->dev, "Failed to request UDC wakeup irq");
+			wakeup_irq = -1;
+			goto out;
+		}
+
+		udc->wakeup_irq = wakeup_irq;
+	}
+
+	pdata->priv = udc;
+
+	rc = 0;
+
+out:
+	if (rc < 0 && udc) {
+		if (udc->wakeup_irq >= 0)
+			free_irq(udc->wakeup_irq, udc);
+
+		if (!IS_ERR_OR_NULL(udc->phy))
+			mxs_usb_phy_put(udc->phy);
+
+		kfree(udc);
+	}
+
+	return rc;
+}
+
+void fsl_udc_unmap_platform(struct platform_device *pdev)
+{
+	struct fsl_usb2_platform_data	*pdata = pdev->dev.platform_data;
+	struct mxs_udc_device		*udc = pdata->priv;
+
+	if (udc->wakeup_irq >= 0)
+		free_irq(udc->wakeup_irq, udc);
+
+	mxs_usb_phy_put(udc->phy);
+	kfree(udc);
+
+	pdata->priv = NULL;
+}
diff -Naur linux-3.4.11/drivers/usb/gadget/fsl_udc_core.c linux-HEAD/drivers/usb/gadget/fsl_udc_core.c
--- linux-3.4.11/drivers/usb/gadget/fsl_udc_core.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/gadget/fsl_udc_core.c	2015-11-18 09:04:24.000000000 +0000
@@ -54,6 +54,10 @@
 
 #define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
 
+static bool force_fs = true;
+module_param(force_fs, bool, 0644);
+MODULE_PARM_DESC(force_fs, "force full-speed mode");
+
 static const char driver_name[] = "fsl-usb2-udc";
 static const char driver_desc[] = DRIVER_DESC;
 
@@ -149,6 +153,13 @@
 #define hc32_to_cpu(x)		le32_to_cpu(x)
 #endif /* CONFIG_PPC32 */
 
+#ifdef CONFIG_USB_WORKAROUND_MX28
+#include <mach/mxs_ehci.h>
+
+#undef fsl_writel
+#define fsl_writel		mxs_ehci_writel
+#endif
+
 /********************************************************************
  *	Internal Used Function
 ********************************************************************/
@@ -300,8 +311,14 @@
 		tmp |= USB_MODE_ES;
 	fsl_writel(tmp, &dr_regs->usbmode);
 
+	if (force_fs) {
+		tmp = fsl_readl(&dr_regs->portsc1);
+		tmp |= PORTSCX_PORT_FORCE_FULL_SPEED;
+		fsl_writel(tmp, &dr_regs->portsc1);
+	}
+
 	/* Clear the setup status */
-	fsl_writel(0, &dr_regs->usbsts);
+	fsl_writel(~0u, &dr_regs->usbsts);
 
 	tmp = udc->ep_qh_dma;
 	tmp &= USB_EP_LIST_ADDRESS_MASK;
@@ -1277,8 +1294,7 @@
 		udc->ep0_dir = USB_DIR_OUT;
 
 	ep = &udc->eps[0];
-	if (udc->ep0_state != DATA_STATE_XMIT)
-		udc->ep0_state = WAIT_FOR_OUT_STATUS;
+	udc->ep0_state = WAIT_FOR_OUT_STATUS;
 
 	req->ep = ep;
 	req->req.length = 0;
@@ -1383,8 +1399,6 @@
 
 	list_add_tail(&req->queue, &ep->queue);
 	udc->ep0_state = DATA_STATE_XMIT;
-	if (ep0_prime_status(udc, EP_DIR_OUT))
-		ep0stall(udc);
 
 	return;
 stall:
@@ -1494,14 +1508,6 @@
 		spin_lock(&udc->lock);
 		udc->ep0_state = (setup->bRequestType & USB_DIR_IN)
 				?  DATA_STATE_XMIT : DATA_STATE_RECV;
-		/*
-		 * If the data stage is IN, send status prime immediately.
-		 * See 2.0 Spec chapter 8.5.3.3 for detail.
-		 */
-		if (udc->ep0_state == DATA_STATE_XMIT)
-			if (ep0_prime_status(udc, EP_DIR_OUT))
-				ep0stall(udc);
-
 	} else {
 		/* No data phase, IN status from gadget */
 		udc->ep0_dir = USB_DIR_IN;
@@ -1531,7 +1537,8 @@
 	switch (udc->ep0_state) {
 	case DATA_STATE_XMIT:
 		/* already primed at setup_received_irq */
-		udc->ep0_state = WAIT_FOR_OUT_STATUS;
+		if (ep0_prime_status(udc, EP_DIR_OUT))
+			ep0stall(udc);
 		break;
 	case DATA_STATE_RECV:
 		/* send status phase */
@@ -1792,6 +1799,8 @@
 	u32 temp;
 	unsigned long timeout;
 
+	pr_debug("%s\n", __func__);
+
 	/* Clear the device address */
 	temp = fsl_readl(&dr_regs->deviceaddr);
 	fsl_writel(temp & ~USB_DEVICE_ADDRESS_MASK, &dr_regs->deviceaddr);
@@ -1864,8 +1873,12 @@
 	unsigned long flags;
 
 	/* Disable ISR for OTG host mode */
-	if (udc->stopped)
+	if (udc->stopped) {
+		trace_printk("sts=%08x, intr=%08x\n",
+			     fsl_readl(&dr_regs->usbsts),
+			     fsl_readl(&dr_regs->usbintr));
 		return IRQ_NONE;
+	}
 	spin_lock_irqsave(&udc->lock, flags);
 	irq_src = fsl_readl(&dr_regs->usbsts) & fsl_readl(&dr_regs->usbintr);
 	/* Clear notification bits */
@@ -2470,12 +2483,16 @@
 
 	pdata->regs = (void *)dr_regs;
 
+	ret = fsl_udc_map_platform(pdev);
+	if (ret < 0)
+		goto err_iounmap_noclk;
+
 	/*
 	 * do platform specific init: check the clock, grab/config pins, etc.
 	 */
 	if (pdata->init && pdata->init(pdev)) {
 		ret = -ENODEV;
-		goto err_iounmap_noclk;
+		goto err_unmap_platform;
 	}
 
 	/* Set accessors only after pdata->init() ! */
@@ -2597,7 +2614,9 @@
 err_iounmap:
 	if (pdata->exit)
 		pdata->exit(pdev);
-	fsl_udc_clk_release();
+	fsl_udc_clk_release(pdev);
+err_unmap_platform:
+	fsl_udc_unmap_platform(pdev);
 err_iounmap_noclk:
 	iounmap(dr_regs);
 err_release_mem_region:
@@ -2625,7 +2644,7 @@
 	usb_del_gadget_udc(&udc_controller->gadget);
 	udc_controller->done = &done;
 
-	fsl_udc_clk_release();
+	fsl_udc_clk_release(pdev);
 
 	/* DR has been stopped in usb_gadget_unregister_driver() */
 	remove_proc_file();
@@ -2637,6 +2656,7 @@
 
 	dma_pool_destroy(udc_controller->td_pool);
 	free_irq(udc_controller->irq, udc_controller);
+	fsl_udc_unmap_platform(pdev);
 	iounmap(dr_regs);
 	if (pdata->operating_mode == FSL_USB2_DR_DEVICE)
 		release_mem_region(res->start, resource_size(res));
diff -Naur linux-3.4.11/drivers/usb/gadget/fsl_usb2_udc.h linux-HEAD/drivers/usb/gadget/fsl_usb2_udc.h
--- linux-3.4.11/drivers/usb/gadget/fsl_usb2_udc.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/gadget/fsl_usb2_udc.h	2015-11-18 09:04:24.000000000 +0000
@@ -580,10 +580,24 @@
 }
 
 struct platform_device;
-#ifdef CONFIG_ARCH_MXC
+#if defined(CONFIG_ARCH_MXS)
+int fsl_udc_map_platform(struct platform_device *pdev);
+void fsl_udc_unmap_platform(struct platform_device *pdev);
+#else
+static inline int fsl_udc_map_platform(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static inline void fsl_udc_unmap_platform(struct platform_device *pdev)
+{
+}
+#endif
+
+#if defined(CONFIG_ARCH_MXC) || defined(CONFIG_ARCH_MXS)
 int fsl_udc_clk_init(struct platform_device *pdev);
 void fsl_udc_clk_finalize(struct platform_device *pdev);
-void fsl_udc_clk_release(void);
+void fsl_udc_clk_release(struct platform_device *pdev);
 #else
 static inline int fsl_udc_clk_init(struct platform_device *pdev)
 {
@@ -592,7 +606,7 @@
 static inline void fsl_udc_clk_finalize(struct platform_device *pdev)
 {
 }
-static inline void fsl_udc_clk_release(void)
+static inline void fsl_udc_clk_release(struct platform_device *pdev)
 {
 }
 #endif
diff -Naur linux-3.4.11/drivers/usb/gadget/gadget_chips.h linux-HEAD/drivers/usb/gadget/gadget_chips.h
--- linux-3.4.11/drivers/usb/gadget/gadget_chips.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/gadget/gadget_chips.h	2015-11-18 09:04:24.000000000 +0000
@@ -51,6 +51,12 @@
 #define gadget_is_s3c_hsotg(g)		(!strcmp("s3c-hsotg", (g)->name))
 #define gadget_is_s3c_hsudc(g)		(!strcmp("s3c-hsudc", (g)->name))
 
+#if defined(CONFIG_USB_MV_UDC) || defined(CONFIG_USB_MV_UDC_MODULE)
+#define	gadget_is_pxa_u2o(g) (!strcmp("mv_udc", (g)->name))
+#else
+#define	gadget_is_pxa_u2o(g) 0
+#endif
+
 /**
  * usb_gadget_controller_number - support bcdDevice id convention
  * @gadget: the controller being driven
@@ -118,6 +124,8 @@
 		return 0x31;
 	else if (gadget_is_dwc3(gadget))
 		return 0x32;
+	else if (gadget_is_pxa_u2o(gadget))
+		return 0x33;
 
 	return -ENOENT;
 }
diff -Naur linux-3.4.11/drivers/usb/gadget/Kconfig linux-HEAD/drivers/usb/gadget/Kconfig
--- linux-3.4.11/drivers/usb/gadget/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/gadget/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -157,7 +157,7 @@
 
 config USB_FSL_USB2
 	tristate "Freescale Highspeed USB DR Peripheral Controller"
-	depends on FSL_SOC || ARCH_MXC
+	depends on FSL_SOC || ARCH_MXC || ARCH_MXS
 	select USB_GADGET_DUALSPEED
 	select USB_FSL_MPH_DR_OF if OF
 	help
diff -Naur linux-3.4.11/drivers/usb/gadget/Makefile linux-HEAD/drivers/usb/gadget/Makefile
--- linux-3.4.11/drivers/usb/gadget/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/gadget/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -19,6 +19,7 @@
 obj-$(CONFIG_USB_FSL_USB2)	+= fsl_usb2_udc.o
 fsl_usb2_udc-y			:= fsl_udc_core.o
 fsl_usb2_udc-$(CONFIG_ARCH_MXC)	+= fsl_mxc_udc.o
+fsl_usb2_udc-$(CONFIG_ARCH_MXS)	+= fsl_mxs_udc.o
 obj-$(CONFIG_USB_M66592)	+= m66592-udc.o
 obj-$(CONFIG_USB_R8A66597)	+= r8a66597-udc.o
 obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
diff -Naur linux-3.4.11/drivers/usb/gadget/mv_udc_core.c linux-HEAD/drivers/usb/gadget/mv_udc_core.c
--- linux-3.4.11/drivers/usb/gadget/mv_udc_core.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/gadget/mv_udc_core.c	2015-11-18 09:04:24.000000000 +0000
@@ -38,6 +38,10 @@
 
 #include "mv_udc.h"
 
+static bool force_fs = true;
+module_param(force_fs, bool, 0644);
+MODULE_PARM_DESC(force_fs, "force full-speed mode");
+
 #define DRIVER_DESC		"Marvell PXA USB Device Controller driver"
 #define DRIVER_VERSION		"8 Nov 2010"
 
@@ -63,7 +67,6 @@
 
 /* controller device global variable */
 static struct mv_udc	*the_controller;
-int mv_usb_otgsc;
 
 static void nuke(struct mv_ep *ep, int status);
 static void stop_activity(struct mv_udc *udc, struct usb_gadget_driver *driver);
@@ -990,7 +993,7 @@
 	unsigned int i;
 
 	for (i = 0; i < udc->clknum; i++)
-		clk_enable(udc->clk[i]);
+		clk_prepare_enable(udc->clk[i]);
 }
 
 static void udc_clock_disable(struct mv_udc *udc)
@@ -998,7 +1001,7 @@
 	unsigned int i;
 
 	for (i = 0; i < udc->clknum; i++)
-		clk_disable(udc->clk[i]);
+		clk_disable_unprepare(udc->clk[i]);
 }
 
 static void udc_stop(struct mv_udc *udc)
@@ -1021,6 +1024,7 @@
 
 static void udc_start(struct mv_udc *udc)
 {
+	u32 tmp;
 	u32 usbintr;
 
 	usbintr = USBINTR_INT_EN | USBINTR_ERR_INT_EN
@@ -1032,7 +1036,9 @@
 	udc->stopped = 0;
 
 	/* Set the Run bit in the command register */
-	writel(USBCMD_RUN_STOP, &udc->op_regs->usbcmd);
+	tmp = readl(&udc->op_regs->usbcmd);
+	tmp |= USBCMD_RUN_STOP;
+	writel(tmp, &udc->op_regs->usbcmd);
 }
 
 static int udc_reset(struct mv_udc *udc)
@@ -1069,7 +1075,7 @@
 
 	writel(tmp, &udc->op_regs->usbmode);
 
-	writel(0x0, &udc->op_regs->epsetupstat);
+	writel(~0x0, &udc->op_regs->epsetupstat);
 
 	/* Configure the Endpoint List Address */
 	writel(udc->ep_dqh_dma & USB_EP_LIST_ADDRESS_MASK,
@@ -1118,6 +1124,7 @@
 
 static int mv_udc_enable(struct mv_udc *udc)
 {
+	might_sleep();
 	if (udc->clock_gating)
 		return mv_udc_enable_internal(udc);
 
@@ -1191,7 +1198,10 @@
 		__func__, udc->softconnect, udc->vbus_active);
 
 	if (udc->driver && udc->softconnect && udc->vbus_active) {
+		spin_unlock_irqrestore(&udc->lock, flags);
 		retval = mv_udc_enable(udc);
+		spin_lock_irqsave(&udc->lock, flags);
+
 		if (retval == 0) {
 			/* Clock is disabled, need re-init registers */
 			udc_reset(udc);
@@ -1215,6 +1225,8 @@
 	unsigned long flags;
 	int retval = 0;
 
+	might_sleep();
+
 	udc = container_of(gadget, struct mv_udc, gadget);
 	spin_lock_irqsave(&udc->lock, flags);
 
@@ -1224,7 +1236,9 @@
 			__func__, udc->softconnect, udc->vbus_active);
 
 	if (udc->driver && udc->softconnect && udc->vbus_active) {
+		spin_unlock_irqrestore(&udc->lock, flags);
 		retval = mv_udc_enable(udc);
+		spin_lock_irqsave(&udc->lock, flags);
 		if (retval == 0) {
 			/* Clock is disabled, need re-init registers */
 			udc_reset(udc);
@@ -1415,9 +1429,9 @@
 	if (!udc)
 		return -ENODEV;
 
-	spin_lock_irqsave(&udc->lock, flags);
-
 	mv_udc_enable(udc);
+
+	spin_lock_irqsave(&udc->lock, flags);
 	udc_stop(udc);
 
 	/* stop all usb activities */
@@ -1869,7 +1883,7 @@
 	}
 }
 
-void irq_process_reset(struct mv_udc *udc)
+static void irq_process_reset(struct mv_udc *udc)
 {
 	u32 tmp;
 	unsigned int loops;
@@ -2109,7 +2123,7 @@
 	 */
 	if (udc->pdata && udc->pdata->vbus
 		&& udc->clock_gating && udc->transceiver == NULL)
-		free_irq(udc->pdata->vbus->irq, &dev->dev);
+		free_irq(udc->pdata->vbus->irq, udc);
 
 	/* free memory allocated in probe */
 	if (udc->dtd_pool)
@@ -2122,7 +2136,7 @@
 	kfree(udc->eps);
 
 	if (udc->irq)
-		free_irq(udc->irq, &dev->dev);
+		free_irq(udc->irq, udc);
 
 	mv_udc_disable(udc);
 
@@ -2178,6 +2192,7 @@
 	spin_lock_init(&udc->lock);
 
 	udc->dev = dev;
+	udc->force_fs = force_fs ? 1u : 0u;
 
 #ifdef CONFIG_USB_OTG_UTILS
 	if (pdata->mode == MV_USB_MODE_OTG)
@@ -2371,10 +2386,10 @@
 err_unregister:
 	if (udc->pdata && udc->pdata->vbus
 		&& udc->clock_gating && udc->transceiver == NULL)
-		free_irq(pdata->vbus->irq, &dev->dev);
+		free_irq(pdata->vbus->irq, udc);
 	device_unregister(&udc->gadget.dev);
 err_free_irq:
-	free_irq(udc->irq, &dev->dev);
+	free_irq(udc->irq, udc);
 err_free_status_req:
 	kfree(udc->status_req->req.buf);
 	kfree(udc->status_req);
diff -Naur linux-3.4.11/drivers/usb/gadget/pxa27x_udc.c linux-HEAD/drivers/usb/gadget/pxa27x_udc.c
--- linux-3.4.11/drivers/usb/gadget/pxa27x_udc.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/gadget/pxa27x_udc.c	2015-11-18 09:04:24.000000000 +0000
@@ -890,8 +890,6 @@
 		*buf++ = udc_ep_readl(ep, UDCDR);
 	req->req.actual += count;
 
-	ep_write_UDCCSR(ep, UDCCSR_PC);
-
 	return count;
 }
 
@@ -955,6 +953,7 @@
 
 	while (epout_has_pkt(ep)) {
 		count = read_packet(ep, req);
+		udc_ep_writel(ep, UDCCSR, UDCCSR_PC);
 		inc_ep_stats_bytes(ep, count, !USB_DIR_IN);
 
 		is_short = (count < ep->fifo_size);
@@ -1770,6 +1769,9 @@
 	if (udc_readl(udc, UDCCR) & UDCCR_EMCE)
 		dev_err(udc->dev, "Configuration errors, udc disabled\n");
 
+	if (udc->mach->udc_command)
+		udc->mach->udc_command(PXA2XX_UDC_CMD_CONNECT_LATE);
+
 	/*
 	 * Caller must be able to sleep in order to cope with startup transients
 	 */
@@ -1950,6 +1952,8 @@
 	}
 
 	have_extrabytes = !ep_is_empty(ep);
+	BUG_ON(have_extrabytes < 0);
+
 	while (!ep_is_empty(ep)) {
 		i = udc_ep_readl(ep, UDCDR);
 		ep_err(ep, "wrong to have extra bytes for setup : 0x%08x\n", i);
@@ -2133,6 +2137,9 @@
 		goto recursion_detected;
 	ep->in_handle_ep = 1;
 
+	/* some code below uses registers not available for ep0 */
+	BUG_ON(is_ep0(ep));
+
 	do {
 		completed = 0;
 		udccsr = udc_ep_readl(ep, UDCCSR);
diff -Naur linux-3.4.11/drivers/usb/host/ehci.h linux-HEAD/drivers/usb/host/ehci.h
--- linux-3.4.11/drivers/usb/host/ehci.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/host/ehci.h	2015-11-18 09:04:24.000000000 +0000
@@ -656,6 +656,10 @@
 #endif
 }
 
+#if defined(CONFIG_USB_WORKAROUND_MX28)
+static void mxs_ehci_writel(unsigned int val, void __iomem *regs);
+#endif
+
 static inline void ehci_writel(const struct ehci_hcd *ehci,
 		const unsigned int val, __u32 __iomem *regs)
 {
@@ -663,6 +667,8 @@
 	ehci_big_endian_mmio(ehci) ?
 		writel_be(val, regs) :
 		writel(val, regs);
+#elif defined(CONFIG_USB_WORKAROUND_MX28)
+	mxs_ehci_writel(val, regs);
 #else
 	writel(val, regs);
 #endif
diff -Naur linux-3.4.11/drivers/usb/host/ehci-hcd.c linux-HEAD/drivers/usb/host/ehci-hcd.c
--- linux-3.4.11/drivers/usb/host/ehci-hcd.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/host/ehci-hcd.c	2015-11-18 09:04:24.000000000 +0000
@@ -1270,6 +1270,11 @@
 #define PLATFORM_DRIVER		ehci_mxc_driver
 #endif
 
+#ifdef CONFIG_USB_EHCI_MXS
+#include "ehci-mxs.c"
+#define PLATFORM_DRIVER		ehci_mxs_driver
+#endif
+
 #ifdef CONFIG_USB_EHCI_SH
 #include "ehci-sh.c"
 #define PLATFORM_DRIVER		ehci_hcd_sh_driver
diff -Naur linux-3.4.11/drivers/usb/host/ehci-mv.c linux-HEAD/drivers/usb/host/ehci-mv.c
--- linux-3.4.11/drivers/usb/host/ehci-mv.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/host/ehci-mv.c	2015-11-18 09:04:24.000000000 +0000
@@ -42,7 +42,7 @@
 	unsigned int i;
 
 	for (i = 0; i < ehci_mv->clknum; i++)
-		clk_enable(ehci_mv->clk[i]);
+		clk_prepare_enable(ehci_mv->clk[i]);
 }
 
 static void ehci_clock_disable(struct ehci_hcd_mv *ehci_mv)
@@ -50,7 +50,7 @@
 	unsigned int i;
 
 	for (i = 0; i < ehci_mv->clknum; i++)
-		clk_disable(ehci_mv->clk[i]);
+		clk_disable_unprepare(ehci_mv->clk[i]);
 }
 
 static int mv_ehci_enable(struct ehci_hcd_mv *ehci_mv)
@@ -389,3 +389,4 @@
 		   },
 	.id_table = ehci_id_table,
 };
+MODULE_DEVICE_TABLE(platform, ehci_id_table);
diff -Naur linux-3.4.11/drivers/usb/host/ehci-mxs.c linux-HEAD/drivers/usb/host/ehci-mxs.c
--- linux-3.4.11/drivers/usb/host/ehci-mxs.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/usb/host/ehci-mxs.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,408 @@
+/*
+ * Copyright (c) 2008 Sascha Hauer <s.hauer@pengutronix.de>, Pengutronix
+ * Copyright (c) 2009 Daniel Mack <daniel@caiaq.de>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/ulpi.h>
+#include <linux/slab.h>
+
+#include <linux/regulator/consumer.h>
+
+#include <mach/hardware.h>
+#include <mach/mxs_ehci.h>
+#include <mach/common.h>
+
+#include <asm/mach-types.h>
+
+#define ULPI_VIEWPORT_OFFSET	0x170
+
+struct ehci_mxs_priv {
+	struct clk	*usbclk;
+	struct usb_hcd	*hcd;
+
+	struct mxs_usb_phy	*phy;
+	struct mxs_usb_phy_user	phy_user;
+
+
+	struct regulator	*vbus;
+	int			wakeup_irq;
+};
+
+/* called during probe() after chip reset completes */
+static int ehci_mxs_setup(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval;
+
+	dbg_hcs_params(ehci, "reset");
+	dbg_hcc_params(ehci, "reset");
+
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+
+	hcd->has_tt = 1;
+
+	retval = ehci_halt(ehci);
+	if (retval)
+		return retval;
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+
+	ehci->sbrn = 0x20;
+
+	ehci_reset(ehci);
+
+	ehci_port_power(ehci, 0);
+	return 0;
+}
+
+static const struct hc_driver ehci_mxs_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "Freescale On-Chip EHCI Host Controller",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_irq,
+	.flags = HCD_USB2 | HCD_MEMORY,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = ehci_mxs_setup,
+	.start = ehci_run,
+	.stop = ehci_stop,
+	.shutdown = ehci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+	.endpoint_reset = ehci_endpoint_reset,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+};
+
+static irqreturn_t ehci_mxs_wakeup_irq(int num, void *priv_v)
+{
+	struct ehci_mxs_priv *priv = priv_v;
+
+	writel(MXS_USBPHY_CTRL_WAKEUP_IRQ | MXS_USBPHY_CTRL_RESUME_IRQ,
+	       priv->phy->addr + MXS_USBPHY_CTRL_clr);
+
+	return IRQ_HANDLED;
+}
+
+static int ehci_mxs_drv_probe(struct platform_device *pdev)
+{
+	struct mxs_usbh_platform_data *pdata = pdev->dev.platform_data;
+	struct usb_hcd *hcd = NULL;
+	struct resource *res;
+	int irq, ret;
+	struct ehci_mxs_priv *priv = NULL;
+	struct device *dev = &pdev->dev;
+	struct ehci_hcd *ehci = NULL;
+	bool pdata_init = false;
+
+	dev_info(&pdev->dev, "initializing i.MX USB Controller\n");
+
+	if (!pdata) {
+		dev_err(dev, "No platform data given, bailing out.\n");
+		return -EINVAL;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+
+	hcd = usb_create_hcd(&ehci_mxs_hc_driver, dev, dev_name(dev));
+	if (!hcd)
+		return -ENOMEM;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	priv->wakeup_irq = -1;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Found HC with no register addr. Check setup!\n");
+		ret = -ENODEV;
+		goto err;
+	}
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = resource_size(res);
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {
+		dev_dbg(dev, "controller already in use\n");
+		ret = -EBUSY;
+		goto err;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		dev_err(dev, "error mapping memory\n");
+		ret = -EFAULT;
+		goto err;
+	}
+
+	switch (pdev->id) {
+	case 0:
+		priv->usbclk = clk_get(dev, "usb0");
+		break;
+	case 1:
+		priv->usbclk = clk_get(dev, "usb1");
+		break;
+	default:
+		dev_err(dev, "invalid device id #%d\n", pdev->id);
+		ret = -ENOENT;
+		break;
+	}
+
+	if (IS_ERR(priv->usbclk)) {
+		ret = PTR_ERR(priv->usbclk);
+		dev_err(dev, "failed to get clock: %d\n", ret);
+		goto err;
+	}
+	clk_prepare_enable(priv->usbclk);
+
+	priv->phy_user.mode = MXS_USB_PHY_MODE_HOST;
+	priv->phy = mxs_usb_phy_get(pdev->id, &priv->phy_user);
+
+	if (IS_ERR(priv->phy)) {
+		ret = PTR_ERR(priv->phy);
+		dev_err(dev, "failed to get phy: %d\n", ret);
+		goto err;
+	}
+	mxs_usb_phy_clk_enable(priv->phy);
+
+	/* call platform specific init function */
+	if (pdata->init) {
+		ret = pdata->init(pdev, hcd->regs, priv->phy->addr);
+		if (ret) {
+			dev_err(dev, "platform init failed\n");
+			goto err;
+		}
+		pdata_init = true;
+
+		/* platforms need some time to settle changed IO settings */
+		mdelay(10);
+	}
+
+	writel(0, hcd->regs + 0x148); /* disable interrupts */
+	ret = mxs_usb_phy_reset(priv->phy, 0);
+	if (ret < 0) {
+		dev_err(dev, "failed to reset PHY: %d\n", ret);
+		goto err;
+	}
+
+	priv->wakeup_irq = platform_get_irq(pdev, 1);
+	if (priv->wakeup_irq >= 0) {
+		ret = request_irq(priv->wakeup_irq, ehci_mxs_wakeup_irq,
+				  IRQF_SHARED, "EHCI wakeup", priv);
+		if (ret < 0) {
+			dev_err(dev, "Failed to request EHCI wakeup irq");
+			priv->wakeup_irq = -1;
+			goto err;
+		}
+	}
+
+	if (!pdata->otg)
+		priv->phy->enable(priv->phy);
+
+	ehci = hcd_to_ehci(hcd);
+
+	/* EHCI registers start at offset 0x100 */
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100 +
+		HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
+
+	/* set up the PORTSCx register */
+	ehci_writel(ehci, pdata->portsc, &ehci->regs->port_status[0]);
+
+	/* is this really needed? */
+	msleep(10);
+
+	priv->vbus = regulator_get(dev, "USB_5V");
+	if (priv->vbus == NULL ||
+	    (IS_ERR(priv->vbus) && PTR_ERR(priv->vbus) == -ENODEV))
+		priv->vbus = NULL;
+	else if (IS_ERR(priv->vbus)) {
+		ret = PTR_ERR(priv->vbus);
+		dev_err(dev, "failed to get VBUS regulator: %d\n", ret);
+		priv->vbus = NULL;
+		goto err;
+	} else {
+		ret = regulator_enable(priv->vbus);
+		if (ret < 0) {
+			dev_err(dev, "failed to enable VBUS regulator: %d\n",
+				ret);
+			regulator_put(priv->vbus);
+			priv->vbus = NULL;
+			goto err;
+		}
+
+		dev_info(dev, "using regulator to control VBUS\n");
+	}
+
+	/* Initialize the transceiver */
+	if (pdata->otg) {
+		pdata->otg->io_priv = hcd->regs + ULPI_VIEWPORT_OFFSET;
+		ret = usb_phy_init(pdata->otg);
+		if (ret) {
+			dev_err(dev, "unable to init transceiver, probably missing\n");
+			ret = -ENODEV;
+			goto err;
+		}
+		ret = otg_set_vbus(pdata->otg->otg, 1);
+		if (ret) {
+			dev_err(dev, "unable to enable vbus on transceiver\n");
+			goto err;
+		}
+	}
+
+	priv->hcd = hcd;
+	platform_set_drvdata(pdev, priv);
+
+	ret = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	if (ret < 0 && priv) {
+		if (priv->vbus) {
+			regulator_disable(priv->vbus);
+			regulator_put(priv->vbus);
+		}
+
+		if (priv->wakeup_irq >= 0)
+			free_irq(priv->wakeup_irq, priv);
+
+		if (pdata_init && pdata->exit)
+			pdata->exit(pdev, hcd->regs, priv->phy->addr);
+
+		if (!IS_ERR_OR_NULL(priv->phy)) {
+			mxs_usb_phy_clk_disable(priv->phy);
+			priv->phy->put(priv->phy);
+		}
+
+		if (!IS_ERR_OR_NULL(priv->usbclk)) {
+			clk_disable_unprepare(priv->usbclk);
+			clk_put(priv->usbclk);
+		}
+
+		if (hcd->rsrc_start) {
+			iounmap(hcd->regs);
+			release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+		}
+
+		kfree(priv);
+	}
+
+	if (ret < 0)
+		usb_put_hcd(hcd);
+
+	return ret;
+}
+
+static int __exit ehci_mxs_drv_remove(struct platform_device *pdev)
+{
+	struct mxs_usbh_platform_data *pdata = pdev->dev.platform_data;
+	struct ehci_mxs_priv *priv = platform_get_drvdata(pdev);
+	struct usb_hcd *hcd = priv->hcd;
+
+	if (pdata && pdata->exit)
+		pdata->exit(pdev, hcd->regs, priv->phy->addr);
+
+	if (pdata->otg)
+		usb_phy_shutdown(pdata->otg);
+
+	usb_remove_hcd(hcd);
+
+	if (priv->vbus) {
+		regulator_disable(priv->vbus);
+		regulator_put(priv->vbus);
+	}
+
+	if (priv->wakeup_irq >= 0)
+		free_irq(priv->wakeup_irq, priv);
+
+	platform_set_drvdata(pdev, NULL);
+
+	mxs_usb_phy_clk_disable(priv->phy);
+	priv->phy->put(priv->phy);
+
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+
+	clk_disable_unprepare(priv->usbclk);
+	clk_put(priv->usbclk);
+
+	kfree(priv);
+
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+static void ehci_mxs_drv_shutdown(struct platform_device *pdev)
+{
+	struct ehci_mxs_priv *priv = platform_get_drvdata(pdev);
+	struct usb_hcd *hcd = priv->hcd;
+
+	if (hcd->driver->shutdown)
+		hcd->driver->shutdown(hcd);
+}
+
+MODULE_ALIAS("platform:mxs-ehci");
+
+static struct platform_driver ehci_mxs_driver = {
+	.probe = ehci_mxs_drv_probe,
+	.remove = __exit_p(ehci_mxs_drv_remove),
+	.shutdown = ehci_mxs_drv_shutdown,
+	.driver = {
+		   .name = "mxs-ehci",
+	},
+};
diff -Naur linux-3.4.11/drivers/usb/host/isp1760-if.c linux-HEAD/drivers/usb/host/isp1760-if.c
--- linux-3.4.11/drivers/usb/host/isp1760-if.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/host/isp1760-if.c	2015-11-18 09:04:24.000000000 +0000
@@ -378,13 +378,18 @@
 		pr_warning("isp1760: IRQ resource not available\n");
 		return -ENODEV;
 	}
+
+	if ((mem_res->flags & IORESOURCE_MEM_16BIT))
+		devflags |= ISP1760_FLAG_BUS_WIDTH_16;
+
+	if ((irq_res->flags & (IORESOURCE_IRQ_HIGHEDGE|IORESOURCE_IRQ_LOWEDGE)))
+		devflags |= ISP1760_FLAG_INTR_EDGE_TRIG;
+
 	irqflags |= irq_res->flags & IRQF_TRIGGER_MASK;
 
 	if (priv) {
 		if (priv->is_isp1761)
 			devflags |= ISP1760_FLAG_ISP1761;
-		if (priv->bus_width_16)
-			devflags |= ISP1760_FLAG_BUS_WIDTH_16;
 		if (priv->port1_otg)
 			devflags |= ISP1760_FLAG_OTG_EN;
 		if (priv->analog_oc)
@@ -432,6 +437,7 @@
 		.name	= "isp1760",
 	},
 };
+MODULE_ALIAS("platform:isp1760");
 
 static int __init isp1760_init(void)
 {
diff -Naur linux-3.4.11/drivers/usb/host/Kconfig linux-HEAD/drivers/usb/host/Kconfig
--- linux-3.4.11/drivers/usb/host/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/host/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -148,6 +148,13 @@
 	---help---
 	  Variation of ARC USB block used in some Freescale chips.
 
+config USB_EHCI_MXS
+	bool "Support for Freescale on-chip EHCI USB controller"
+	depends on USB_EHCI_HCD && ARCH_MXS
+	select USB_EHCI_ROOT_HUB_TT
+	---help---
+	  Variation of ARC USB block used in some Freescale chips.
+
 config USB_EHCI_HCD_OMAP
 	bool "EHCI support for OMAP3 and later chips"
 	depends on USB_EHCI_HCD && ARCH_OMAP
diff -Naur linux-3.4.11/drivers/usb/host/ohci-pxa27x.c linux-HEAD/drivers/usb/host/ohci-pxa27x.c
--- linux-3.4.11/drivers/usb/host/ohci-pxa27x.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/host/ohci-pxa27x.c	2015-11-18 09:04:24.000000000 +0000
@@ -162,14 +162,19 @@
 	uint32_t uhchr = __raw_readl(ohci->mmio_base + UHCHR);
 	uint32_t uhcrhda = __raw_readl(ohci->mmio_base + UHCRHDA);
 
-	if (inf->flags & ENABLE_PORT1)
-		uhchr &= ~UHCHR_SSEP1;
+	uhchr &= ~(UHCHR_SSEP1 | UHCHR_SSEP2 | UHCHR_SSEP3 |
+		   UHCHR_PCPL  | UHCHR_PSPL);
 
-	if (inf->flags & ENABLE_PORT2)
-		uhchr &= ~UHCHR_SSEP2;
+	uhcrhda &= ~(UHCRHDA_NOCP | UHCRHDA_OCPM);
 
-	if (inf->flags & ENABLE_PORT3)
-		uhchr &= ~UHCHR_SSEP3;
+	if (!(inf->flags & ENABLE_PORT1))
+		uhchr |= UHCHR_SSEP1;
+
+	if (!(inf->flags & ENABLE_PORT2))
+		uhchr |= UHCHR_SSEP2;
+
+	if (!(inf->flags & ENABLE_PORT3))
+		uhchr |= UHCHR_SSEP3;
 
 	if (inf->flags & POWER_CONTROL_LOW)
 		uhchr |= UHCHR_PCPL;
diff -Naur linux-3.4.11/drivers/usb/Kconfig linux-HEAD/drivers/usb/Kconfig
--- linux-3.4.11/drivers/usb/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -38,6 +38,7 @@
 	default y if ARCH_W90X900
 	default y if ARCH_AT91
 	default y if ARCH_MXC
+	default y if ARCH_MXS
 	default y if ARCH_OMAP3
 	default y if ARCH_CNS3XXX
 	default y if ARCH_VT8500
diff -Naur linux-3.4.11/drivers/usb/otg/fsl_otg.c linux-HEAD/drivers/usb/otg/fsl_otg.c
--- linux-3.4.11/drivers/usb/otg/fsl_otg.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/otg/fsl_otg.c	2015-11-18 09:04:24.000000000 +0000
@@ -853,6 +853,7 @@
 	if (pdata->init && pdata->init(pdev) != 0)
 		return -EINVAL;
 
+#ifdef CONFIG_PPC32
 	if (pdata->big_endian_mmio) {
 		_fsl_readl = _fsl_readl_be;
 		_fsl_writel = _fsl_writel_be;
@@ -860,6 +861,7 @@
 		_fsl_readl = _fsl_readl_le;
 		_fsl_writel = _fsl_writel_le;
 	}
+#endif
 
 	/* request irq */
 	p_otg->irq = platform_get_irq(pdev, 0);
diff -Naur linux-3.4.11/drivers/usb/otg/Kconfig linux-HEAD/drivers/usb/otg/Kconfig
--- linux-3.4.11/drivers/usb/otg/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/otg/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -110,7 +110,7 @@
 
 config FSL_USB2_OTG
 	bool "Freescale USB OTG Transceiver Driver"
-	depends on USB_EHCI_FSL && USB_GADGET_FSL_USB2 && USB_SUSPEND
+	depends on (USB_EHCI_FSL || USB_EHCI_MXS) && USB_GADGET_FSL_USB2 && USB_SUSPEND
 	select USB_OTG
 	select USB_OTG_UTILS
 	help
diff -Naur linux-3.4.11/drivers/usb/otg/mv_otg.c linux-HEAD/drivers/usb/otg/mv_otg.c
--- linux-3.4.11/drivers/usb/otg/mv_otg.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/usb/otg/mv_otg.c	2015-11-18 09:04:24.000000000 +0000
@@ -240,7 +240,7 @@
 	unsigned int i;
 
 	for (i = 0; i < mvotg->clknum; i++)
-		clk_enable(mvotg->clk[i]);
+		clk_prepare_enable(mvotg->clk[i]);
 }
 
 static void otg_clock_disable(struct mv_otg *mvotg)
@@ -248,7 +248,7 @@
 	unsigned int i;
 
 	for (i = 0; i < mvotg->clknum; i++)
-		clk_disable(mvotg->clk[i]);
+		clk_disable_unprepare(mvotg->clk[i]);
 }
 
 static int mv_otg_enable_internal(struct mv_otg *mvotg)
diff -Naur linux-3.4.11/drivers/video/backlight/Kconfig linux-HEAD/drivers/video/backlight/Kconfig
--- linux-3.4.11/drivers/video/backlight/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/video/backlight/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -265,6 +265,11 @@
          If you have an Intel-based Apple say Y to enable a driver for its
 	 backlight.
 
+config LCD_MAX749
+	tristate "MAX749 LCD Bias driver"
+	depends on LCD_CLASS_DEVICE
+	default n
+
 config BACKLIGHT_TOSA
 	tristate "Sharp SL-6000 Backlight Driver"
 	depends on I2C && MACH_TOSA && LCD_TOSA
diff -Naur linux-3.4.11/drivers/video/backlight/Makefile linux-HEAD/drivers/video/backlight/Makefile
--- linux-3.4.11/drivers/video/backlight/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/video/backlight/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -42,3 +42,4 @@
 obj-$(CONFIG_BACKLIGHT_PCF50633)	+= pcf50633-backlight.o
 obj-$(CONFIG_BACKLIGHT_AAT2870) += aat2870_bl.o
 obj-$(CONFIG_BACKLIGHT_OT200) += ot200_bl.o
+obj-$(CONFIG_LCD_MAX749)	+= max749.o
diff -Naur linux-3.4.11/drivers/video/backlight/max749.c linux-HEAD/drivers/video/backlight/max749.c
--- linux-3.4.11/drivers/video/backlight/max749.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/video/backlight/max749.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,421 @@
+// $Id$    --*- c -*--
+
+// Copyright (C) 2007 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; version 2 of the License.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/lcd.h>
+#include <linux/fb.h>
+#include <linux/lcd-max749.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+
+#define MAX749_STATE_SHUTDOWN	0
+#define MAX749_STATE_RESET	1
+#define MAX749_STATE_ON		2
+
+struct max749_device {
+	struct lcd_device	*lcd;
+	void			(*set_adj)(int);
+	void			(*set_ctrl)(int);
+
+	int			contrast;	// contrast set by the user
+	int			cur_contrast;	// contrast stored in the device
+	int			regulation;	// regulation offset
+	int			power;
+
+	int			state;
+
+	struct mutex		lock;
+};
+
+static void
+max749_set_state(struct max749_device *dev, int state)
+{
+	mutex_lock(&dev->lock);
+
+	switch (state) {
+	case MAX749_STATE_SHUTDOWN:
+		dev->set_adj(0);
+		dev->set_ctrl(0);
+
+		dev->state = state;
+		break;
+
+	case MAX749_STATE_RESET:
+		switch (dev->state) {
+		case MAX749_STATE_SHUTDOWN:
+		case MAX749_STATE_ON:
+		case MAX749_STATE_RESET:
+			dev->set_adj(1);
+			dev->set_ctrl(0);
+
+			dev->cur_contrast = 32;
+			break;
+
+		default:
+			break;
+		}
+
+		dev->state = state;
+		break;
+
+	case MAX749_STATE_ON:
+		switch (dev->state) {
+		case MAX749_STATE_RESET:
+			dev->set_adj(1);
+			dev->set_ctrl(1);
+			break;
+
+		case MAX749_STATE_SHUTDOWN:
+			dev->set_adj(0);
+			dev->set_ctrl(1);
+			break;
+
+		default:
+			break;
+		}
+
+		dev->state = state;
+		break;
+
+	default:
+		break;
+	}
+
+	mutex_unlock(&dev->lock);
+}
+
+static int
+max749_set_contrast(struct lcd_device *lcd, int contrast)
+{
+	struct max749_device	*dev = class_get_devdata(&lcd->class_dev);
+	int			new_contrast = max(0, min(63, contrast + dev->regulation));
+
+	mutex_lock(&dev->lock);
+
+	if (dev->state!=MAX749_STATE_SHUTDOWN) {
+		unsigned int	cnt;
+
+		if (new_contrast==32 ||
+		    (dev->cur_contrast<32 && new_contrast>32) ||
+		    (new_contrast<dev->cur_contrast &&
+		     !(new_contrast<32 && dev->cur_contrast>32))) {
+			mutex_unlock(&dev->lock);
+			max749_set_state(dev, MAX749_STATE_RESET);
+			mutex_lock(&dev->lock);
+		}
+
+
+		cnt  = 64 + new_contrast - dev->cur_contrast;
+		cnt %= 64;
+
+		if (cnt>0) {
+			dev->state = MAX749_STATE_ON;
+			dev->set_ctrl(1);
+		}
+
+		while (cnt-->0) {
+			dev->set_adj(0);
+			ndelay(100);
+			dev->set_adj(1);
+			ndelay(100);
+		}
+
+		dev->cur_contrast = new_contrast;
+	}
+
+	dev->contrast = max(0, min(63, contrast));
+
+	mutex_unlock(&dev->lock);
+	return 0;
+}
+
+static int
+max749_get_contrast(struct lcd_device *lcd)
+{
+	struct max749_device	*dev = class_get_devdata(&lcd->class_dev);
+	return dev->contrast;
+}
+
+static int
+max749_set_power(struct lcd_device *lcd, int power)
+{
+	struct max749_device	*dev = class_get_devdata(&lcd->class_dev);
+
+	if (power > FB_BLANK_NORMAL)
+		max749_set_state(dev, MAX749_STATE_SHUTDOWN);
+	else {
+		if (dev->power > FB_BLANK_NORMAL)
+			max749_set_state(dev, MAX749_STATE_RESET);
+		else
+			max749_set_state(dev, MAX749_STATE_ON);
+
+		max749_set_contrast(lcd, dev->contrast);
+	}
+
+	dev->power = power;
+	return 0;
+}
+
+static int
+max749_get_power(struct lcd_device *lcd)
+{
+	struct max749_device	*dev = class_get_devdata(&lcd->class_dev);
+	return dev->power;
+}
+
+static struct lcd_ops		max749_lcd_ops = {
+	.get_power	= max749_get_power,
+	.set_power	= max749_set_power,
+	.get_contrast	= max749_get_contrast,
+	.set_contrast	= max749_set_contrast
+};
+
+static ssize_t max749_reset(struct class_device *cdev,
+			    const char *buf, size_t count)
+{
+	struct lcd_device	*lcd = to_lcd_device(cdev);
+	struct max749_device	*dev = class_get_devdata(&lcd->class_dev);
+	int			is_hard_reset;
+
+	is_hard_reset = count>0 && simple_strtoul(buf, 0,0);
+
+	mutex_lock(&lcd->ops_lock);
+
+	if (is_hard_reset) {
+		dev->regulation = 0;
+		max749_set_contrast(lcd, 32);
+	}
+	else {
+		max749_set_state(dev, MAX749_STATE_RESET);
+		max749_set_contrast(lcd, dev->contrast);
+	}
+
+	mutex_unlock(&lcd->ops_lock);
+
+	return count;
+}
+
+static ssize_t max749_inc(struct class_device *cdev,
+			  const char *buf, size_t count)
+{
+	struct lcd_device	*lcd = to_lcd_device(cdev);
+	struct max749_device	*dev = class_get_devdata(&lcd->class_dev);
+	ssize_t			rc   = count;
+
+	mutex_lock(&lcd->ops_lock);
+	if (dev->contrast >= 63)
+		rc = -EOVERFLOW;
+	else
+		max749_set_contrast(lcd, dev->contrast+1);
+	mutex_unlock(&lcd->ops_lock);
+
+	return rc;
+}
+
+static ssize_t max749_dec(struct class_device *cdev,
+			  const char *buf, size_t count)
+{
+	struct lcd_device	*lcd = to_lcd_device(cdev);
+	struct max749_device	*dev = class_get_devdata(&lcd->class_dev);
+	ssize_t			rc   = count;
+
+	mutex_lock(&lcd->ops_lock);
+	if (dev->contrast < 1)
+		rc = -EOVERFLOW;
+	else
+		max749_set_contrast(lcd, dev->contrast-1);
+	mutex_unlock(&lcd->ops_lock);
+
+	return rc;
+}
+
+static ssize_t max749_regulation_show(struct class_device *cdev, char *buf)
+{
+	struct lcd_device	*lcd = to_lcd_device(cdev);
+	struct max749_device	*dev = class_get_devdata(&lcd->class_dev);
+	int rc;
+
+	mutex_lock(&lcd->ops_lock);
+	rc = sprintf(buf, "%d\n", dev->regulation);
+	mutex_unlock(&lcd->ops_lock);
+
+	return rc;
+}
+
+static ssize_t max749_regulation_store(struct class_device *cdev,
+				       const char *buf, size_t count)
+{
+	struct lcd_device	*lcd = to_lcd_device(cdev);
+	struct max749_device	*dev = class_get_devdata(&lcd->class_dev);
+	char			*endp;
+	int			regulation = simple_strtoul(buf, &endp, 0);
+
+	size_t			size = endp - buf;
+
+	if (*endp && isspace(*endp))
+		size++;
+	if (size != count || regulation>63)
+		return -EINVAL;
+
+	mutex_lock(&lcd->ops_lock);
+	dev->regulation = regulation;
+	max749_set_contrast(lcd, dev->contrast);
+	mutex_unlock(&lcd->ops_lock);
+
+	return count;
+}
+
+static const struct class_device_attribute max749_attributes[] = {
+	__ATTR(regulation, 0600, max749_regulation_show, max749_regulation_store),
+	__ATTR(reset,      0200, 0, max749_reset),
+	__ATTR(inc,        0200, 0, max749_inc),
+	__ATTR(dec,        0200, 0, max749_dec)
+};
+
+static int
+max749_register_dev(struct max749_device *dev)
+{
+	unsigned int			i;
+	int				rc;
+
+	dev->lcd = lcd_device_register("max749-lcd", dev,
+				       &max749_lcd_ops);
+
+	if (IS_ERR(dev->lcd)) {
+		rc = PTR_ERR(dev->lcd);
+		return rc;
+	}
+
+	for (i=0; i<ARRAY_SIZE(max749_attributes); ++i) {
+		rc = class_device_create_file(&dev->lcd->class_dev,
+					      max749_attributes+i);
+
+		if (unlikely(rc)) {
+			while (--i >= 0)
+				class_device_remove_file(&dev->lcd->class_dev,
+							 max749_attributes+i);
+
+			lcd_device_unregister(dev->lcd);
+			return rc;
+		}
+	}
+
+	return 0;
+}
+
+static int
+max749_lcd_probe(struct platform_device *pdev)
+{
+	struct max749_lcd_machinfo const	*info = pdev->dev.platform_data;
+	struct max749_device			*dev;
+	int					rc;
+
+	BUG_ON(info->set_adj==0 || info->set_ctrl==0);
+	dev = kzalloc(sizeof *dev, GFP_KERNEL);
+	if (dev==0)
+		return -ENOMEM;
+
+	dev->set_adj    = info->set_adj;
+	dev->set_ctrl   = info->set_ctrl;
+	dev->contrast   = 32;
+	dev->regulation = 20;
+	dev->state      = MAX749_STATE_SHUTDOWN;
+	dev->power      = FB_BLANK_UNBLANK;
+
+	rc = max749_register_dev(dev);
+	if (rc) {
+		dev_err(&pdev->dev, "failed to register LCD device: %i\n",
+			rc);
+
+		kfree(dev);
+		return rc;
+	}
+
+	dev->lcd->props.max_contrast = 63;
+	mutex_init(&dev->lock);
+
+	platform_set_drvdata(pdev, dev);
+
+	max749_set_state(dev, MAX749_STATE_SHUTDOWN);
+	max749_set_state(dev, MAX749_STATE_RESET);
+
+	dev_info(&pdev->dev, "MAX749 LCD Bias driver loaded\n");
+
+	return 0;
+}
+
+static int
+max749_lcd_remove(struct platform_device *pdev)
+{
+	struct max749_device		*dev = platform_get_drvdata(pdev);
+
+	if (dev) {
+		size_t			i;
+
+		max749_set_state(dev, MAX749_STATE_SHUTDOWN);
+
+		for (i=ARRAY_SIZE(max749_attributes); i>0; --i)
+			class_device_remove_file(&dev->lcd->class_dev,
+						 max749_attributes+i-1);
+
+		mutex_destroy(&dev->lock);
+		lcd_device_unregister(dev->lcd);
+		kfree(dev);
+
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+#  error Implement me!
+#else
+#define max749_lcd_suspend	NULL
+#define max749_lcd_resume	NULL
+#endif
+
+static struct platform_driver max749_lcd_driver = {
+	.probe		= max749_lcd_probe,
+	.remove		= max749_lcd_remove,
+	.suspend	= max749_lcd_suspend,
+	.resume		= max749_lcd_resume,
+	.driver		= {
+		.name	= "max749-lcd",
+	},
+};
+
+static int __init max749_lcd_init(void)
+{
+	return platform_driver_register(&max749_lcd_driver);
+}
+
+static void __exit max749_lcd_exit(void)
+{
+	platform_driver_unregister(&max749_lcd_driver);
+}
+
+module_init(max749_lcd_init);
+module_exit(max749_lcd_exit);
+
+MODULE_AUTHOR("Enrico Scholz <enrico.scholz@sigma-chemnitz.de>");
+MODULE_DESCRIPTION("MAX749 LCD Driver");
+MODULE_LICENSE("GPL");
diff -Naur linux-3.4.11/drivers/video/pxa168fb.c linux-HEAD/drivers/video/pxa168fb.c
--- linux-3.4.11/drivers/video/pxa168fb.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/video/pxa168fb.c	2015-11-18 09:04:24.000000000 +0000
@@ -417,7 +417,8 @@
 	else
 		info->fix.visual = FB_VISUAL_TRUECOLOR;
 	info->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
-	info->fix.ypanstep = var->yres;
+
+	set_graphics_start(info, var->xoffset, var->yoffset);
 
 	/*
 	 * Disable panel output while we setup the display.
@@ -581,6 +582,8 @@
 		fb_videomode_to_var(&info->var, m);
 
 	/* Init settings. */
+	var->width = mi->width;
+	var->height = mi->height;
 	var->xres_virtual = var->xres;
 	var->yres_virtual = info->fix.smem_len /
 		(var->xres_virtual * (var->bits_per_pixel >> 3));
@@ -654,13 +657,14 @@
 	 * Initialise static fb parameters.
 	 */
 	info->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK |
-		      FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
+		      FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN |
+		      FBINFO_VIRTFB;
 	info->node = -1;
 	strlcpy(info->fix.id, mi->id, 16);
 	info->fix.type = FB_TYPE_PACKED_PIXELS;
 	info->fix.type_aux = 0;
 	info->fix.xpanstep = 0;
-	info->fix.ypanstep = 0;
+	info->fix.ypanstep = 1;
 	info->fix.ywrapstep = 0;
 	info->fix.mmio_start = res->start;
 	info->fix.mmio_len = resource_size(res);
@@ -691,7 +695,6 @@
 	}
 
 	info->fix.smem_start = (unsigned long)fbi->fb_start_dma;
-	set_graphics_start(info, 0, 0);
 
 	/*
 	 * Set video mode according to platform data.
diff -Naur linux-3.4.11/drivers/video/pxafb.c linux-HEAD/drivers/video/pxafb.c
--- linux-3.4.11/drivers/video/pxafb.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/video/pxafb.c	2015-11-18 09:04:24.000000000 +0000
@@ -32,6 +32,7 @@
  *   All Rights Reserved
  */
 
+#undef DEBUG_TIMING
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/kernel.h>
@@ -590,7 +591,7 @@
 			fb_set_cmap(&fbi->fb.cmap, info);
 		pxafb_schedule_work(fbi, C_ENABLE);
 	}
-	return 0;
+	return (blank == FB_BLANK_NORMAL) ? 1 : 0;
 }
 
 static struct fb_ops pxafb_ops = {
@@ -1021,7 +1022,11 @@
 	 * speeds */
 	pcd = (unsigned long long)(clk_get_rate(fbi->clk) / 10000);
 	pcd *= pixclock;
-	do_div(pcd, 100000000 * 2);
+	if (!(fbi->reg_lccr4 & LCCR4_PCDDIV))
+		do_div(pcd, 100000000 * 2);
+	else
+		do_div(pcd, 100000000);
+	pcd -= 1;
 	/* no need for this, since we should subtract 1 anyway. they cancel */
 	/* pcd += 1; */ /* make up for integer math truncations */
 	return (unsigned int)pcd;
@@ -1376,13 +1381,16 @@
 	setup_base_frame(fbi, var, 0);
 
 	fbi->reg_lccr0 = fbi->lccr0 |
-		(LCCR0_LDM | LCCR0_SFM | LCCR0_IUM | LCCR0_EFM |
-		 LCCR0_QDM | LCCR0_BM  | LCCR0_OUM);
+		(LCCR0_LDM | LCCR0_SFM | LCCR0_EFM |
+#ifndef DEBUG_TIMING
+		 LCCR0_OUM | LCCR0_IUM |
+#endif
+		 LCCR0_QDM | LCCR0_BM);
 
 	fbi->reg_lccr3 |= pxafb_var_to_lccr3(var);
 
-	fbi->reg_lccr4 = lcd_readl(fbi, LCCR4) & ~LCCR4_PAL_FOR_MASK;
-	fbi->reg_lccr4 |= (fbi->lccr4 & LCCR4_PAL_FOR_MASK);
+	fbi->reg_lccr4 = lcd_readl(fbi, LCCR4) & ~(LCCR4_PAL_FOR_MASK|LCCR4_PCDDIV);
+	fbi->reg_lccr4 |= (fbi->lccr4 & (LCCR4_PAL_FOR_MASK|LCCR4_PCDDIV));
 	local_irq_restore(flags);
 
 	/*
@@ -1493,6 +1501,25 @@
 		complete(&fbi->disable_done);
 	}
 
+#ifdef DEBUG_TIMING
+	if (lcsr & LCSR_IUL)
+		printk(KERN_ERR "%s(): Input FIFO Underrun for Channel 0; LCSR=%08x\n",
+		       __FUNCTION__, lcsr);
+
+	if (lcsr & LCSR_IUU)
+		printk(KERN_ERR "%s(): Input FIFO Underrun for Channel 1; LCSR=%08x\n",
+		       __FUNCTION__, lcsr);
+
+	if (lcsr & LCSR_OU)
+		printk(KERN_ERR "%s(): Output FIFO Underrun; LCSR=%08x\n",
+		       __FUNCTION__, lcsr);
+#endif
+
+	if (lcsr & LCSR_BER)
+		printk(KERN_ERR "%s(): Bus Error on channel %u; LCSR=%08x\n",
+		       __FUNCTION__,
+		       (lcsr & LCSR_BER_CH_MASK) >> LCSR_BER_CH_S, lcsr);
+
 #ifdef CONFIG_FB_PXA_SMARTPANEL
 	if (lcsr & LCSR_CMD_INT)
 		complete(&fbi->command_done);
@@ -1708,15 +1735,14 @@
 
 static int __devinit pxafb_init_video_memory(struct pxafb_info *fbi)
 {
-	int size = PAGE_ALIGN(fbi->video_mem_size);
+	fbi->video_mem = dma_alloc_writecombine(fbi->dev,
+						fbi->video_mem_size,
+						&fbi->video_mem_phys,
+						GFP_KERNEL | __GFP_ZERO);
 
-	fbi->video_mem = alloc_pages_exact(size, GFP_KERNEL | __GFP_ZERO);
 	if (fbi->video_mem == NULL)
 		return -ENOMEM;
 
-	fbi->video_mem_phys = virt_to_phys(fbi->video_mem);
-	fbi->video_mem_size = size;
-
 	fbi->fb.fix.smem_start	= fbi->video_mem_phys;
 	fbi->fb.fix.smem_len	= fbi->video_mem_size;
 	fbi->fb.screen_base	= fbi->video_mem;
@@ -2247,7 +2273,8 @@
 failed_free_irq:
 	free_irq(irq, fbi);
 failed_free_mem:
-	free_pages_exact(fbi->video_mem, fbi->video_mem_size);
+	dma_free_writecombine(fbi->dev, fbi->video_mem_size,
+			      fbi->video_mem, fbi->video_mem_phys);
 failed_free_dma:
 	dma_free_coherent(&dev->dev, fbi->dma_buff_size,
 			fbi->dma_buff, fbi->dma_buff_phys);
@@ -2275,6 +2302,13 @@
 
 	info = &fbi->fb;
 
+#ifdef CONFIG_CPU_FREQ
+	cpufreq_unregister_notifier(&fbi->freq_policy,
+				    CPUFREQ_POLICY_NOTIFIER);
+	cpufreq_unregister_notifier(&fbi->freq_transition,
+				    CPUFREQ_TRANSITION_NOTIFIER);
+#endif
+
 	pxafb_overlay_exit(fbi);
 	unregister_framebuffer(info);
 
@@ -2286,7 +2320,8 @@
 	irq = platform_get_irq(dev, 0);
 	free_irq(irq, fbi);
 
-	free_pages_exact(fbi->video_mem, fbi->video_mem_size);
+	dma_free_writecombine(fbi->dev, fbi->video_mem_size,
+			      fbi->video_mem, fbi->video_mem_phys);
 
 	dma_free_writecombine(&dev->dev, fbi->dma_buff_size,
 			fbi->dma_buff, fbi->dma_buff_phys);
diff -Naur linux-3.4.11/drivers/video/pxafb.h linux-HEAD/drivers/video/pxafb.h
--- linux-3.4.11/drivers/video/pxafb.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/video/pxafb.h	2015-11-18 09:04:24.000000000 +0000
@@ -119,7 +119,7 @@
 	dma_addr_t		fdadr[DMA_MAX * 2];
 
 	void __iomem		*video_mem;	/* virtual address of frame buffer */
-	unsigned long		video_mem_phys;	/* physical address of frame buffer */
+	dma_addr_t		video_mem_phys;	/* physical address of frame buffer */
 	size_t			video_mem_size;	/* size of the frame buffer */
 	u16 *			palette_cpu;	/* virtual address of palette memory */
 	u_int			palette_size;
diff -Naur linux-3.4.11/drivers/watchdog/gpio_wdt.c linux-HEAD/drivers/watchdog/gpio_wdt.c
--- linux-3.4.11/drivers/watchdog/gpio_wdt.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/watchdog/gpio_wdt.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,153 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/watchdog.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+
+
+struct gpiowd_device {
+	struct watchdog_device		wd;
+	int				gpio;
+	unsigned long			flags;
+};
+
+static struct watchdog_info const	gpiowd_info = {
+	.options	= WDIOF_KEEPALIVEPING,
+	.identity	= "GPIO",
+};
+
+static int gpiowd_ping(struct watchdog_device *wd)
+{
+	struct gpiowd_device	*gwd =
+		container_of(wd, struct gpiowd_device, wd);
+	int			st = test_and_change_bit(0, &gwd->flags);
+
+	gpio_set_value_cansleep(gwd->gpio, st);
+	return 0;
+}
+
+static struct watchdog_ops const	gpiowd_ops = {
+	.owner		= THIS_MODULE,
+	.start		= gpiowd_ping,
+	.stop		= gpiowd_ping,
+	.ping		= gpiowd_ping,
+};
+
+static int __devinit gpiowd_probe(struct platform_device *pdev)
+{
+	struct gpiowd_device	*gwd;
+	int			rc;
+	int			gpio;
+	bool			st;
+
+	gwd = kzalloc(sizeof *gwd, GFP_KERNEL);
+	if (!gwd)
+		return -ENOMEM;
+
+	gwd->gpio = -1;
+
+	gpio = (uintptr_t)(pdev->dev.platform_data);
+	if (!gpio_is_valid(gpio)) {
+		dev_warn(&pdev->dev, "platform gpio %d not valid\n", gpio);
+		rc = -EINVAL;
+		goto out;
+	}
+
+	rc = gpio_request(gpio, "WATCHDOG");
+	if (rc < 0) {
+		dev_warn(&pdev->dev, "failed to request gpio %d: %d\n", 
+			 gpio, rc);
+		goto out;
+	}
+
+	gwd->gpio = gpio;
+
+	st = gpio_get_value_cansleep(gwd->gpio);
+	rc = gpio_direction_output(gwd->gpio, st);
+	if (rc < 0) {
+		dev_warn(&pdev->dev, "failed to configure gpio %d: %d\n", 
+			 gpio, rc);
+		goto out;
+	}
+
+	if (st)
+		clear_bit(0, &gwd->flags);
+	else
+		set_bit(0, &gwd->flags);
+
+	gwd->wd.info = &gpiowd_info;
+	gwd->wd.ops  = &gpiowd_ops;
+
+	watchdog_set_nowayout(&gwd->wd, true);
+	rc = watchdog_register_device(&gwd->wd);
+	if (rc < 0) {
+		dev_warn(&pdev->dev, "failed to register watchdog: %d\n", rc);
+		goto out;
+	}
+
+	rc = device_move(gwd->wd.dev, &pdev->dev, DPM_ORDER_NONE);
+	if (rc < 0)
+		dev_warn(gwd->wd.dev, "failed to reassign parent: %d\n", rc);
+
+	platform_set_drvdata(pdev, gwd);
+
+	dev_info(gwd->wd.dev, "watchdog for gpio %d initialized\n", gwd->gpio);
+	rc = 0;
+
+out:
+	if (rc < 0) {
+		if (gwd->gpio != -1) {
+			gpio_direction_input(gwd->gpio);
+			gpio_free(gwd->gpio);
+		}
+
+		kfree(gwd);
+	}
+
+	return rc;
+}
+
+static int __devexit gpiowd_remove(struct platform_device *pdev)
+{
+	struct gpiowd_device	*gwd = platform_get_drvdata(pdev);
+
+	watchdog_unregister_device(&gwd->wd);
+
+	gpio_direction_input(gwd->gpio);
+	gpio_free(gwd->gpio);
+	kfree(gwd);
+
+	return 0;
+}
+
+static struct platform_driver	gpiowd_driver = {
+	.driver = {
+		.name	=  "gpio-wdt",
+		.owner	=  THIS_MODULE,
+	},
+	.probe	=  gpiowd_probe,
+	.remove	=  __devexit_p(gpiowd_remove),
+};
+
+module_platform_driver(gpiowd_driver);
+
+MODULE_AUTHOR("Enrico Scholz <enrico.scholz@sigma-chemnitz.de>");
+MODULE_DESCRIPTION("Driver for gpio driven watchdogs");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:gpio-wdt");
diff -Naur linux-3.4.11/drivers/watchdog/Kconfig linux-HEAD/drivers/watchdog/Kconfig
--- linux-3.4.11/drivers/watchdog/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/watchdog/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -64,6 +64,10 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called softdog.
 
+config GPIO_WATCHDOG
+        tristate "GPIO driven watchdog"
+	select WATCHDOG_CORE
+
 config WM831X_WATCHDOG
 	tristate "WM831x watchdog"
 	depends on MFD_WM831X
@@ -349,6 +353,16 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called imx2_wdt.
 
+config PXA168_WATCHDOG
+	tristate "PXA168 watchdog"
+	depends on ARCH_PXA168
+	help
+	  Watchdog timer embedded into PXA168 chips. This will reboot
+	  your system when timeout is reached.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called pxa168_wdt.
+
 # AVR32 Architecture
 
 config AT32AP700X_WDT
diff -Naur linux-3.4.11/drivers/watchdog/Makefile linux-HEAD/drivers/watchdog/Makefile
--- linux-3.4.11/drivers/watchdog/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/watchdog/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -53,6 +53,7 @@
 obj-$(CONFIG_NUC900_WATCHDOG) += nuc900_wdt.o
 obj-$(CONFIG_TS72XX_WATCHDOG) += ts72xx_wdt.o
 obj-$(CONFIG_IMX2_WDT) += imx2_wdt.o
+obj-$(CONFIG_PXA168_WATCHDOG) += pxa168_wdt.o
 
 # AVR32 Architecture
 obj-$(CONFIG_AT32AP700X_WDT) += at32ap700x_wdt.o
@@ -167,3 +168,4 @@
 obj-$(CONFIG_WM8350_WATCHDOG) += wm8350_wdt.o
 obj-$(CONFIG_MAX63XX_WATCHDOG) += max63xx_wdt.o
 obj-$(CONFIG_SOFT_WATCHDOG) += softdog.o
+obj-$(CONFIG_GPIO_WATCHDOG) += gpio_wdt.o
diff -Naur linux-3.4.11/drivers/watchdog/pxa168_wdt.c linux-HEAD/drivers/watchdog/pxa168_wdt.c
--- linux-3.4.11/drivers/watchdog/pxa168_wdt.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/watchdog/pxa168_wdt.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,327 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/watchdog.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <asm/io.h>
+
+#include <mach/addr-map.h>
+#include <mach/cputype.h>
+
+#include "pxa168_wdt.h"
+
+static unsigned int margin __initdata = 60; /* (secs) Default is 1 minute */
+module_param(margin, uint, 0);
+MODULE_PARM_DESC(margin, "Watchdog margin in seconds (default 60s)");
+
+static bool nowayout = WATCHDOG_NOWAYOUT;
+module_param(nowayout, bool, 0);
+MODULE_PARM_DESC(nowayout,
+		 "Watchdog cannot be stopped once started (default="
+		 __MODULE_STRING(WATCHDOG_NOWAYOUT) ")");
+
+struct pxa168_wdt_device {
+	struct clk		*clk;
+	struct watchdog_device	wd;
+	unsigned long		flags;
+	spinlock_t		lock;
+	uint16_t		wtm;
+
+	void __iomem		*wdbase;
+	void __iomem		*mpmubase;
+};
+
+#define to_pxa168(_wd) \
+	container_of(_wd, struct pxa168_wdt_device, wd)
+
+#define file_to_wdt(_fp) \
+	container_of((_fp)->private_data, struct pxa168_wdt_device, misc)
+
+static struct watchdog_info const	pxa168_wdt_ident = {
+	.options	= (WDIOF_CARDRESET | WDIOF_SETTIMEOUT |
+			   WDIOF_KEEPALIVEPING),
+	.identity	= "PXA168 Watchdog",
+	.firmware_version	= 1,
+};
+
+static void pxa168_wdt_device_unlock(struct pxa168_wdt_device *wdt)
+{
+	__raw_writel(TMR_WFAR_KEY, wdt->wdbase + TMR_WFAR);
+	__raw_writel(TMR_WSAR_KEY, wdt->wdbase + TMR_WSAR);
+}
+
+static void pxa168_wdt_device_write(struct pxa168_wdt_device *wdt,
+				    uint32_t v, uintptr_t reg)
+{
+	pxa168_wdt_device_unlock(wdt);
+	__raw_writel(v, wdt->wdbase + reg);
+}
+
+static signed long pxa168_wdt_calc_wtm(struct pxa168_wdt_device *wdt,
+				       unsigned long ms)
+{
+	unsigned long	rate = clk_get_rate(wdt->clk);
+	signed long	res = rate * ms / 1000 + 1;
+
+	if (res >= (1 << 16)) {
+		dev_warn(wdt->wd.dev, "invalid margin %lu\n", ms);
+		res = -1;
+	}
+
+	return res;
+}
+
+static int pxa168_wdt_calc_margin(struct pxa168_wdt_device *wdt, uint16_t wtm)
+{
+	unsigned long	rate = clk_get_rate(wdt->clk);
+	signed long	res = wtm * 1000 / rate;
+
+	return res;
+}
+
+static int pxa168_wdt_ping(struct watchdog_device *wd_)
+{
+	struct pxa168_wdt_device	*wdt = to_pxa168(wd_);
+	unsigned long			flags;
+
+	spin_lock_irqsave(&wdt->lock, flags);
+	pxa168_wdt_device_unlock(wdt);
+	pxa168_wdt_device_write(wdt, TMR_WCR_WCR, TMR_WCR);
+	spin_unlock_irqrestore(&wdt->lock, flags);
+
+	return 0;
+}
+
+static int pxa168_wdt_start(struct watchdog_device *wd_)
+{
+	struct pxa168_wdt_device	*wdt = to_pxa168(wd_);
+	unsigned long			flags;
+
+	clk_enable(wdt->clk);
+
+	spin_lock_irqsave(&wdt->lock, flags);
+
+	/* enable WDT reset; there is no way out from this */
+	__raw_writel(__raw_readl(wdt->mpmubase + MPMU_APRR) | MPMU_APRR_WDTR,
+		     wdt->mpmubase + MPMU_APRR);
+
+	pxa168_wdt_device_write(wdt, 0, TMR_WSR); /* clear status */
+	pxa168_wdt_device_write(wdt, wdt->wtm, TMR_WMR);
+	pxa168_wdt_device_write(wdt, TMR_WMER_WE | TMR_WMER_WRIE, TMR_WMER);
+
+	/* enable FNCLK */
+	__raw_writel(__raw_readl(wdt->mpmubase + MPMU_WDTPCR) |
+		     MPMU_WDTPCR_FNCLK, wdt->mpmubase + MPMU_WDTPCR);
+
+	spin_unlock_irqrestore(&wdt->lock, flags);
+
+	pxa168_wdt_ping(wd_);
+
+	return 0;
+}
+
+static int pxa168_wdt_stop(struct watchdog_device *wd_)
+{
+	struct pxa168_wdt_device	*wdt = to_pxa168(wd_);
+	unsigned long			flags;
+
+	pxa168_wdt_ping(wd_);
+
+	if (!nowayout) {
+		spin_lock_irqsave(&wdt->lock, flags);
+
+		/* clear WE; keep WRIE */
+		pxa168_wdt_device_write(wdt, TMR_WMER_WRIE, TMR_WMER);
+
+		/* disable FNCLK */
+		__raw_writel(__raw_readl(wdt->mpmubase + MPMU_WDTPCR) &
+			     ~MPMU_WDTPCR_FNCLK,
+			     wdt->mpmubase + MPMU_WDTPCR);
+
+		spin_unlock_irqrestore(&wdt->lock, flags);
+
+		dev_info(wdt->wd.dev, "disabled watchdog timer\n");
+	}
+
+	clk_disable(wdt->clk);
+
+	return 0;
+}
+
+static int pxa168_wdt_set_timeout(struct watchdog_device *wd_,
+				  unsigned int time_ms)
+{
+	struct pxa168_wdt_device	*wdt = to_pxa168(wd_);
+	unsigned long			flags;
+	signed long			wtm;
+	int				rc;
+
+	wtm = pxa168_wdt_calc_wtm(wdt, time_ms);
+	if (wtm < 0) {
+		rc = -EINVAL;
+		goto out;
+	}
+
+	spin_lock_irqsave(&wdt->lock, flags);
+	wdt->wtm = wtm;
+	pxa168_wdt_device_write(wdt, wdt->wtm, TMR_WMR);
+	spin_unlock_irqrestore(&wdt->lock, flags);
+
+	wdt->wd.timeout = pxa168_wdt_calc_margin(wdt, wdt->wtm) / 1000;
+
+	pxa168_wdt_ping(wd_);
+
+out:
+	return rc;
+}
+
+
+static struct watchdog_ops const	pxa168_wdt_ops = {
+	.owner		= THIS_MODULE,
+	.start		= pxa168_wdt_start,
+	.stop		= pxa168_wdt_stop,
+	.ping		= pxa168_wdt_ping,
+	.set_timeout	= pxa168_wdt_set_timeout,
+};
+
+static int __devinit pxa168_wdt_probe(struct platform_device *pdev)
+{
+	struct pxa168_wdt_device	*wdt;
+	int				rc;
+	signed long			wtm;
+
+	wdt = kzalloc(sizeof *wdt, GFP_KERNEL);
+	if (!wdt) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	if (cpu_is_pxa168()) {
+		wdt->mpmubase = (void __iomem *)(APB_VIRT_BASE + 0x50000);
+		wdt->wdbase = (void __iomem *)(APB_VIRT_BASE + 0x14000);
+	} else {
+		rc = -ENXIO;
+		goto out;
+	}
+
+	spin_lock_init(&wdt->lock);
+
+	wdt->clk = clk_get(&pdev->dev, "WDTCLK");
+	if (IS_ERR(wdt->clk)) {
+		rc = -PTR_ERR(wdt->clk);
+		wdt->clk = NULL;
+		dev_err(&pdev->dev, "failed to get clock: %d\n", rc);
+		goto out;
+	}
+
+	rc = clk_prepare(wdt->clk);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to prepare clock: %d\n", rc);
+		clk_put(wdt->clk);
+		wdt->clk = NULL;
+		goto out;
+	}
+
+	wtm = pxa168_wdt_calc_wtm(wdt, margin * 1000);
+	if (wtm < 0) {
+		rc = -EINVAL;
+		goto out;
+	}
+	wdt->wtm = wtm;
+
+	clk_enable(wdt->clk);
+	if ((__raw_readl(wdt->mpmubase + MPMU_APRR) & MPMU_APRR_WDTR) == 0)
+		wdt->wd.bootstatus |= WDIOF_CARDRESET;
+	clk_disable(wdt->clk);
+
+	if (clk_get_rate(wdt->clk) == 0) {
+		dev_err(&pdev->dev, "failed to calculate clock rate\n");
+		rc = -EIO;
+		goto out;
+	}
+
+	watchdog_set_nowayout(&wdt->wd, nowayout);
+
+	wdt->wd.info = &pxa168_wdt_ident;
+	wdt->wd.ops  = &pxa168_wdt_ops;
+	wdt->wd.min_timeout = 1;
+	wdt->wd.max_timeout = (1 << 16) * 1000 / clk_get_rate(wdt->clk);
+
+	rc = watchdog_register_device(&wdt->wd);
+	if (rc < 0) {
+		dev_err(&pdev->dev, "failed to register watchdog device: %d\n",
+			rc);
+		goto out;
+	}
+
+	rc = device_move(wdt->wd.dev, &pdev->dev, DPM_ORDER_NONE);
+	if (rc < 0)
+		dev_warn(wdt->wd.dev, "failed to reassign parent: %d\n", rc);
+
+	dev_set_drvdata(&pdev->dev, wdt);
+
+	dev_info(wdt->wd.dev, "PXA168 Watchdog Timer; margin %us\n", margin);
+	rc = 0;
+
+out:
+	if (rc < 0) {
+		if (wdt->clk) {
+			clk_unprepare(wdt->clk);
+			clk_put(wdt->clk);
+		}
+
+		kfree(wdt);
+	}
+
+	return rc;
+}
+
+static int __devexit pxa168_wdt_remove(struct platform_device *pdev)
+{
+	struct pxa168_wdt_device	*wdt = dev_get_drvdata(&pdev->dev);
+
+	watchdog_unregister_device(&wdt->wd);
+	if (!nowayout)
+		clk_unprepare(wdt->clk);
+
+	clk_put(wdt->clk);
+	kfree(wdt);
+
+	return 0;
+}
+
+static struct platform_driver pxa168_wdt_driver = {
+	.driver		= {
+		.name	= "pxa168-wdt",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= pxa168_wdt_probe,
+	.remove		= __devexit_p(pxa168_wdt_remove),
+};
+
+module_platform_driver(pxa168_wdt_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Enrico Scholz <enrico.scholz@sigma-chemnitz.de>");
+MODULE_ALIAS("platform:pxa168-wdt");
diff -Naur linux-3.4.11/drivers/watchdog/pxa168_wdt.h linux-HEAD/drivers/watchdog/pxa168_wdt.h
--- linux-3.4.11/drivers/watchdog/pxa168_wdt.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/drivers/watchdog/pxa168_wdt.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,52 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_LINUX_DRIVERS_WATCHDOG_PXA168_WDT_H
+#define H_LINUX_DRIVERS_WATCHDOG_PXA168_WDT_H
+
+#define TMR_WFAR	0x9c		/* 1st Access Register */
+#define TMR_WFAR_KEY	0xbaba
+#define TMR_WSAR	0xa0		/* 2nd Access Register */
+#define TMR_WSAR_KEY	0xeb10
+
+#define TMR_WCR		0x98		/* Counter Reset Register */
+#define TMR_WCR_WCR	(1u << 0)	/* counter value reset */
+
+#define TMR_WSR		0x70		/* Status Register */
+#define TMR_WSR_WTS	(1u << 0)	/* reset indication */
+
+#define TMR_WVR		0x6c		/* Value Register */
+#define TMR_WVR_WTV_msk	(0xffffu << 0)	/* timer value mask */
+
+#define TMR_WMR		0x68		/* Match Register */
+#define TMR_WMR_WTM_msk	(0xffffu << 0)	/* timer match mask */
+
+#define TMR_WMER	0x64		/* Match Enable Register */
+#define TMR_WMER_WE	(1u << 0)	/* count enable */
+#define TMR_WMER_WRIE	(1u << 1)	/* reset/interrupt enable */
+
+
+
+#define MPMU_WDTPCR		0x0200	/* Watch Dog Timer */
+#define MPMU_WDTPCR_ABCLK	(1u << 0) /* APB bus clock enable/disable */
+#define MPMU_WDTPCR_FNCLK	(1u << 1) /* Timers + WDT functional clock */
+#define MPMU_WDTPCR_AWDTRST	(1u << 2) /* WDT reset */
+
+#define MPMU_APRR		0x1020	  /* Programmable Reset Register */
+#define MPMU_APRR_WDTR		(1u << 4) /* hw reset <-> wdt reset */
+#define MPMU_APRR_SLAVE_R	(1u << 6) /* slave set reset out */
+
+#endif	/* H_LINUX_DRIVERS_WATCHDOG_PXA168_WDT_H */
diff -Naur linux-3.4.11/drivers/watchdog/watchdog_dev.c linux-HEAD/drivers/watchdog/watchdog_dev.c
--- linux-3.4.11/drivers/watchdog/watchdog_dev.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/drivers/watchdog/watchdog_dev.c	2015-11-18 09:04:24.000000000 +0000
@@ -42,10 +42,15 @@
 #include <linux/init.h>		/* For __init/__exit/... */
 #include <linux/uaccess.h>	/* For copy_to_user/put_user/... */
 
-/* make sure we only register one /dev/watchdog device */
-static unsigned long watchdog_dev_busy;
+static struct class *watchdog_class;	/* So we have someone to create
+					   our devices */
+
+static dev_t dog_devt;		/* Watchdog device range */
+static unsigned long dog_mask;	/* Watchdogs that are in use */
 /* the watchdog device behind /dev/watchdog */
-static struct watchdog_device *wdd;
+static struct watchdog_device *old_wdd;
+
+#define DOG_MAX		32	/* assign_id must be changed to boost this */
 
 /*
  *	watchdog_ping: ping the watchdog.
@@ -136,6 +141,7 @@
 static ssize_t watchdog_write(struct file *file, const char __user *data,
 						size_t len, loff_t *ppos)
 {
+	struct watchdog_device *wdd = file->private_data;
 	size_t i;
 	char c;
 
@@ -175,6 +181,7 @@
 static long watchdog_ioctl(struct file *file, unsigned int cmd,
 							unsigned long arg)
 {
+	struct watchdog_device *wdd = file->private_data;
 	void __user *argp = (void __user *)arg;
 	int __user *p = argp;
 	unsigned int val;
@@ -256,7 +263,8 @@
  *	it can only be opened once.
  */
 
-static int watchdog_open(struct inode *inode, struct file *file)
+static int watchdog_do_open(struct watchdog_device *wdd,
+				struct inode *inode, struct file *file)
 {
 	int err = -EBUSY;
 
@@ -275,6 +283,8 @@
 	if (err < 0)
 		goto out_mod;
 
+	file->private_data = wdd;
+
 	/* dev/watchdog is a virtual (and thus non-seekable) filesystem */
 	return nonseekable_open(inode, file);
 
@@ -286,7 +296,40 @@
 }
 
 /*
- *      watchdog_release: release the /dev/watchdog device.
+ *	watchdog_open: open the /dev/watchdog device.
+ *	@inode: inode of device
+ *	@file: file handle to device
+ *
+ *	When the /dev/watchdog device gets opened, we start the watchdog.
+ *	Watch out: the /dev/watchdog device is single open, so we make sure
+ *	it can only be opened once.
+ */
+
+static int watchdog_open(struct inode *inode, struct file *file)
+{
+	return watchdog_do_open(old_wdd, inode, file);
+}
+
+/*
+ *	watchdog_mopen: open the newer watchdog devices.
+ *	@inode: inode of device
+ *	@file: file handle to device
+ *
+ *	When the watchdog device gets opened, we start the watchdog.
+ *	Watch out: the /dev/watchdog device is single open, so we make sure
+ *	it can only be opened once.
+ */
+
+static int watchdog_mopen(struct inode *inode, struct file *file)
+{
+	struct watchdog_device *wdd = container_of(inode->i_cdev,
+		struct watchdog_device, cdev);
+
+	return watchdog_do_open(wdd, inode, file);
+}
+
+/*
+ *      watchdog_release: release the watchdog device.
  *      @inode: inode of device
  *      @file: file handle to device
  *
@@ -297,6 +340,7 @@
 
 static int watchdog_release(struct inode *inode, struct file *file)
 {
+	struct watchdog_device *wdd = file->private_data;
 	int err = -EBUSY;
 
 	/*
@@ -331,69 +375,188 @@
 	.release	= watchdog_release,
 };
 
+static const struct file_operations watchdog_multi_fops = {
+	.owner		= THIS_MODULE,
+	.write		= watchdog_write,
+	.unlocked_ioctl	= watchdog_ioctl,
+	.open		= watchdog_mopen,
+	.release	= watchdog_release,
+};
+
 static struct miscdevice watchdog_miscdev = {
 	.minor		= WATCHDOG_MINOR,
 	.name		= "watchdog",
 	.fops		= &watchdog_fops,
 };
 
-/*
- *	watchdog_dev_register:
- *	@watchdog: watchdog device
+/**
+ *	watchdog_assign_id	-	pick a free watchdog ident
+ *	@watchdog: the watchdog device
+ *	@first: number to scan from
+ *
+ *	Assign a watchdog number to the device. For the moment we support
+ *	a starting offset so that a legacy watchdog can be worked around
+ */
+static int watchdog_assign_id(struct watchdog_device *watchdog, int first)
+{
+	int i;
+	for (i = first; i < DOG_MAX; i ++) {
+		if (test_and_set_bit(i, &dog_mask) == 0) {
+			watchdog->id = i;
+			return i;
+		}
+	}
+	pr_err("no free watchdog slots.\n");
+	return -EBUSY;
+}
+
+/**
+ *	watchdog_release_id	-	release a watchdg id
+ *	@watchdog: the watchdog device
  *
- *	Register a watchdog device as /dev/watchdog. /dev/watchdog
- *	is actually a miscdevice and thus we set it up like that.
+ *	Release the identifier associated with this watchdog. All cdev
+ *	resources must have been released first.
  */
+static void watchdog_release_id(struct watchdog_device *watchdog)
+{
+	clear_bit(watchdog->id, &dog_mask);
+}
 
-int watchdog_dev_register(struct watchdog_device *watchdog)
+/**
+ *	watchdog_add_device	-	add a watchdog device
+ *	@watchdog: the watchdog device
+ *
+ *	Add a watchdog device node to the system and set up all the
+ *	needed structures.
+ */
+static int watchdog_add_device(struct watchdog_device *watchdog)
 {
 	int err;
 
-	/* Only one device can register for /dev/watchdog */
-	if (test_and_set_bit(0, &watchdog_dev_busy)) {
-		pr_err("only one watchdog can use /dev/watchdog\n");
-		return -EBUSY;
+	/* Fill in the data structures */
+	watchdog->devt = MKDEV(MAJOR(dog_devt), watchdog->id);
+	watchdog->cdev.owner = watchdog->ops->owner;
+	cdev_init(&watchdog->cdev, &watchdog_multi_fops);
+	/* Add the device */
+	err  = cdev_add(&watchdog->cdev, watchdog->devt, 1);
+	if (err) {
+		pr_err("watchdog%d unable to add device %d:%d\n",
+			watchdog->id,  MAJOR(dog_devt), watchdog->id);
+		return err;
 	}
-
-	wdd = watchdog;
-
-	err = misc_register(&watchdog_miscdev);
-	if (err != 0) {
-		pr_err("%s: cannot register miscdev on minor=%d (err=%d)\n",
-		       watchdog->info->identity, WATCHDOG_MINOR, err);
-		goto out;
+	watchdog->dev = device_create(watchdog_class, watchdog->busdev,
+					MKDEV(MAJOR(dog_devt), watchdog->id),
+					NULL, "watchdog%d", watchdog->id);
+	if (IS_ERR(watchdog->dev)) {
+		cdev_del(&watchdog->cdev);
+		return PTR_ERR(watchdog->dev);
 	}
-
 	return 0;
+}
 
-out:
-	wdd = NULL;
-	clear_bit(0, &watchdog_dev_busy);
+/**
+ *	watchdog_del_device	-	delete a watchdog device
+ *	@watchdog: the watchdog device
+ *
+ *	Delete a watchdog device cdev object
+ */
+static void watchdog_del_device(struct watchdog_device *watchdog)
+{
+	cdev_del(&watchdog->cdev);
+	device_destroy(watchdog_class, MKDEV(MAJOR(dog_devt), watchdog->id));
+}	
+
+/**
+ *	watchdog_dev_register 	-	register a watchdog
+ *	@watchdog: watchdog device
+ *
+ *	Register a watchdog device including handling the legacy
+ *	/dev/watchdog node. /dev/watchdog is actually a miscdevice and
+ *	thus we set it up like that.
+ */
+int watchdog_dev_register(struct watchdog_device *watchdog)
+{
+	int err;
+
+	err = watchdog_assign_id(watchdog, 0);
+	if (err < 0)
+		return err;
+	if (err == 0) {
+		err = misc_register(&watchdog_miscdev);
+		if (err == 0)
+			old_wdd = watchdog;
+		else {
+			pr_err("%s: cannot register miscdev on minor=%d (err=%d).\n",
+				watchdog->info->identity, WATCHDOG_MINOR, err);
+			if (err == -EBUSY) {
+				pr_err("%s: probably a legacy watchdog module is present.\n",
+					watchdog->info->identity);
+				watchdog_release_id(watchdog);
+				err = watchdog_assign_id(watchdog, 1);
+			}
+			if (err < 0)
+				return err;
+		}
+	}
+	err = watchdog_add_device(watchdog);
+	if (err < 0) {
+		if (watchdog->id == 0) {
+			misc_deregister(&watchdog_miscdev);
+			old_wdd = NULL;
+		}
+		watchdog_release_id(watchdog);
+	}
 	return err;
 }
 
-/*
- *	watchdog_dev_unregister:
+/**
+ *	watchdog_dev_unregister		-	unregister a watchdog
  *	@watchdog: watchdog device
  *
- *	Deregister the /dev/watchdog device.
+ *	Unregister the watchdog and if needed the legacy /dev/watchdog device.
  */
-
 int watchdog_dev_unregister(struct watchdog_device *watchdog)
 {
-	/* Check that a watchdog device was registered in the past */
-	if (!test_bit(0, &watchdog_dev_busy) || !wdd)
-		return -ENODEV;
-
-	/* We can only unregister the watchdog device that was registered */
-	if (watchdog != wdd) {
-		pr_err("%s: watchdog was not registered as /dev/watchdog\n",
-		       watchdog->info->identity);
-		return -ENODEV;
+	watchdog_del_device(watchdog);
+	if (watchdog->id == 0) {
+		misc_deregister(&watchdog_miscdev);
+		old_wdd = NULL;
 	}
+	watchdog_release_id(watchdog);
+	return 0;
+}
 
-	misc_deregister(&watchdog_miscdev);
-	wdd = NULL;
-	clear_bit(0, &watchdog_dev_busy);
+/**
+ *	watchdog_init	-	module init call
+ *
+ *	Allocate a range of chardev nodes to use for watchdog devices
+ */
+int __init watchdog_init(void)
+{
+	int err = alloc_chrdev_region(&dog_devt, 0, DOG_MAX, "watchdog");
+	if (err < 0) {
+		pr_err("watchdog: unable to allocate char dev region\n");
+		return err;
+	}
+	watchdog_class = class_create(THIS_MODULE, "watchdog");
+	if (IS_ERR(watchdog_class)) {
+		unregister_chrdev_region(dog_devt, DOG_MAX);
+		return PTR_ERR(watchdog_class);
+	}
 	return 0;
 }
+
+/**
+ *	watchdog_exit	-	module exit
+ *
+ *	Release the range of chardev nodes used for watchdog devices
+ */
+void __exit watchdog_exit(void)
+{
+	unregister_chrdev_region(dog_devt, DOG_MAX);
+	class_destroy(watchdog_class);
+}
+
+subsys_initcall(watchdog_init);
+module_exit(watchdog_exit);
+
diff -Naur linux-3.4.11/fs/Kconfig linux-HEAD/fs/Kconfig
--- linux-3.4.11/fs/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/fs/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -243,6 +243,27 @@
 
 source "fs/nfs/Kconfig"
 source "fs/nfsd/Kconfig"
+config NFS_FAKE_UID
+	bool "SECURITY! Map an user uid to root"
+	depends on ROOT_NFS && DANGEROUS
+	help
+	  When mounting an NFS filesystem, map a certain uid to root.
+
+          This is a pure development option used to allow to
+          create/develop a root filesystem as a non-root user.
+
+          DO NOT use it for productive systems.
+
+config NFS_FAKE_UID_NUMBER
+	int "Mapped UID"
+	depends on NFS_FAKE_UID
+	default 500
+	help
+	  The uid which shall be mapped to 'root' when mounting an NFS
+	  filesystem.
+
+	  Use '-1' to map every uid to 'root'.
+
 
 config LOCKD
 	tristate
diff -Naur linux-3.4.11/fs/nfs/nfs2xdr.c linux-HEAD/fs/nfs/nfs2xdr.c
--- linux-3.4.11/fs/nfs/nfs2xdr.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/fs/nfs/nfs2xdr.c	2015-11-18 09:04:24.000000000 +0000
@@ -295,6 +295,16 @@
 	fattr->nlink = be32_to_cpup(p++);
 	fattr->uid = be32_to_cpup(p++);
 	fattr->gid = be32_to_cpup(p++);
+
+#ifdef CONFIG_NFS_FAKE_UID
+#warning "NFS driver will be built with NFS_FAKE_UID support lowering security"
+
+	if (CONFIG_NFS_FAKE_UID_NUMBER==-1 ||
+	    fattr->uid==CONFIG_NFS_FAKE_UID_NUMBER) fattr->uid = 0;
+	if (CONFIG_NFS_FAKE_UID==-1 ||
+	    fattr->gid==CONFIG_NFS_FAKE_UID_NUMBER) fattr->gid = 0;
+#endif
+
 	fattr->size = be32_to_cpup(p++);
 	fattr->du.nfs2.blocksize = be32_to_cpup(p++);
 
diff -Naur linux-3.4.11/fs/nfs/nfs3xdr.c linux-HEAD/fs/nfs/nfs3xdr.c
--- linux-3.4.11/fs/nfs/nfs3xdr.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/fs/nfs/nfs3xdr.c	2015-11-18 09:04:24.000000000 +0000
@@ -664,6 +664,15 @@
 	fattr->uid = be32_to_cpup(p++);
 	fattr->gid = be32_to_cpup(p++);
 
+#ifdef CONFIG_NFS_FAKE_UID
+#warning "NFS driver will be built with NFS_FAKE_UID support lowering security"
+
+	if (CONFIG_NFS_FAKE_UID_NUMBER==-1 ||
+	    fattr->uid==CONFIG_NFS_FAKE_UID_NUMBER) fattr->uid = 0;
+	if (CONFIG_NFS_FAKE_UID==-1 ||
+	    fattr->gid==CONFIG_NFS_FAKE_UID_NUMBER) fattr->gid = 0;
+#endif
+
 	p = xdr_decode_size3(p, &fattr->size);
 	p = xdr_decode_size3(p, &fattr->du.nfs3.used);
 	p = xdr_decode_specdata3(p, &fattr->rdev);
diff -Naur linux-3.4.11/fs/nfs/nfs4xdr.c linux-HEAD/fs/nfs/nfs4xdr.c
--- linux-3.4.11/fs/nfs/nfs4xdr.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/fs/nfs/nfs4xdr.c	2015-11-18 09:04:24.000000000 +0000
@@ -4296,6 +4296,15 @@
 		goto xdr_error;
 	fattr->valid |= status;
 
+#ifdef CONFIG_NFS_FAKE_UID
+#warning "NFS driver will be built with NFS_FAKE_UID support lowering security"
+
+	if (CONFIG_NFS_FAKE_UID_NUMBER==-1 ||
+	    fattr->uid==CONFIG_NFS_FAKE_UID_NUMBER) fattr->uid = 0;
+	if (CONFIG_NFS_FAKE_UID==-1 ||
+	    fattr->gid==CONFIG_NFS_FAKE_UID_NUMBER) fattr->gid = 0;
+#endif
+
 	status = decode_attr_rdev(xdr, bitmap, &fattr->rdev);
 	if (status < 0)
 		goto xdr_error;
diff -Naur linux-3.4.11/.gitignore linux-HEAD/.gitignore
--- linux-3.4.11/.gitignore	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/.gitignore	2015-11-18 09:04:24.000000000 +0000
@@ -64,6 +64,12 @@
 include/generated
 arch/*/include/generated
 
+#
+# EliTo changes
+#
+cscope.out
+uImage
+sys-root
 # stgit generated dirs
 patches-*
 
diff -Naur linux-3.4.11/include/linux/can/platform/sja1000.h linux-HEAD/include/linux/can/platform/sja1000.h
--- linux-3.4.11/include/linux/can/platform/sja1000.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/linux/can/platform/sja1000.h	2015-11-18 09:04:24.000000000 +0000
@@ -25,11 +25,27 @@
 #define OCR_TX_MASK       0xfc
 #define OCR_TX_SHIFT      2
 
+/**
+ *  @offset_data: relative offset of the memory address where data is written
+ *      in indirect addressing mode.
+ *  @offset_addr: relative offset of the memory address where register address
+ *      is written in indirect addressing mode.
+ *
+ *  When one or both of the offset_data or offset_addr attributes are not
+ *  zero, indirect addressing mode will be used for the SJA1000 chip.  This
+ *  means that a memory access operation will be splitted into two steps: the
+ *  first step writes the register address to [offset_addr] while the second
+ *  ones reads resp. writes the data from/to [offset_data].  The offset_addr
+ *  and offset_data are relative to the base address given in the memory
+ *  resource of the SJA1000 device. */
 struct sja1000_platform_data {
 	u32 osc_freq;	/* CAN bus oscillator frequency in Hz */
 
 	u8 ocr;		/* output control register */
 	u8 cdr;		/* clock divider register */
+
+	unsigned long	offset_data;
+	unsigned long	offset_addr;
 };
 
 #endif	/* !_CAN_PLATFORM_SJA1000_H_ */
diff -Naur linux-3.4.11/include/linux/dm9000.h linux-HEAD/include/linux/dm9000.h
--- linux-3.4.11/include/linux/dm9000.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/linux/dm9000.h	2015-11-18 09:04:24.000000000 +0000
@@ -34,6 +34,11 @@
 	void	(*inblk)(void __iomem *reg, void *data, int len);
 	void	(*outblk)(void __iomem *reg, void *data, int len);
 	void	(*dumpblk)(void __iomem *reg, int len);
+
+	/* An optional method which fills in the MAC address when it could not
+	 * be read from EEPROM. The used method should/can be tagged as
+	 * __devinit. */
+	void 	(*fill_ether_addr)(unsigned char mac[6]);
 };
 
 #endif /* __DM9000_PLATFORM_DATA */
diff -Naur linux-3.4.11/include/linux/fec.h linux-HEAD/include/linux/fec.h
--- linux-3.4.11/include/linux/fec.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/linux/fec.h	2015-11-18 09:04:24.000000000 +0000
@@ -19,6 +19,9 @@
 struct fec_platform_data {
 	phy_interface_t phy;
 	unsigned char mac[ETH_ALEN];
+
+	unsigned int phy_addr;
+	int phy_irq;
 };
 
 #endif
diff -Naur linux-3.4.11/include/linux/fsl_devices.h linux-HEAD/include/linux/fsl_devices.h
--- linux-3.4.11/include/linux/fsl_devices.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/linux/fsl_devices.h	2015-11-18 09:04:24.000000000 +0000
@@ -72,6 +72,9 @@
 	void		(*exit)(struct platform_device *);
 	void __iomem	*regs;		/* ioremap'd register base */
 	struct clk	*clk;
+#ifdef CONFIG_ARCH_MXS
+	void		*priv;
+#endif
 	unsigned	power_budget;	/* hcd->power_budget */
 	unsigned	big_endian_mmio:1;
 	unsigned	big_endian_desc:1;
diff -Naur linux-3.4.11/include/linux/gpio-misc.h linux-HEAD/include/linux/gpio-misc.h
--- linux-3.4.11/include/linux/gpio-misc.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/include/linux/gpio-misc.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,73 @@
+// $Id$    --*- c -*--
+
+// Copyright (C) 2006 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; version 2 of the License.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+
+#ifndef _H_SIGMA_GPIO_H
+#define _H_SIGMA_GPIO_H
+
+#include <linux/time.h>
+
+#ifdef CONFIG_GPIO_PXA_IN
+struct gpio_event
+{
+	struct timespec		time_ev;
+	struct timespec		time_rep;
+	unsigned int		seqnr;
+	unsigned int		id;
+	unsigned int		level;
+};
+#endif
+
+#ifdef __KERNEL__
+
+#define GPIO_NAME_SIZE		16
+
+#ifdef CONFIG_GPIO_PXA_IN
+struct gpio_in_data
+{
+	char		name[GPIO_NAME_SIZE];
+	unsigned int	num;
+	unsigned int	edge;
+	unsigned int	debounce;
+	int		negated;
+};
+#endif
+
+struct gpio_out_data
+{
+	char		name[GPIO_NAME_SIZE];
+	unsigned int	num;
+	int		negated;
+	int		level;
+};
+
+struct gpio_platform_data
+{
+	struct module		*module;
+
+#ifdef CONFIG_GPIO_PXA_IN
+	int			num_in;
+	struct gpio_in_data	*gpios_in;
+#endif
+
+	int			num_out;
+	struct gpio_out_data	*gpios_out;
+};
+
+#endif
+
+#endif	//  _H_SIGMA_GPIO_H
diff -Naur linux-3.4.11/include/linux/lcd-max749.h linux-HEAD/include/linux/lcd-max749.h
--- linux-3.4.11/include/linux/lcd-max749.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/include/linux/lcd-max749.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,32 @@
+// $Id$    --*- c -*--
+
+// Copyright (C) 2007 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; version 2 of the License.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+
+#ifndef H_LINUX_LCD_MAX749_H
+#define H_LINUX_LCD_MAX749_H
+
+#include <linux/lcd.h>
+
+struct max749_lcd_machinfo {
+	void			(*set_adj)(int);
+	void			(*set_ctrl)(int);
+};
+
+extern struct lcd_device *	max749_get_device(void);
+
+
+#endif	//  H_LINUX_LCD_MAX749_H
diff -Naur linux-3.4.11/include/linux/max730x.h linux-HEAD/include/linux/max730x.h
--- linux-3.4.11/include/linux/max730x.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/include/linux/max730x.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,45 @@
+/*	--*- c -*--
+ * Copyright (C) 2008 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_LINUX_INCLUDE_MAX730X_H
+#define H_LINUX_INCLUDE_MAX730X_H
+
+#include <linux/types.h>
+#include <linux/device.h>
+
+struct max730x_device {
+	int		(*reset)(struct max730x_device *dev);
+	int		(*update)(struct max730x_device *dev);
+	void		(*free)(struct max730x_device *dev);
+
+	void *		(*get_drvdata)(struct max730x_device *dev);
+};
+
+struct max730x_platform_data {
+	uint32_t	dir;		/* bitmask: 0 ... input, 1 ... output */
+	uint32_t	pullup;		/* bitmask: 0 ... no pull-up, 1 ... pull-up */
+	uint32_t	val;		/* bitmask: 0 ... active-hi,  1 ... active-lo */
+};
+
+struct max730x_op
+{
+	int		(*set)(struct max730x_op *op, uint8_t address, uint8_t value);
+	int		(*get)(struct max730x_op *op, uint8_t address, uint8_t *value);
+};
+
+struct max730x_device	*max730x_create(struct device *, struct max730x_op *op, int irq);
+
+#endif	/* H_LINUX_INCLUDE_MAX730X_H */
diff -Naur linux-3.4.11/include/linux/platform_data/lvl-gpio.h linux-HEAD/include/linux/platform_data/lvl-gpio.h
--- linux-3.4.11/include/linux/platform_data/lvl-gpio.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/include/linux/platform_data/lvl-gpio.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,32 @@
+/*	--*- c -*--
+ * Copyright (C) 2012 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_LINUX_KERNEL_INCLUDE_LINUX_PLATFORM_DATA_LVL_GPIO_H
+#define H_LINUX_KERNEL_INCLUDE_LINUX_PLATFORM_DATA_LVL_GPIO_H
+
+struct lvl_gpio_gpio {
+	unsigned int			gpio;
+	char const			*name;
+	unsigned int			irq_mask;
+	unsigned int			is_managed:1;
+};
+
+struct lvl_gpio_data {
+	size_t				num_gpio;
+	struct lvl_gpio_gpio const	*gpios;
+};
+
+#endif	/* H_LINUX_KERNEL_INCLUDE_LINUX_PLATFORM_DATA_LVL_GPIO_H */
diff -Naur linux-3.4.11/include/linux/platform_data/pxa_sdhci.h linux-HEAD/include/linux/platform_data/pxa_sdhci.h
--- linux-3.4.11/include/linux/platform_data/pxa_sdhci.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/linux/platform_data/pxa_sdhci.h	2015-11-18 09:04:24.000000000 +0000
@@ -51,10 +51,17 @@
 	unsigned int	host_caps;
 	unsigned int	quirks;
 	unsigned int	pm_caps;
+
+	int		(*init)(struct device *dev, irq_handler_t fn, void *fn_data);
+	void		(*remove)(struct device *dev, void *fn_data);
+	void		(*clk_74)(void);
 };
 
 struct sdhci_pxa {
 	u8	clk_enable;
 	u8	power_mode;
+	unsigned int	delay_in_ms;
+	unsigned int	delay_in_us;
+	unsigned int	delay_in_ns;
 };
 #endif /* _PXA_SDHCI_H_ */
diff -Naur linux-3.4.11/include/linux/platform_device.h linux-HEAD/include/linux/platform_device.h
--- linux-3.4.11/include/linux/platform_device.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/linux/platform_device.h	2015-11-18 09:04:24.000000000 +0000
@@ -47,7 +47,7 @@
 extern int platform_get_irq(struct platform_device *, unsigned int);
 extern struct resource *platform_get_resource_byname(struct platform_device *, unsigned int, const char *);
 extern int platform_get_irq_byname(struct platform_device *, const char *);
-extern int platform_add_devices(struct platform_device **, int);
+extern int platform_add_devices(struct platform_device * const *, int);
 
 struct platform_device_info {
 		struct device *parent;
diff -Naur linux-3.4.11/include/linux/regulator/lp3972.h linux-HEAD/include/linux/regulator/lp3972.h
--- linux-3.4.11/include/linux/regulator/lp3972.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/linux/regulator/lp3972.h	2015-11-18 09:04:24.000000000 +0000
@@ -43,6 +43,7 @@
 struct lp3972_platform_data {
 	int num_regulators;
 	struct lp3972_regulator_subdev *regulators;
+	int gpio_base;
 };
 
 #endif
diff -Naur linux-3.4.11/include/linux/serial_rs485.h linux-HEAD/include/linux/serial_rs485.h
--- linux-3.4.11/include/linux/serial_rs485.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/include/linux/serial_rs485.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,41 @@
+/*	--*- c -*--
+ * Copyright (C) 2009 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_LINUX_SERIAL_RS485_H
+#define H_LINUX_SERIAL_RS485_H
+
+enum {
+	/* set when TXE is low active */
+	RS485_TXE_LOW_ACTIVE = (1 << 0),
+
+	/* set when nRXE is low active */
+	RS485_RXEN_LOW_ACTIVE = (1 << 1),
+};
+
+struct rs485_platform_data {
+	unsigned int	uart_line;
+	unsigned int	flags;
+
+	int		gpio_txe;
+	int		gpio_rxen;
+
+	unsigned int	timer;
+};
+
+struct uart_port;
+void	rs485_enable_tx(struct uart_port *, int enable);
+
+#endif	/* H_LINUX_SERIAL_RS485_H */
diff -Naur linux-3.4.11/include/linux/smc91x.h linux-HEAD/include/linux/smc91x.h
--- linux-3.4.11/include/linux/smc91x.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/linux/smc91x.h	2015-11-18 09:04:24.000000000 +0000
@@ -29,6 +29,7 @@
 	unsigned long flags;
 	unsigned char leda;
 	unsigned char ledb;
+	void	(*fill_ether_addr)(unsigned char addr[]);
 };
 
 #endif /* __SMC91X_H__ */
diff -Naur linux-3.4.11/include/linux/spi/pxa2xx_spi.h linux-HEAD/include/linux/spi/pxa2xx_spi.h
--- linux-3.4.11/include/linux/spi/pxa2xx_spi.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/linux/spi/pxa2xx_spi.h	2015-11-18 09:04:24.000000000 +0000
@@ -43,7 +43,7 @@
 	void (*cs_control)(u32 command);
 };
 
-#ifdef CONFIG_ARCH_PXA
+#if defined(CONFIG_ARCH_PXA) || defined(CONFIG_ARCH_MMP)
 
 #include <linux/clk.h>
 #include <mach/dma.h>
diff -Naur linux-3.4.11/include/linux/ucb1400.h linux-HEAD/include/linux/ucb1400.h
--- linux-3.4.11/include/linux/ucb1400.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/linux/ucb1400.h	2015-11-18 09:04:24.000000000 +0000
@@ -75,8 +75,13 @@
 #define UCB_ADC_DATA		0x68
 #define UCB_ADC_DAT_VALID	(1 << 15)
 
-#define UCB_FCSR		0x6c
-#define UCB_FCSR_AVE		(1 << 12)
+#define UCB_FCSR1		0x6a
+
+#define UCB_FCSR2		0x6c
+#define UCB_FCSR2_AVE		(1 << 12)
+
+#define UCB_TEST_CTRL		0x6e
+#define UCB_EXTRA_INT		0x70
 
 #define UCB_ADC_DAT_MASK	0x3ff
 
diff -Naur linux-3.4.11/include/linux/usb/isp1760.h linux-HEAD/include/linux/usb/isp1760.h
--- linux-3.4.11/include/linux/usb/isp1760.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/linux/usb/isp1760.h	2015-11-18 09:04:24.000000000 +0000
@@ -8,7 +8,6 @@
 
 struct isp1760_platform_data {
 	unsigned is_isp1761:1;			/* Chip is ISP1761 */
-	unsigned bus_width_16:1;		/* 16/32-bit data bus width */
 	unsigned port1_otg:1;			/* Port 1 supports OTG */
 	unsigned analog_oc:1;			/* Analog overcurrent */
 	unsigned dack_polarity_high:1;		/* DACK active high */
diff -Naur linux-3.4.11/include/linux/watchdog.h linux-HEAD/include/linux/watchdog.h
--- linux-3.4.11/include/linux/watchdog.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/linux/watchdog.h	2015-11-18 09:04:24.000000000 +0000
@@ -54,6 +54,8 @@
 #ifdef __KERNEL__
 
 #include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
 
 struct watchdog_ops;
 struct watchdog_device;
@@ -105,6 +107,13 @@
  * via the watchdog_set_drvdata and watchdog_get_drvdata helpers.
  */
 struct watchdog_device {
+	struct cdev cdev;		/* Character device */
+	struct device *dev;		/* Device for our node */
+	struct device *busdev;		/* Parent bus device (set by caller
+							if used) */
+	dev_t devt;			/* Our device devt */
+	int id;				/* Watchdog id */
+
 	const struct watchdog_info *info;
 	const struct watchdog_ops *ops;
 	unsigned int bootstatus;
diff -Naur linux-3.4.11/include/video/pxa168fb.h linux-HEAD/include/video/pxa168fb.h
--- linux-3.4.11/include/video/pxa168fb.h	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/include/video/pxa168fb.h	2015-11-18 09:04:24.000000000 +0000
@@ -94,6 +94,12 @@
 	unsigned	pix_fmt;
 
 	/*
+	 * physical dimensions, in mm
+	 */
+	unsigned int	width;
+	unsigned int	height;
+
+	/*
 	 * I/O pin allocation.
 	 */
 	unsigned	io_pin_allocation_mode:4;
diff -Naur linux-3.4.11/init/Kconfig linux-HEAD/init/Kconfig
--- linux-3.4.11/init/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/init/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -60,6 +60,13 @@
 	  you say Y here, you will be offered the choice of using features or
 	  drivers that are currently considered to be in the alpha-test phase.
 
+config DANGEROUS
+	bool "Enable dangerous features"
+	depends on EXPERIMENTAL && DEBUG_KERNEL
+	help
+	  Enable features which are dangerous for normal operations but
+          are useful for debugging and development.
+
 config BROKEN
 	bool
 
diff -Naur linux-3.4.11/kernel/irq/autoprobe.c linux-HEAD/kernel/irq/autoprobe.c
--- linux-3.4.11/kernel/irq/autoprobe.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/kernel/irq/autoprobe.c	2015-11-18 09:04:24.000000000 +0000
@@ -138,6 +138,10 @@
 }
 EXPORT_SYMBOL(probe_irq_mask);
 
+#ifndef NO_IRQ
+#  define NO_IRQ	0
+#endif
+
 /**
  *	probe_irq_off	- end an interrupt autodetect
  *	@val: mask of potential interrupts (unused)
@@ -157,7 +161,7 @@
  */
 int probe_irq_off(unsigned long val)
 {
-	int i, irq_found = 0, nr_of_irqs = 0;
+	int i, irq_found = NO_IRQ, nr_of_irqs = 0;
 	struct irq_desc *desc;
 
 	for_each_irq_desc(i, desc) {
@@ -167,6 +171,9 @@
 			if (!(desc->istate & IRQS_WAITING)) {
 				if (!nr_of_irqs)
 					irq_found = i;
+				else
+					printk(KERN_WARNING "%s: extra irq %d (beside %d) detected\n",
+					       __func__, i, irq_found);
 				nr_of_irqs++;
 			}
 			desc->istate &= ~IRQS_AUTODETECT;
diff -Naur linux-3.4.11/kernel/power/Kconfig linux-HEAD/kernel/power/Kconfig
--- linux-3.4.11/kernel/power/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/kernel/power/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -211,6 +211,11 @@
 	  anything, try disabling/enabling this option (or disabling/enabling
 	  APM in your BIOS).
 
+config PM_PXA
+	bool
+	depends on PM && CONFIG_PXA27x
+	default y
+
 config ARCH_HAS_OPP
 	bool
 
diff -Naur linux-3.4.11/kernel/power/Makefile linux-HEAD/kernel/power/Makefile
--- linux-3.4.11/kernel/power/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/kernel/power/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -11,3 +11,4 @@
 				   block_io.o
 
 obj-$(CONFIG_MAGIC_SYSRQ)	+= poweroff.o
+obj-$(CONFIG_PM_PXA)		+= pxa.o
diff -Naur linux-3.4.11/kernel/power/pxa.c linux-HEAD/kernel/power/pxa.c
--- linux-3.4.11/kernel/power/pxa.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/kernel/power/pxa.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,667 @@
+/*	--*- c -*--
+ * Copyright (C) 2006,2010 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/suspend.h>
+#include <linux/syscalls.h>
+#include <linux/fs.h>
+#include <linux/pm.h>
+#include <linux/string.h>
+#include <mach/hardware.h>
+#include <mach/pxa2xx-regs.h>
+#include <mach/mfp-pxa2xx.h>
+#include <mach/gpio.h>
+
+#include "../arch/arm/mach-pxa/generic.h"
+#include "power.h"
+#include "pxa.h"
+
+static inline int is_input(int gpio)
+{
+	return (GPDR(gpio) & GPIO_bit(gpio)) == 0;
+}
+
+static ssize_t pwer_show_MUX2(char *buf, uint32_t v)
+{
+	int		gpio;
+
+	switch (v & 7) {
+	case 0:		return sprintf(buf, "disabled");
+	case 1:		gpio = 38; break;
+	case 2:		gpio = 53; break;
+	case 3:		gpio = 40; break;
+	case 4:		gpio = 36; break;
+	default:	return sprintf(buf, "err");
+	}
+
+	return sprintf(buf, "%sgpio<%i>", is_input(gpio) ? "*" : "", gpio);
+}
+
+static ssize_t pwer_show_MUX3(char *buf, uint32_t v)
+{
+	int		gpio;
+
+	switch (v & 3) {
+	case 0:		return sprintf(buf, "disabled");
+	case 1:		gpio = 31;  break;
+	case 2:		gpio = 113; break;
+	default:	return sprintf(buf, "err");
+	}
+
+	return sprintf(buf, "%sgpio<%i>", is_input(gpio) ? "*" : "", gpio);
+}
+
+static ssize_t pwer_parse_raw(char const *buf, size_t len, unsigned int *val)
+{
+	char		tmp[64];
+	int		rc;
+
+	if (len >= sizeof tmp) {
+		printk(KERN_WARNING "number too long (%u chars)", len);
+		return -EINVAL;
+	}
+
+	snprintf(tmp, len+1, "%s", buf);
+
+	if (strcmp(tmp, "disabled")==0 ||
+	    strcmp(tmp, "0")==0) {
+		*val = 0;
+		return len;
+	}
+
+	rc = sscanf(tmp, "gpio<%u>", val);
+	if (rc==0)
+		rc = sscanf(tmp, "%u", val);
+
+	if (rc!=1) {
+		printk(KERN_WARNING "invalid syntax for MUX3");
+		return -EINVAL;
+	}
+
+	return len;
+}
+
+
+static ssize_t pwer_parse_MUX2(char const *buf, size_t len, uint32_t *val)
+{
+	unsigned int		tmp_val;
+	ssize_t			rc = pwer_parse_raw(buf, len, &tmp_val);
+
+	if (rc<0)
+		return rc;
+
+	switch (tmp_val) {
+	case 0:		*val = 0; break;
+	case 38:	*val = 1; break;
+	case 53:	*val = 2; break;
+	case 40:	*val = 3; break;
+	case 36:	*val = 4; break;
+	default:
+		printk(KERN_WARNING "invalid GPIO %u for MUX2", tmp_val);
+		return -EINVAL;
+	}
+
+	return rc;
+}
+
+static ssize_t pwer_parse_MUX3(char const *buf, size_t len, uint32_t *val)
+{
+	unsigned int		tmp_val;
+	ssize_t			rc = pwer_parse_raw(buf, len, &tmp_val);
+
+	if (rc<0)
+		return rc;
+
+	switch (tmp_val) {
+	case 0:		*val = 0; break;
+	case 31:	*val = 1; break;
+	case 113:	*val = 2; break;
+	default:
+		printk(KERN_WARNING "invalid GPIO %u for MUX3", tmp_val);
+		return -EINVAL;
+	}
+
+	return rc;
+}
+
+static ssize_t pwer_show_edge(char *buf,
+			      int is_rising, int is_falling)
+{
+	if (is_rising && is_falling)
+		return sprintf(buf, "both");
+	else if (is_rising)
+		return sprintf(buf, "rising");
+	else if (is_falling)
+		return sprintf(buf, "falling");
+	else
+		return sprintf(buf, "disabled");
+}
+
+static ssize_t pwer_parse_edge(char const *buf, size_t len,
+			       int *is_rising, int *is_falling)
+{
+	if (strncmp(buf, "both", len)==0) {
+		*is_falling = 1;
+		*is_rising  = 1;
+	}
+	else if (strncmp(buf, "falling", len)==0) {
+		*is_falling = 1;
+		*is_rising  = 0;
+	}
+	else if (strncmp(buf, "rising", len)==0) {
+		*is_falling = 0;
+		*is_rising  = 1;
+	}
+	else if (strncmp(buf, "disabled", len)==0 ||
+		 strncmp(buf, "0", len)==0) {
+		*is_falling = 0;
+		*is_rising  = 0;
+	}
+	else {
+		printk(KERN_WARNING "invalid value '%s' for an edge\n",
+		       buf);
+		return -EINVAL;
+	}
+
+	return len;
+}
+
+static ssize_t pwer_show_simple(char *buf, int is_enabled)
+{
+	if (is_enabled)
+		return sprintf(buf, "enabled");
+	else
+		return sprintf(buf, "disabled");
+}
+
+static ssize_t pwer_parse_simple(char const *buf, size_t len,
+				 int *is_enabled)
+{
+	if (strncmp(buf, "disabled", len)==0 ||
+	    strncmp(buf, "0", len)==0)
+		*is_enabled = 0;
+	else if (strncmp(buf, "enabled", len)==0 ||
+		 strncmp(buf, "1", len)==0)
+		*is_enabled = 1;
+	else {
+		printk(KERN_WARNING "invalid value '%s'",
+		       buf);
+		return -EINVAL;
+	}
+
+	return len;
+}
+
+static struct pwer_data const		pwer_data[] = {
+	{ .type = tpBATT, .event = "BATTF" },
+	PWER_SIMPLE(RTC,    31),
+	PWER_SIMPLE(PI,	    30),
+	PWER_SIMPLE(USBH2,  28),
+	PWER_SIMPLE(USBH1,  27),
+	PWER_SIMPLE(USBC,   26),
+	PWER_SIMPLE(BB,	    25),
+	PWER_SIMPLE(USIM,   23),
+	PWER_MULTIPLE(MUX3, 19, 2),
+	PWER_MULTIPLE(MUX2, 16, 3),
+	PWER_PKWR(102,	    19),
+	PWER_PKWR(101,	    18),
+	PWER_PKWR(100,	    17),
+	PWER_PKWR( 99,	    16),
+	PWER_PKWR( 98,	    15),
+	PWER_PKWR( 97,	    14),
+	PWER_PKWR( 96,	    13),
+	PWER_PKWR( 95,	    12),
+	PWER_PKWR( 94,	    11),
+	PWER_PKWR( 93,	    10),
+	PWER_PKWR( 91,	     9),
+	PWER_PKWR( 90,	     8),
+	PWER_PKWR( 39,	     7),
+	PWER_PKWR( 38,	     6),
+	PWER_PKWR( 37,	     5),
+	PWER_PKWR( 36,	     4),
+	PWER_EDGE( 35,	    24),
+	PWER_PKWR( 34,	     3),
+	PWER_PKWR( 17,	     2),
+	PWER_PKWR( 16,	     1),
+	PWER_EDGE( 15,	    15),
+	PWER_EDGE( 14,	    14),
+	PWER_PKWR( 13,	     0),
+	PWER_EDGE( 13,	    13),
+	PWER_EDGE( 12,	    12),
+	PWER_EDGE( 11,	    11),
+	PWER_EDGE( 10,	    10),
+	PWER_EDGE(  9,	     9),
+	PWER_EDGE(  4,	     4),
+	PWER_EDGE(  3,	     3),
+	PWER_EDGE(  1,	     1),
+	PWER_EDGE(  0,	     0),
+};
+
+static char *  show_wakeup_status(char *buf, int is_detected)
+{
+	if (is_detected)
+		*buf++ = 'X';
+	else
+		*buf++ = '.';
+
+	*buf++ = ' ';
+	*buf++ = ' ';
+
+	return buf;
+}
+
+static ssize_t wakeup_show(struct kobject *kobj, struct kobj_attribute *attr,
+			   char *buf)
+{
+	size_t		i;
+	uint32_t	mask;
+	unsigned int	shift;
+	char		*ptr = buf;
+
+	uint32_t const	pwer = PWER;
+	uint32_t const	prer = PRER & pwer;
+	uint32_t const	pfer = PFER & pwer;
+	uint32_t const	pkwr = PKWR;
+	uint32_t const	pedr = PEDR;
+	uint32_t const	pksr = PKSR;
+	uint32_t const	pslr = PSLR;
+
+	for (i=0; i<ARRAY_SIZE(pwer_data); ++i) {
+		ptr += sprintf(ptr, "%-5s  ", pwer_data[i].event);
+		switch (pwer_data[i].type) {
+		case tpNONE:
+			BUG();
+
+		case tpBATT:
+			ptr   += sprintf(ptr, "BATT  ?	");
+			if (pslr & PSLR_IVF)
+				ptr += sprintf(ptr, "disabled");
+			else
+				ptr += sprintf(ptr, "enabled");
+			break;
+
+		case tpSIMPLE:
+			mask   = (1<<pwer_data[i].info.simple.bit);
+			ptr   += sprintf(ptr, "PWER  ");
+			ptr    = show_wakeup_status(ptr, pedr & mask);
+			ptr   += pwer_show_simple(ptr, pwer & mask);
+			break;
+
+		case tpEDGE:
+			mask   = (1<<pwer_data[i].info.edge.bit);
+			ptr   += sprintf(ptr, "EDGE  ");
+			ptr    = show_wakeup_status(ptr, pedr & mask);
+			if (!is_input(mfp_to_gpio(pwer_data[i].info.edge.mfp)))
+				*ptr++ = '*';
+			ptr   += pwer_show_edge(ptr, prer & mask, pfer & mask);
+			break;
+
+		case tpMULTIPLE:
+			shift  = pwer_data[i].info.multiple.bit;
+			mask   = (1<<(pwer_data[i].info.multiple.width))-1;
+			mask <<= shift;
+
+			ptr   += sprintf(ptr, "PWER  ");
+			ptr    = show_wakeup_status(ptr, pedr & mask);
+			ptr   += pwer_data[i].info.multiple.show(ptr,
+								 (pwer & mask) >> shift);
+			break;
+
+		case tpPKWR:
+			mask   = (1<<pwer_data[i].info.pkwr.bit);
+			ptr   += sprintf(ptr, "KBD   ");
+			ptr    = show_wakeup_status(ptr, pksr & mask);
+			if (!is_input(pwer_data[i].info.pkwr.gpio))
+				*ptr++ = '*';
+			ptr   += pwer_show_simple(ptr, pkwr & mask);
+			break;
+		}
+
+		*ptr++ = '\n';
+	}
+
+	return ptr-buf;
+}
+
+static int wakeup_store_value(struct pwer_data const *info,
+			      char const *value)
+{
+	int			is_enabled, is_falling, is_rising;
+	size_t			len = strlen(value);
+	int			rc, shift;
+	unsigned long		flags;
+	uint32_t		val, mask;
+
+	switch (info->type) {
+	case tpBATT:
+		rc = pwer_parse_simple(value, len, &is_enabled);
+		if (rc<0) {
+			printk("pxa-wakeup: invalid value '%s'\n", value);
+			return rc;
+		}
+
+		local_irq_save(flags);
+		if (is_enabled)
+			PSLR &= ~PSLR_IVF;
+		else
+			PSLR |=	 PSLR_IVF;
+		local_irq_restore(flags);
+
+		break;
+
+	case tpPKWR:
+		rc = pwer_parse_simple(value, len, &is_enabled);
+		if (rc<0) {
+			printk("pxa-wakeup: invalid value '%s'\n", value);
+			return rc;
+		}
+		mask = (1<<info->info.pkwr.bit);
+
+		local_irq_save(flags);
+		if (is_enabled)
+			PKWR |= mask;
+		else
+			PKWR &= ~mask;
+		local_irq_restore(flags);
+
+		break;
+
+	case tpSIMPLE:
+		rc = pwer_parse_simple(value, len, &is_enabled);
+		if (rc<0) {
+			printk("pxa-wakeup: invalid value '%s'\n", value);
+			return rc;
+		}
+
+		mask = (1<<info->info.simple.bit);
+
+		local_irq_save(flags);
+		if (is_enabled)
+			PWER |= mask;
+		else
+			PWER &= ~mask;
+		local_irq_restore(flags);
+
+		break;
+
+	case tpEDGE:
+		rc = pwer_parse_edge(value, len, &is_rising, &is_falling);
+		if (rc<0) {
+			printk("pxa-wakeup: invalid value '%s' for an edge\n", value);
+			return rc;
+		}
+
+		pxa2xx_mfp_cfg_wake(info->info.edge.mfp,
+				    ((is_rising  ? WAKEUP_ON_EDGE_RISE : 0) |
+				     (is_falling ? WAKEUP_ON_EDGE_FALL : 0)));
+		rc = gpio_set_wake(mfp_to_gpio(info->info.edge.mfp),
+				   is_rising || is_falling);
+
+		if (rc < 0) {
+			printk("pxa-wakeup: failed to setup edge gpio: %d\n", rc);
+			return rc;
+		}
+
+		break;
+
+
+		break;
+
+	case tpMULTIPLE:
+		rc = info->info.multiple.parse(value, len, &val);
+		if (rc<0)
+			return rc;
+
+		shift  = info->info.multiple.bit;
+		mask   = (1<<(info->info.multiple.width))-1;
+		mask <<= shift;
+		val  <<= shift;
+
+		local_irq_save(flags);
+		PWER   = (PWER & ~mask) | val;
+		local_irq_restore(flags);
+
+		break;
+	default:
+		BUG();
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t wakeup_store(struct kobject *kobj, struct kobj_attribute *attr,
+			    const char * buf, size_t n)
+{
+	pwer_type			type = tpNONE;
+	int				rc;
+	char				line[64];
+	char *				ptr = line;
+	char const			*key;
+	int				gpio;
+	size_t				i;
+	struct pwer_data const	*	data_result = 0;
+	char const			*eol;
+	char *				end_ptr;
+
+	if (*buf=='\n')
+		return 1;
+
+	eol = strchr(buf, '\n');
+	if (eol!=0)
+		n   = eol-buf;
+	else
+		eol = buf + n;
+
+	if (n>=sizeof line) {
+		printk(KERN_WARNING "line too large (%u)\n", n);
+		return -EINVAL;
+	}
+
+	memcpy(line, buf, n);
+	line[n] = '\0';
+
+	pr_debug("%s(): parsing %u chars: '%s'\n", __FUNCTION__, n+1, line);
+
+	if (strnicmp(ptr, "kbd-", 4)==0) {
+		type = tpPKWR;
+		ptr += 4;
+	}
+	else if (strnicmp(ptr, "edge-", 5)==0) {
+		type = tpEDGE;
+		ptr += 5;
+	}
+
+	if (*ptr=='[')
+		++ptr;
+
+	gpio = simple_strtol(ptr, &end_ptr, 10);
+	if (end_ptr==ptr)
+		gpio = -1;
+
+	if (gpio<0)
+		key = ptr;
+	else
+		key = 0;
+
+	ptr = end_ptr;
+	while (*ptr!=' ' && *ptr!='\t' && *ptr!=0)
+		++ptr;
+
+	if (*ptr!=0)
+		*ptr++ = 0;
+
+	while (!(*ptr!=' ' && *ptr!='\t') && *ptr!=0)
+		++ptr;
+
+	pr_debug("%s(): searching for type=%u, gpio=%i, key='%s', value='%s'\n",
+		 __FUNCTION__, type, gpio, key, ptr);
+
+
+	for (i=0; i<ARRAY_SIZE(pwer_data); ++i) {
+		struct pwer_data const	* const	data  = pwer_data+i;
+		int				found = 0;
+
+		if (type!=tpNONE && type!=data->type)
+			continue;
+
+		if (key!=0 && strnicmp(key, data->event, (size_t)-1)==0)
+			found = 1;
+		else if (gpio>=0) {
+			switch (data->type) {
+			case tpEDGE:  found = (mfp_to_gpio(data->info.edge.mfp)
+					       == gpio); break;
+			case tpPKWR:  found = data->info.pkwr.gpio == gpio; break;
+			default:      break;
+			}
+		}
+
+		if (found && data_result!=0) {
+			printk(KERN_WARNING "%s(): ambigious query\n", __FUNCTION__);
+			return -EINVAL;
+		}
+
+		if (found)
+			data_result = data;
+	}
+
+	if (!data_result) {
+		printk(KERN_WARNING "%s(): can not find such a wakeup configuration\n", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	rc = wakeup_store_value(data_result, ptr);
+	if (rc<0)
+		return rc;
+
+	return n;
+}
+
+static ssize_t info_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	get_clk_frequency_khz(1);
+
+	return sprintf(buf,
+		       "PMCR=%08x\nPSSR=%08x\nPSPR=%08x\nPWER=%08x\nPRER=%08x\nPFER=%08x\nPEDR=%08x\nPCFR=%08x\n\n"
+		       "PGSR=%08x %08x %08x %08x\n"
+		       "PCSR=%08x\nPSLR=%08x\nPSTR=%08x\nPVCR=%08x\n\n"
+		       "PUCR=%08x\nPKWR=%08x\nPKSR=%08x\n\n"
+		       "MSC0=%08x\nMSC1=%08x\nMSC2=%08x\n\n"
+		       "CCCR=%08x\n"
+		       ,
+		       PMCR, PSSR, PSPR, PWER, PRER, PFER, PEDR, PCFR,
+		       PGSR0, PGSR1, PGSR1, PGSR2,
+		       RCSR, PSLR, PSTR, PVCR,
+		       PUCR, PKWR, PKSR,
+		       MSC0, MSC1, MSC2,
+		       CCCR
+		);
+}
+
+static ssize_t reset_out_store(struct kobject *kobj, struct kobj_attribute *attr,
+			       const char * buf, size_t n)
+{
+	int		is_enabled;
+	unsigned long	flags;
+	int		rc;
+	char const	*eol;
+
+	if (*buf=='\n')
+		return 1;
+
+	eol = strchr(buf, '\n');
+	if (eol!=0)
+		n   = eol-buf;
+	else
+		eol = buf + n;
+
+	rc = pwer_parse_simple(buf, n, &is_enabled);
+	if (rc<0)
+		return rc;
+
+	local_irq_save(flags);
+	if (is_enabled)
+		PSLR &= ~PSLR_SL_ROD;
+	else
+		PSLR |=	 PSLR_SL_ROD;
+	local_irq_restore(flags);
+
+	return rc;
+}
+
+static ssize_t rcsr_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	uint32_t		rcsr = RCSR;
+
+	return sprintf(buf,
+		       "GPR: %s\n"
+		       "SMR: %s\n"
+		       "WDR: %s\n"
+		       "HWR: %s\n",
+		       (rcsr & RCSR_GPR ? "yes" : "no"),
+		       (rcsr & RCSR_SMR ? "yes" : "no"),
+		       (rcsr & RCSR_WDR ? "yes" : "no"),
+		       (rcsr & RCSR_HWR ? "yes" : "no"));
+}
+
+static ssize_t reset_out_show(struct kobject *kobj, struct kobj_attribute *attr,
+			      char *buf)
+{
+	if (PSLR & PSLR_SL_ROD)
+		return sprintf(buf, "disabled\n");
+	else
+		return sprintf(buf, "enabled\n");
+}
+
+power_attr(wakeup);
+power_attr(reset_out);
+
+static struct kobj_attribute	info_attr = {
+	.attr = {
+		.name = "info",
+		.mode = 0444
+	},
+	.show = info_show
+};
+
+static struct kobj_attribute	rcsr_attr = {
+	.attr = {
+		.name = "rcsr",
+		.mode = 0444
+	},
+	.show = rcsr_show
+};
+
+static struct attribute * g[] = {
+	&wakeup_attr.attr,
+	&info_attr.attr,
+	&reset_out_attr.attr,
+	&rcsr_attr.attr,
+	0
+};
+
+static struct attribute_group attr_group = {
+	.attrs = g,
+};
+
+
+static int __init pm_pxa_init(void)
+{
+	return sysfs_create_group(power_kobj,&attr_group);
+}
+
+postcore_initcall(pm_pxa_init);
diff -Naur linux-3.4.11/kernel/power/pxa.h linux-HEAD/kernel/power/pxa.h
--- linux-3.4.11/kernel/power/pxa.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/kernel/power/pxa.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,87 @@
+// $Id$    --*- c -*--
+
+// Copyright (C) 2006 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; version 2 of the License.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+//
+
+#ifndef H_SIGMA_LINUX_KERNEL_PM_PXA_H
+#define H_SIGMA_LINUX_KERNEL_PM_PXA_H
+
+typedef enum { tpNONE, tpSIMPLE, tpEDGE, tpMULTIPLE, tpPKWR, tpBATT }	pwer_type;
+
+struct pwer_data {
+	pwer_type				type;
+	char const *				event;
+
+	union {
+		struct {
+			unsigned char	bit;
+		}			simple;
+
+		struct {
+			unsigned char	bit;
+			unsigned long	mfp;
+		}			edge;
+
+		struct {
+			unsigned int	bit;
+			unsigned char	gpio;
+		}			pkwr;
+
+		struct {
+			unsigned char	bit;
+			unsigned char	width;
+
+			ssize_t		(*show)(char *buf, uint32_t val);
+			ssize_t		(*parse)(char const *buf, size_t len, uint32_t *val);
+		}			multiple;
+	}				info;
+};
+
+
+#define PWER_SIMPLE(NAME, BIT)					\
+	{							\
+		.type  = tpSIMPLE,				\
+		.event = #NAME,					\
+		.info  = { .simple = { .bit = (BIT) } }		\
+	}
+
+#define PWER_EDGE(_gpio, BIT)					\
+	{							\
+		.type  = tpEDGE,				\
+		.event = "[" #_gpio "]",			\
+		.info  = { .edge = { .bit = (BIT),		\
+				     .mfp = MFP_PIN_GPIO ## _gpio } }	\
+	}
+
+#define PWER_PKWR(GPIO, BIT)					\
+	{							\
+		.type  = tpPKWR,				\
+		.event = "[" #GPIO "]",				\
+		.info  = { .pkwr = { .bit = (BIT), .gpio = (GPIO) } } \
+	}
+
+#define PWER_MULTIPLE(NAME, BIT, WIDTH)	\
+	{	.type  = tpMULTIPLE,			\
+		.event = #NAME,				\
+		.info  = { .multiple = {		\
+			 .bit   = (BIT),		\
+			 .width = (WIDTH),		\
+			 .show  = pwer_show_##NAME,	\
+			 .parse = pwer_parse_##NAME	\
+			 }}				\
+	}
+
+#endif	//  H_SIGMA_LINUX_KERNEL_PM_PXA_H
diff -Naur linux-3.4.11/.mailmap linux-HEAD/.mailmap
--- linux-3.4.11/.mailmap	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/.mailmap	1970-01-01 00:00:00.000000000 +0000
@@ -1,115 +0,0 @@
-#
-# This list is used by git-shortlog to fix a few botched name translations
-# in the git archive, either because the author's full name was messed up
-# and/or not always written the same way, making contributions from the
-# same person appearing not to be so or badly displayed.
-#
-# repo-abbrev: /pub/scm/linux/kernel/git/
-#
-
-Aaron Durbin <adurbin@google.com>
-Adam Oldham <oldhamca@gmail.com>
-Adam Radford <aradford@gmail.com>
-Adrian Bunk <bunk@stusta.de>
-Alan Cox <alan@lxorguk.ukuu.org.uk>
-Alan Cox <root@hraefn.swansea.linux.org.uk>
-Aleksey Gorelov <aleksey_gorelov@phoenix.com>
-Al Viro <viro@ftp.linux.org.uk>
-Al Viro <viro@zenIV.linux.org.uk>
-Andreas Herrmann <aherrman@de.ibm.com>
-Andrew Morton <akpm@osdl.org>
-Andrew Vasquez <andrew.vasquez@qlogic.com>
-Andy Adamson <andros@citi.umich.edu>
-Archit Taneja <archit@ti.com>
-Arnaud Patard <arnaud.patard@rtp-net.org>
-Arnd Bergmann <arnd@arndb.de>
-Axel Dyks <xl@xlsigned.net>
-Axel Lin <axel.lin@gmail.com>
-Ben Gardner <bgardner@wabtec.com>
-Ben M Cahill <ben.m.cahill@intel.com>
-Björn Steinbrink <B.Steinbrink@gmx.de>
-Brian Avery <b.avery@hp.com>
-Brian King <brking@us.ibm.com>
-Christoph Hellwig <hch@lst.de>
-Corey Minyard <minyard@acm.org>
-Damian Hobson-Garcia <dhobsong@igel.co.jp>
-David Brownell <david-b@pacbell.net>
-David Woodhouse <dwmw2@shinybook.infradead.org>
-Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
-Domen Puncer <domen@coderock.org>
-Douglas Gilbert <dougg@torque.net>
-Ed L. Cashin <ecashin@coraid.com>
-Evgeniy Polyakov <johnpol@2ka.mipt.ru>
-Felipe W Damasio <felipewd@terra.com.br>
-Felix Kuhling <fxkuehl@gmx.de>
-Felix Moeller <felix@derklecks.de>
-Filipe Lautert <filipe@icewall.org>
-Franck Bui-Huu <vagabon.xyz@gmail.com>
-Frank Zago <fzago@systemfabricworks.com>
-Greg Kroah-Hartman <greg@echidna.(none)>
-Greg Kroah-Hartman <gregkh@suse.de>
-Greg Kroah-Hartman <greg@kroah.com>
-Henk Vergonet <Henk.Vergonet@gmail.com>
-Henrik Kretzschmar <henne@nachtwindheim.de>
-Herbert Xu <herbert@gondor.apana.org.au>
-Jacob Shin <Jacob.Shin@amd.com>
-James Bottomley <jejb@mulgrave.(none)>
-James Bottomley <jejb@titanic.il.steeleye.com>
-James E Wilson <wilson@specifix.com>
-James Ketrenos <jketreno@io.(none)>
-Jean Tourrilhes <jt@hpl.hp.com>
-Jeff Garzik <jgarzik@pretzel.yyz.us>
-Jens Axboe <axboe@suse.de>
-Jens Osterkamp <Jens.Osterkamp@de.ibm.com>
-John Stultz <johnstul@us.ibm.com>
-Juha Yrjola <at solidboot.com>
-Juha Yrjola <juha.yrjola@nokia.com>
-Juha Yrjola <juha.yrjola@solidboot.com>
-Kay Sievers <kay.sievers@vrfy.org>
-Kenneth W Chen <kenneth.w.chen@intel.com>
-Koushik <raghavendra.koushik@neterion.com>
-Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
-Leonid I Ananiev <leonid.i.ananiev@intel.com>
-Linas Vepstas <linas@austin.ibm.com>
-Mark Brown <broonie@sirena.org.uk>
-Matthieu CASTET <castet.matthieu@free.fr>
-Mayuresh Janorkar <mayur@ti.com>
-Michael Buesch <m@bues.ch>
-Michel Dänzer <michel@tungstengraphics.com>
-Mitesh shah <mshah@teja.com>
-Morten Welinder <terra@gnome.org>
-Morten Welinder <welinder@anemone.rentec.com>
-Morten Welinder <welinder@darter.rentec.com>
-Morten Welinder <welinder@troll.com>
-Mythri P K <mythripk@ti.com>
-Nguyen Anh Quynh <aquynh@gmail.com>
-Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
-Patrick Mochel <mochel@digitalimplant.org>
-Peter A Jonsson <pj@ludd.ltu.se>
-Peter Oruba <peter@oruba.de>
-Peter Oruba <peter.oruba@amd.com>
-Praveen BP <praveenbp@ti.com>
-Rajesh Shah <rajesh.shah@intel.com>
-Ralf Baechle <ralf@linux-mips.org>
-Ralf Wildenhues <Ralf.Wildenhues@gmx.de>
-Rémi Denis-Courmont <rdenis@simphalempin.com>
-Rudolf Marek <R.Marek@sh.cvut.cz>
-Rui Saraiva <rmps@joel.ist.utl.pt>
-Sachin P Sant <ssant@in.ibm.com>
-Sam Ravnborg <sam@mars.ravnborg.org>
-Sascha Hauer <s.hauer@pengutronix.de>
-S.Çağlar Onur <caglar@pardus.org.tr>
-Simon Kelley <simon@thekelleys.org.uk>
-Stéphane Witzmann <stephane.witzmann@ubpmes.univ-bpclermont.fr>
-Stephen Hemminger <shemminger@osdl.org>
-Sumit Semwal <sumit.semwal@ti.com>
-Tejun Heo <htejun@gmail.com>
-Thomas Graf <tgraf@suug.ch>
-Tony Luck <tony.luck@intel.com>
-Tsuneo Yoshioka <Tsuneo.Yoshioka@f-secure.com>
-Uwe Kleine-König <ukleinek@informatik.uni-freiburg.de>
-Uwe Kleine-König <ukl@pengutronix.de>
-Uwe Kleine-König <Uwe.Kleine-Koenig@digi.com>
-Valdis Kletnieks <Valdis.Kletnieks@vt.edu>
-Takashi YOSHII <takashi.yoshii.zj@renesas.com>
-Yusuke Goda <goda.yusuke@renesas.com>
diff -Naur linux-3.4.11/Makefile linux-HEAD/Makefile
--- linux-3.4.11/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -645,8 +645,12 @@
 warn-assign = \
 $(warning "WARNING: Appending $$K$(1) ($(K$(1))) from $(origin K$(1)) to kernel $$$(1)")
 
+_clean_cppflags := $(filterout -DKERNEL_MTD_SIZE=%,$(KCPPFLAGS))
+
 ifneq ($(KCPPFLAGS),)
+ifneq ($(_clean_cppflags),)
         $(call warn-assign,CPPFLAGS)
+endif
         KBUILD_CPPFLAGS += $(KCPPFLAGS)
 endif
 ifneq ($(KAFLAGS),)
diff -Naur linux-3.4.11/net/ipv4/ipconfig.c linux-HEAD/net/ipv4/ipconfig.c
--- linux-3.4.11/net/ipv4/ipconfig.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/net/ipv4/ipconfig.c	2015-11-18 09:04:24.000000000 +0000
@@ -430,9 +430,6 @@
 	 *	claim locks on system_utsname
 	 */
 
-	if (!ic_host_name_set)
-		sprintf(init_utsname()->nodename, "%pI4", &ic_myaddr);
-
 	if (root_server_addr == NONE)
 		root_server_addr = ic_servaddr;
 
diff -Naur linux-3.4.11/scripts/kconfig/.gitignore linux-HEAD/scripts/kconfig/.gitignore
--- linux-3.4.11/scripts/kconfig/.gitignore	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/scripts/kconfig/.gitignore	2015-11-18 09:04:24.000000000 +0000
@@ -21,3 +21,6 @@
 qconf
 gconf
 kxgettext
+zconf.hash.c
+lkc_defs.h
+qconf.moc
diff -Naur linux-3.4.11/scripts/kconfig/zconf.hash.c linux-HEAD/scripts/kconfig/zconf.hash.c
--- linux-3.4.11/scripts/kconfig/zconf.hash.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/scripts/kconfig/zconf.hash.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,286 @@
+/* ANSI-C code produced by gperf version 3.0.4 */
+/* Command-line: gperf -t --output-file scripts/kconfig/zconf.hash.c_shipped -a -C -E -g -k '1,3,$' -p -t scripts/kconfig/zconf.gperf  */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 10 "scripts/kconfig/zconf.gperf"
+struct kconf_id;
+
+static const struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
+/* maximum key range = 71, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+kconf_id_hash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 25, 25,
+       0,  0,  0,  5,  0,  0, 73, 73,  5,  0,
+      10,  5, 45, 73, 20, 20,  0, 15, 15, 73,
+      20, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[2]];
+      /*FALLTHROUGH*/
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval + asso_values[(unsigned char)str[len - 1]];
+}
+
+struct kconf_id_strings_t
+  {
+    char kconf_id_strings_str2[sizeof("if")];
+    char kconf_id_strings_str3[sizeof("int")];
+    char kconf_id_strings_str5[sizeof("endif")];
+    char kconf_id_strings_str7[sizeof("default")];
+    char kconf_id_strings_str8[sizeof("tristate")];
+    char kconf_id_strings_str9[sizeof("endchoice")];
+    char kconf_id_strings_str12[sizeof("def_tristate")];
+    char kconf_id_strings_str13[sizeof("def_bool")];
+    char kconf_id_strings_str14[sizeof("defconfig_list")];
+    char kconf_id_strings_str17[sizeof("on")];
+    char kconf_id_strings_str18[sizeof("optional")];
+    char kconf_id_strings_str21[sizeof("option")];
+    char kconf_id_strings_str22[sizeof("endmenu")];
+    char kconf_id_strings_str23[sizeof("mainmenu")];
+    char kconf_id_strings_str25[sizeof("menuconfig")];
+    char kconf_id_strings_str27[sizeof("modules")];
+    char kconf_id_strings_str29[sizeof("menu")];
+    char kconf_id_strings_str31[sizeof("select")];
+    char kconf_id_strings_str32[sizeof("comment")];
+    char kconf_id_strings_str33[sizeof("env")];
+    char kconf_id_strings_str35[sizeof("range")];
+    char kconf_id_strings_str36[sizeof("choice")];
+    char kconf_id_strings_str39[sizeof("bool")];
+    char kconf_id_strings_str41[sizeof("source")];
+    char kconf_id_strings_str42[sizeof("visible")];
+    char kconf_id_strings_str43[sizeof("hex")];
+    char kconf_id_strings_str46[sizeof("config")];
+    char kconf_id_strings_str47[sizeof("boolean")];
+    char kconf_id_strings_str51[sizeof("string")];
+    char kconf_id_strings_str54[sizeof("help")];
+    char kconf_id_strings_str56[sizeof("prompt")];
+    char kconf_id_strings_str72[sizeof("depends")];
+  };
+static const struct kconf_id_strings_t kconf_id_strings_contents =
+  {
+    "if",
+    "int",
+    "endif",
+    "default",
+    "tristate",
+    "endchoice",
+    "def_tristate",
+    "def_bool",
+    "defconfig_list",
+    "on",
+    "optional",
+    "option",
+    "endmenu",
+    "mainmenu",
+    "menuconfig",
+    "modules",
+    "menu",
+    "select",
+    "comment",
+    "env",
+    "range",
+    "choice",
+    "bool",
+    "source",
+    "visible",
+    "hex",
+    "config",
+    "boolean",
+    "string",
+    "help",
+    "prompt",
+    "depends"
+  };
+#define kconf_id_strings ((const char *) &kconf_id_strings_contents)
+#ifdef __GNUC__
+__inline
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+const struct kconf_id *
+kconf_id_lookup (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 32,
+      MIN_WORD_LENGTH = 2,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 2,
+      MAX_HASH_VALUE = 72
+    };
+
+  static const struct kconf_id wordlist[] =
+    {
+      {-1}, {-1},
+#line 25 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_IF,		TF_COMMAND|TF_PARAM},
+#line 36 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str3,		T_TYPE,		TF_COMMAND, S_INT},
+      {-1},
+#line 26 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str5,		T_ENDIF,	TF_COMMAND},
+      {-1},
+#line 29 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+#line 31 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+#line 20 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str9,	T_ENDCHOICE,	TF_COMMAND},
+      {-1}, {-1},
+#line 32 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+#line 35 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+#line 45 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+      {-1}, {-1},
+#line 43 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,		T_ON,		TF_PARAM},
+#line 28 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,	T_OPTIONAL,	TF_COMMAND},
+      {-1}, {-1},
+#line 42 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str21,		T_OPTION,	TF_COMMAND},
+#line 17 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,	T_ENDMENU,	TF_COMMAND},
+#line 15 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,	T_MAINMENU,	TF_COMMAND},
+      {-1},
+#line 23 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str25,	T_MENUCONFIG,	TF_COMMAND},
+      {-1},
+#line 44 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
+      {-1},
+#line 16 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
+      {-1},
+#line 39 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str31,		T_SELECT,	TF_COMMAND},
+#line 21 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_COMMENT,	TF_COMMAND},
+#line 46 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str33,		T_OPT_ENV,	TF_OPTION},
+      {-1},
+#line 40 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,		T_RANGE,	TF_COMMAND},
+#line 19 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_CHOICE,	TF_COMMAND},
+      {-1}, {-1},
+#line 33 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str39,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1},
+#line 18 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str41,		T_SOURCE,	TF_COMMAND},
+#line 41 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str42,	T_VISIBLE,	TF_COMMAND},
+#line 37 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str43,		T_TYPE,		TF_COMMAND, S_HEX},
+      {-1}, {-1},
+#line 22 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str46,		T_CONFIG,	TF_COMMAND},
+#line 34 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str47,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1}, {-1}, {-1},
+#line 38 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str51,		T_TYPE,		TF_COMMAND, S_STRING},
+      {-1}, {-1},
+#line 24 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str54,		T_HELP,		TF_COMMAND},
+      {-1},
+#line 30 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str56,		T_PROMPT,	TF_COMMAND},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+#line 27 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str72,	T_DEPENDS,	TF_COMMAND}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = kconf_id_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register int o = wordlist[key].name;
+          if (o >= 0)
+            {
+              register const char *s = o + kconf_id_strings;
+
+              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
+                return &wordlist[key];
+            }
+        }
+    }
+  return 0;
+}
+#line 47 "scripts/kconfig/zconf.gperf"
+
diff -Naur linux-3.4.11/scripts/kconfig/zconf.lex.c linux-HEAD/scripts/kconfig/zconf.lex.c
--- linux-3.4.11/scripts/kconfig/zconf.lex.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/scripts/kconfig/zconf.lex.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,2420 @@
+
+#line 3 "scripts/kconfig/zconf.lex.c_shipped"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yylineno zconflineno
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+#define yywrap zconfwrap
+#define yyalloc zconfalloc
+#define yyrealloc zconfrealloc
+#define yyfree zconffree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE zconfrestart(zconfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when zconftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int zconfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
+
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define zconfwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][17] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   44,  -18,  -18,  -18
+    },
+
+    {
+       11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+
+    },
+
+    {
+       11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+       11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+       49,   49,   49,   49,   49,  -22,   49
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+       11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,   53,  -28,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+       11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+       11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+       11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,   56,   57,   57,  -34,  -34,  -34
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   57,   57,   57,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,   59
+    },
+
+    {
+       11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,   44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+    },
+
+    {
+       11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+       11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+       49,   49,   49,   49,   49,  -49,   49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+       11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    {
+       11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,   60,   57,   57,  -56,  -56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,   57,   57,   57,  -57,  -57,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,  -58,  -58,  -58,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,   57,   57,   57,  -60,  -60,  -60
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[61] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+       31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+       22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+        3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+       26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+#define YY_NO_INPUT 1
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+static void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+static void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = realloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+static void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int zconflex_destroy (void );
+
+int zconfget_debug (void );
+
+void zconfset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE zconfget_extra (void );
+
+void zconfset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *zconfget_in (void );
+
+void zconfset_in  (FILE * in_str  );
+
+FILE *zconfget_out (void );
+
+void zconfset_out  (FILE * out_str  );
+
+int zconfget_leng (void );
+
+char *zconfget_text (void );
+
+int zconfget_lineno (void );
+
+void zconfset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int zconfwrap (void );
+#else
+extern int zconfwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( zconftext, zconfleng, 1, zconfout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(zconfin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	int str = 0;
+	int ts, i;
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! zconfin )
+			zconfin = stdin;
+
+		if ( ! zconfout )
+			zconfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
+
+		zconf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+	current_file->lineno++;
+	return T_EOL;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+	unput(zconftext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+{
+		const struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		BEGIN(PARAM);
+		current_pos.file = current_file;
+		current_pos.lineno = current_file->lineno;
+		if (id && id->flags & TF_COMMAND) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+{
+		BEGIN(INITIAL);
+		current_file->lineno++;
+		return T_EOL;
+	}
+	YY_BREAK
+
+case 9:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+		str = zconftext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{
+		const struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		if (id && id->flags & TF_PARAM) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 23:
+/* rule 23 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+	}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+	}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+{
+		if (str == zconftext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(zconftext, 1);
+	}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+{
+		ts = 0;
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 30:
+/* rule 30 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+{
+		while (zconfleng) {
+			if ((zconftext[zconfleng-1] != ' ') && (zconftext[zconfleng-1] != '\t'))
+				break;
+			zconfleng--;
+		}
+		append_string(zconftext, zconfleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+{
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(zconfin);
+	yyterminate();
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( zconfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * zconftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of zconflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			zconfrestart(zconfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) zconfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					zconfrestart(zconfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( zconfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
+	}
+
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	zconf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		zconffree((void *) b->yy_ch_buf  );
+
+	zconffree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	zconf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+{
+    
+	return zconf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) zconfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = zconf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
+
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
+
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
+
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from zconflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    zconfin = stdin;
+    zconfout = stdout;
+#else
+    zconfin = (FILE *) 0;
+    zconfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * zconflex_init()
+     */
+    return 0;
+}
+
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * zconflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *zconfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name != NULL && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *iter;
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	zconfin = zconf_fopen(file->name);
+	if (!zconfin) {
+		printf("%s:%d: can't open file \"%s\"\n",
+		    zconf_curname(), zconf_lineno(), file->name);
+		exit(1);
+	}
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	for (iter = current_file->parent; iter; iter = iter->parent ) {
+		if (!strcmp(current_file->name,iter->name) ) {
+			printf("%s:%d: recursive inclusion detected. "
+			       "Inclusion path:\n  current file : '%s'\n",
+			       zconf_curname(), zconf_lineno(),
+			       zconf_curname());
+			iter = current_file->parent;
+			while (iter && \
+			       strcmp(iter->name,current_file->name)) {
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno-1);
+				iter = iter->parent;
+			}
+			if (iter)
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno+1);
+			exit(1);
+		}
+	}
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+const char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
diff -Naur linux-3.4.11/scripts/kconfig/zconf.tab.c linux-HEAD/scripts/kconfig/zconf.tab.c
--- linux-3.4.11/scripts/kconfig/zconf.tab.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/scripts/kconfig/zconf.tab.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,2504 @@
+/* A Bison parser, made by GNU Bison 2.4.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
+   2009, 2010 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse         zconfparse
+#define yylex           zconflex
+#define yyerror         zconferror
+#define yylval          zconflval
+#define yychar          zconfchar
+#define yydebug         zconfdebug
+#define yynerrs         zconfnerrs
+
+
+/* Copy the first part of user declarations.  */
+
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "lkc.h"
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconf_error(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[SYMBOL_HASHSIZE];
+
+static struct menu *current_menu, *current_entry;
+
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_MENUCONFIG = 266,
+     T_HELP = 267,
+     T_HELPTEXT = 268,
+     T_IF = 269,
+     T_ENDIF = 270,
+     T_DEPENDS = 271,
+     T_OPTIONAL = 272,
+     T_PROMPT = 273,
+     T_TYPE = 274,
+     T_DEFAULT = 275,
+     T_SELECT = 276,
+     T_RANGE = 277,
+     T_VISIBLE = 278,
+     T_OPTION = 279,
+     T_ON = 280,
+     T_WORD = 281,
+     T_WORD_QUOTE = 282,
+     T_UNEQUAL = 283,
+     T_CLOSE_PAREN = 284,
+     T_OPEN_PAREN = 285,
+     T_EOL = 286,
+     T_OR = 287,
+     T_AND = 288,
+     T_EQUAL = 289,
+     T_NOT = 290
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+
+	char *string;
+	struct file *file;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	const struct kconf_id *id;
+
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Include zconf.hash.c here so it can see the token constants. */
+#include "zconf.hash.c"
+
+
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  11
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   290
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  36
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  50
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  118
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  191
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   290
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     6,     8,    11,    13,    14,    17,    20,
+      23,    26,    31,    36,    40,    42,    44,    46,    48,    50,
+      52,    54,    56,    58,    60,    62,    64,    66,    68,    72,
+      75,    79,    82,    86,    89,    90,    93,    96,    99,   102,
+     105,   108,   112,   117,   122,   127,   133,   137,   138,   142,
+     143,   146,   150,   153,   155,   159,   160,   163,   166,   169,
+     172,   175,   180,   184,   187,   192,   193,   196,   200,   202,
+     206,   207,   210,   213,   216,   220,   224,   228,   230,   234,
+     235,   238,   241,   244,   248,   252,   255,   258,   261,   262,
+     265,   268,   271,   276,   277,   280,   283,   286,   287,   290,
+     292,   294,   297,   300,   303,   305,   308,   309,   312,   314,
+     318,   322,   326,   329,   333,   337,   339,   341,   342
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      37,     0,    -1,    81,    38,    -1,    38,    -1,    63,    39,
+      -1,    39,    -1,    -1,    39,    41,    -1,    39,    55,    -1,
+      39,    67,    -1,    39,    80,    -1,    39,    26,     1,    31,
+      -1,    39,    40,     1,    31,    -1,    39,     1,    31,    -1,
+      16,    -1,    18,    -1,    19,    -1,    21,    -1,    17,    -1,
+      22,    -1,    20,    -1,    23,    -1,    31,    -1,    61,    -1,
+      71,    -1,    44,    -1,    46,    -1,    69,    -1,    26,     1,
+      31,    -1,     1,    31,    -1,    10,    26,    31,    -1,    43,
+      47,    -1,    11,    26,    31,    -1,    45,    47,    -1,    -1,
+      47,    48,    -1,    47,    49,    -1,    47,    75,    -1,    47,
+      73,    -1,    47,    42,    -1,    47,    31,    -1,    19,    78,
+      31,    -1,    18,    79,    82,    31,    -1,    20,    83,    82,
+      31,    -1,    21,    26,    82,    31,    -1,    22,    84,    84,
+      82,    31,    -1,    24,    50,    31,    -1,    -1,    50,    26,
+      51,    -1,    -1,    34,    79,    -1,     7,    85,    31,    -1,
+      52,    56,    -1,    80,    -1,    53,    58,    54,    -1,    -1,
+      56,    57,    -1,    56,    75,    -1,    56,    73,    -1,    56,
+      31,    -1,    56,    42,    -1,    18,    79,    82,    31,    -1,
+      19,    78,    31,    -1,    17,    31,    -1,    20,    26,    82,
+      31,    -1,    -1,    58,    41,    -1,    14,    83,    81,    -1,
+      80,    -1,    59,    62,    60,    -1,    -1,    62,    41,    -1,
+      62,    67,    -1,    62,    55,    -1,     3,    79,    81,    -1,
+       4,    79,    31,    -1,    64,    76,    74,    -1,    80,    -1,
+      65,    68,    66,    -1,    -1,    68,    41,    -1,    68,    67,
+      -1,    68,    55,    -1,     6,    79,    31,    -1,     9,    79,
+      31,    -1,    70,    74,    -1,    12,    31,    -1,    72,    13,
+      -1,    -1,    74,    75,    -1,    74,    31,    -1,    74,    42,
+      -1,    16,    25,    83,    31,    -1,    -1,    76,    77,    -1,
+      76,    31,    -1,    23,    82,    -1,    -1,    79,    82,    -1,
+      26,    -1,    27,    -1,     5,    31,    -1,     8,    31,    -1,
+      15,    31,    -1,    31,    -1,    81,    31,    -1,    -1,    14,
+      83,    -1,    84,    -1,    84,    34,    84,    -1,    84,    28,
+      84,    -1,    30,    83,    29,    -1,    35,    83,    -1,    83,
+      32,    83,    -1,    83,    33,    83,    -1,    26,    -1,    27,
+      -1,    -1,    26,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   104,   104,   104,   106,   106,   108,   110,   111,   112,
+     113,   114,   115,   119,   123,   123,   123,   123,   123,   123,
+     123,   123,   127,   128,   129,   130,   131,   132,   136,   137,
+     143,   151,   157,   165,   175,   177,   178,   179,   180,   181,
+     182,   185,   193,   199,   209,   215,   221,   224,   226,   237,
+     238,   243,   252,   257,   265,   268,   270,   271,   272,   273,
+     274,   277,   283,   294,   300,   310,   312,   317,   325,   333,
+     336,   338,   339,   340,   345,   352,   359,   364,   372,   375,
+     377,   378,   379,   382,   390,   397,   404,   410,   417,   419,
+     420,   421,   424,   432,   434,   435,   438,   445,   447,   452,
+     453,   456,   457,   458,   462,   463,   466,   467,   470,   471,
+     472,   473,   474,   475,   476,   479,   480,   483,   484
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU",
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG",
+  "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS",
+  "T_OPTIONAL", "T_PROMPT", "T_TYPE", "T_DEFAULT", "T_SELECT", "T_RANGE",
+  "T_VISIBLE", "T_OPTION", "T_ON", "T_WORD", "T_WORD_QUOTE", "T_UNEQUAL",
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_EOL", "T_OR", "T_AND", "T_EQUAL",
+  "T_NOT", "$accept", "input", "start", "stmt_list", "option_name",
+  "common_stmt", "option_error", "config_entry_start", "config_stmt",
+  "menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
+  "config_option", "symbol_option", "symbol_option_list",
+  "symbol_option_arg", "choice", "choice_entry", "choice_end",
+  "choice_stmt", "choice_option_list", "choice_option", "choice_block",
+  "if_entry", "if_end", "if_stmt", "if_block", "mainmenu_stmt", "menu",
+  "menu_entry", "menu_end", "menu_stmt", "menu_block", "source_stmt",
+  "comment", "comment_stmt", "help_start", "help", "depends_list",
+  "depends", "visibility_list", "visible", "prompt_stmt_opt", "prompt",
+  "end", "nl", "if_expr", "expr", "symbol", "word_opt", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    36,    37,    37,    38,    38,    39,    39,    39,    39,
+      39,    39,    39,    39,    40,    40,    40,    40,    40,    40,
+      40,    40,    41,    41,    41,    41,    41,    41,    42,    42,
+      43,    44,    45,    46,    47,    47,    47,    47,    47,    47,
+      47,    48,    48,    48,    48,    48,    49,    50,    50,    51,
+      51,    52,    53,    54,    55,    56,    56,    56,    56,    56,
+      56,    57,    57,    57,    57,    58,    58,    59,    60,    61,
+      62,    62,    62,    62,    63,    64,    65,    66,    67,    68,
+      68,    68,    68,    69,    70,    71,    72,    73,    74,    74,
+      74,    74,    75,    76,    76,    76,    77,    78,    78,    79,
+      79,    80,    80,    80,    81,    81,    82,    82,    83,    83,
+      83,    83,    83,    83,    83,    84,    84,    85,    85
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     1,     2,     1,     0,     2,     2,     2,
+       2,     4,     4,     3,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     3,     2,
+       3,     2,     3,     2,     0,     2,     2,     2,     2,     2,
+       2,     3,     4,     4,     4,     5,     3,     0,     3,     0,
+       2,     3,     2,     1,     3,     0,     2,     2,     2,     2,
+       2,     4,     3,     2,     4,     0,     2,     3,     1,     3,
+       0,     2,     2,     2,     3,     3,     3,     1,     3,     0,
+       2,     2,     2,     3,     3,     2,     2,     2,     0,     2,
+       2,     2,     4,     0,     2,     2,     2,     0,     2,     1,
+       1,     2,     2,     2,     1,     2,     0,     2,     1,     3,
+       3,     3,     2,     3,     3,     1,     1,     0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       6,     0,   104,     0,     3,     0,     6,     6,    99,   100,
+       0,     1,     0,     0,     0,     0,   117,     0,     0,     0,
+       0,     0,     0,    14,    18,    15,    16,    20,    17,    19,
+      21,     0,    22,     0,     7,    34,    25,    34,    26,    55,
+      65,     8,    70,    23,    93,    79,     9,    27,    88,    24,
+      10,     0,   105,     2,    74,    13,     0,   101,     0,   118,
+       0,   102,     0,     0,     0,   115,   116,     0,     0,     0,
+     108,   103,     0,     0,     0,     0,     0,     0,     0,    88,
+       0,     0,    75,    83,    51,    84,    30,    32,     0,   112,
+       0,     0,    67,     0,     0,    11,    12,     0,     0,     0,
+       0,    97,     0,     0,     0,    47,     0,    40,    39,    35,
+      36,     0,    38,    37,     0,     0,    97,     0,    59,    60,
+      56,    58,    57,    66,    54,    53,    71,    73,    69,    72,
+      68,   106,    95,     0,    94,    80,    82,    78,    81,    77,
+      90,    91,    89,   111,   113,   114,   110,   109,    29,    86,
+       0,   106,     0,   106,   106,   106,     0,     0,     0,    87,
+      63,   106,     0,   106,     0,    96,     0,     0,    41,    98,
+       0,     0,   106,    49,    46,    28,     0,    62,     0,   107,
+      92,    42,    43,    44,     0,     0,    48,    61,    64,    45,
+      50
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     3,     4,     5,    33,    34,   108,    35,    36,    37,
+      38,    74,   109,   110,   157,   186,    39,    40,   124,    41,
+      76,   120,    77,    42,   128,    43,    78,     6,    44,    45,
+     137,    46,    80,    47,    48,    49,   111,   112,    81,   113,
+      79,   134,   152,   153,    50,     7,   165,    69,    70,    60
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -90
+static const yytype_int16 yypact[] =
+{
+       4,    42,   -90,    96,   -90,   111,   -90,    15,   -90,   -90,
+      75,   -90,    82,    42,   104,    42,   110,   107,    42,   115,
+     125,    -4,   121,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   162,   -90,   163,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   139,   -90,   -90,   138,   -90,   142,   -90,   143,   -90,
+     152,   -90,   164,   167,   168,   -90,   -90,    -4,    -4,    77,
+     -18,   -90,   177,   185,    33,    71,   195,   247,   236,    -2,
+     236,   171,   -90,   -90,   -90,   -90,   -90,   -90,    41,   -90,
+      -4,    -4,   138,    97,    97,   -90,   -90,   186,   187,   194,
+      42,    42,    -4,   196,    97,   -90,   219,   -90,   -90,   -90,
+     -90,   210,   -90,   -90,   204,    42,    42,   199,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   222,   -90,   223,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   215,   -90,   -90,   -90,   -90,   -90,
+      -4,   222,   228,   222,    -5,   222,    97,    35,   229,   -90,
+     -90,   222,   232,   222,    -4,   -90,   135,   233,   -90,   -90,
+     234,   235,   222,   240,   -90,   -90,   237,   -90,   239,   -13,
+     -90,   -90,   -90,   -90,   244,    42,   -90,   -90,   -90,   -90,
+     -90
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+     -90,   -90,   269,   271,   -90,    23,   -70,   -90,   -90,   -90,
+     -90,   243,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -48,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -20,   -90,   -90,   -90,   -90,   -90,   206,   205,   -68,
+     -90,   -90,   169,    -1,    27,    -7,   118,   -66,   -89,   -90
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -86
+static const yytype_int16 yytable[] =
+{
+      10,    88,    89,    54,   146,   147,   119,     1,   122,   164,
+      93,   141,    56,   142,    58,   156,    94,    62,     1,    90,
+      91,   131,    65,    66,   144,   145,    67,    90,    91,   132,
+     127,    68,   136,   -31,    97,     2,   154,   -31,   -31,   -31,
+     -31,   -31,   -31,   -31,   -31,    98,    52,   -31,   -31,    99,
+     -31,   100,   101,   102,   103,   104,   -31,   105,   129,   106,
+     138,   173,    92,   141,   107,   142,   174,   172,     8,     9,
+     143,   -33,    97,    90,    91,   -33,   -33,   -33,   -33,   -33,
+     -33,   -33,   -33,    98,   166,   -33,   -33,    99,   -33,   100,
+     101,   102,   103,   104,   -33,   105,    11,   106,   179,   151,
+     123,   126,   107,   135,   125,   130,     2,   139,     2,    90,
+      91,    -5,    12,    55,   161,    13,    14,    15,    16,    17,
+      18,    19,    20,    65,    66,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    57,    59,    31,    61,    -4,
+      12,    63,    32,    13,    14,    15,    16,    17,    18,    19,
+      20,    64,    71,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    72,    73,    31,   180,    90,    91,    52,
+      32,   -85,    97,    82,    83,   -85,   -85,   -85,   -85,   -85,
+     -85,   -85,   -85,    84,   190,   -85,   -85,    99,   -85,   -85,
+     -85,   -85,   -85,   -85,   -85,    85,    97,   106,    86,    87,
+     -52,   -52,   140,   -52,   -52,   -52,   -52,    98,    95,   -52,
+     -52,    99,   114,   115,   116,   117,    96,   148,   149,   150,
+     158,   106,   155,   159,    97,   163,   118,   -76,   -76,   -76,
+     -76,   -76,   -76,   -76,   -76,   160,   164,   -76,   -76,    99,
+      13,    14,    15,    16,    17,    18,    19,    20,    91,   106,
+      21,    22,    14,    15,   140,    17,    18,    19,    20,   168,
+     175,    21,    22,   177,   181,   182,   183,    32,   187,   167,
+     188,   169,   170,   171,   185,   189,    53,    51,    32,   176,
+      75,   178,   121,     0,   133,   162,     0,     0,     0,     0,
+     184
+};
+
+static const yytype_int16 yycheck[] =
+{
+       1,    67,    68,    10,    93,    94,    76,     3,    76,    14,
+      28,    81,    13,    81,    15,   104,    34,    18,     3,    32,
+      33,    23,    26,    27,    90,    91,    30,    32,    33,    31,
+      78,    35,    80,     0,     1,    31,   102,     4,     5,     6,
+       7,     8,     9,    10,    11,    12,    31,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,    78,    26,
+      80,    26,    69,   133,    31,   133,    31,   156,    26,    27,
+      29,     0,     1,    32,    33,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,   150,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,     0,    26,   164,   100,
+      77,    78,    31,    80,    77,    78,    31,    80,    31,    32,
+      33,     0,     1,    31,   115,     4,     5,     6,     7,     8,
+       9,    10,    11,    26,    27,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,    26,    26,    31,     0,
+       1,    26,    31,     4,     5,     6,     7,     8,     9,    10,
+      11,    26,    31,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,     1,     1,    26,    31,    32,    33,    31,
+      31,     0,     1,    31,    31,     4,     5,     6,     7,     8,
+       9,    10,    11,    31,   185,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,     1,    26,    31,    31,
+       5,     6,    31,     8,     9,    10,    11,    12,    31,    14,
+      15,    16,    17,    18,    19,    20,    31,    31,    31,    25,
+       1,    26,    26,    13,     1,    26,    31,     4,     5,     6,
+       7,     8,     9,    10,    11,    31,    14,    14,    15,    16,
+       4,     5,     6,     7,     8,     9,    10,    11,    33,    26,
+      14,    15,     5,     6,    31,     8,     9,    10,    11,    31,
+      31,    14,    15,    31,    31,    31,    31,    31,    31,   151,
+      31,   153,   154,   155,    34,    31,     7,     6,    31,   161,
+      37,   163,    76,    -1,    79,   116,    -1,    -1,    -1,    -1,
+     172
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,    31,    37,    38,    39,    63,    81,    26,    27,
+      79,     0,     1,     4,     5,     6,     7,     8,     9,    10,
+      11,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,    26,    31,    40,    41,    43,    44,    45,    46,    52,
+      53,    55,    59,    61,    64,    65,    67,    69,    70,    71,
+      80,    39,    31,    38,    81,    31,    79,    31,    79,    26,
+      85,    31,    79,    26,    26,    26,    27,    30,    35,    83,
+      84,    31,     1,     1,    47,    47,    56,    58,    62,    76,
+      68,    74,    31,    31,    31,    31,    31,    31,    83,    83,
+      32,    33,    81,    28,    34,    31,    31,     1,    12,    16,
+      18,    19,    20,    21,    22,    24,    26,    31,    42,    48,
+      49,    72,    73,    75,    17,    18,    19,    20,    31,    42,
+      57,    73,    75,    41,    54,    80,    41,    55,    60,    67,
+      80,    23,    31,    74,    77,    41,    55,    66,    67,    80,
+      31,    42,    75,    29,    83,    83,    84,    84,    31,    31,
+      25,    79,    78,    79,    83,    26,    84,    50,     1,    13,
+      31,    79,    78,    26,    14,    82,    83,    82,    31,    82,
+      82,    82,    84,    26,    31,    31,    82,    31,    82,    83,
+      31,    31,    31,    31,    82,    34,    51,    31,    31,    31,
+      79
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
+
+#define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+      case 53: /* "choice_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 59: /* "if_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 65: /* "menu_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 10:
+
+    { zconf_error("unexpected end statement"); ;}
+    break;
+
+  case 11:
+
+    { zconf_error("unknown statement \"%s\"", (yyvsp[(2) - (4)].string)); ;}
+    break;
+
+  case 12:
+
+    {
+	zconf_error("unexpected option \"%s\"", kconf_id_strings + (yyvsp[(2) - (4)].id)->name);
+;}
+    break;
+
+  case 13:
+
+    { zconf_error("invalid statement"); ;}
+    break;
+
+  case 28:
+
+    { zconf_error("unknown option \"%s\"", (yyvsp[(1) - (3)].string)); ;}
+    break;
+
+  case 29:
+
+    { zconf_error("invalid option"); ;}
+    break;
+
+  case 30:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 31:
+
+    {
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 32:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 33:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 41:
+
+    {
+	menu_set_type((yyvsp[(1) - (3)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (3)].id)->stype);
+;}
+    break;
+
+  case 42:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 43:
+
+    {
+	menu_add_expr(P_DEFAULT, (yyvsp[(2) - (4)].expr), (yyvsp[(3) - (4)].expr));
+	if ((yyvsp[(1) - (4)].id)->stype != S_UNKNOWN)
+		menu_set_type((yyvsp[(1) - (4)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (4)].id)->stype);
+;}
+    break;
+
+  case 44:
+
+    {
+	menu_add_symbol(P_SELECT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 45:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[(2) - (5)].symbol), (yyvsp[(3) - (5)].symbol)), (yyvsp[(4) - (5)].expr));
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 48:
+
+    {
+	const struct kconf_id *id = kconf_id_lookup((yyvsp[(2) - (3)].string), strlen((yyvsp[(2) - (3)].string)));
+	if (id && id->flags & TF_OPTION)
+		menu_add_option(id->token, (yyvsp[(3) - (3)].string));
+	else
+		zconfprint("warning: ignoring unknown option %s", (yyvsp[(2) - (3)].string));
+	free((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 49:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+  case 50:
+
+    { (yyval.string) = (yyvsp[(2) - (2)].string); ;}
+    break;
+
+  case 51:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), SYMBOL_CHOICE);
+	sym->flags |= SYMBOL_AUTO;
+	menu_add_entry(sym);
+	menu_add_expr(P_CHOICE, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 52:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 53:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 61:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 62:
+
+    {
+	if ((yyvsp[(1) - (3)].id)->stype == S_BOOLEAN || (yyvsp[(1) - (3)].id)->stype == S_TRISTATE) {
+		menu_set_type((yyvsp[(1) - (3)].id)->stype);
+		printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+			zconf_curname(), zconf_lineno(),
+			(yyvsp[(1) - (3)].id)->stype);
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 63:
+
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 64:
+
+    {
+	if ((yyvsp[(1) - (4)].id)->stype == S_UNKNOWN) {
+		menu_add_symbol(P_DEFAULT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+		printd(DEBUG_PARSE, "%s:%d:default\n",
+			zconf_curname(), zconf_lineno());
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 67:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	menu_add_dep((yyvsp[(2) - (3)].expr));
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 68:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 74:
+
+    {
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+;}
+    break;
+
+  case 75:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 76:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 77:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 83:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+	zconf_nextfile((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 84:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_COMMENT, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 85:
+
+    {
+	menu_end_entry();
+;}
+    break;
+
+  case 86:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;}
+    break;
+
+  case 87:
+
+    {
+	current_entry->help = (yyvsp[(2) - (2)].string);
+;}
+    break;
+
+  case 92:
+
+    {
+	menu_add_dep((yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 96:
+
+    {
+	menu_add_visibility((yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 98:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 101:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 102:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 103:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 106:
+
+    { (yyval.expr) = NULL; ;}
+    break;
+
+  case 107:
+
+    { (yyval.expr) = (yyvsp[(2) - (2)].expr); ;}
+    break;
+
+  case 108:
+
+    { (yyval.expr) = expr_alloc_symbol((yyvsp[(1) - (1)].symbol)); ;}
+    break;
+
+  case 109:
+
+    { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 110:
+
+    { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 111:
+
+    { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
+    break;
+
+  case 112:
+
+    { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[(2) - (2)].expr)); ;}
+    break;
+
+  case 113:
+
+    { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 114:
+
+    { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 115:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), 0); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 116:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), SYMBOL_CONST); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 117:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+
+
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+
+
+void conf_parse(const char *name)
+{
+	struct symbol *sym;
+	int i;
+
+	zconf_initscan(name);
+
+	sym_init();
+	_menu_init();
+	modules_sym = sym_lookup(NULL, 0);
+	modules_sym->type = S_BOOLEAN;
+	modules_sym->flags |= SYMBOL_AUTO;
+	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
+
+	if (getenv("ZCONF_DEBUG"))
+		zconfdebug = 1;
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	if (!modules_sym->prop) {
+		struct property *prop;
+
+		prop = prop_alloc(P_DEFAULT, modules_sym);
+		prop->expr = expr_alloc_symbol(sym_lookup("MODULES", 0));
+	}
+
+	rootmenu.prompt->text = _(rootmenu.prompt->text);
+	rootmenu.prompt->text = sym_expand_string_value(rootmenu.prompt->text);
+
+	menu_finalize(&rootmenu);
+	for_all_symbols(i, sym) {
+		if (sym_check_deps(sym))
+			zconfnerrs++;
+        }
+	if (zconfnerrs)
+		exit(1);
+	sym_set_change_count(1);
+}
+
+static const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	case T_DEPENDS:		return "depends";
+	case T_VISIBLE:		return "visible";
+	}
+	return "<token>";
+}
+
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken)
+{
+	if (id->token != endtoken) {
+		zconf_error("unexpected '%s' within %s block",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconf_error("'%s' in different file than '%s'",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		fprintf(stderr, "%s:%d: location of the '%s'\n",
+			current_menu->file->name, current_menu->lineno,
+			zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconf_error(const char *err, ...)
+{
+	va_list ap;
+
+	zconfnerrs++;
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+}
+
+static void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+static void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "\nchoice\n");
+	else
+		fprintf(out, "\nconfig %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		case P_SELECT:
+			fputs( "  select ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_RANGE:
+			fputs( "  range ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_MENU:
+			fputs( "  menu ", out);
+			print_quoted_string(out, prop->text);
+			fputc('\n', out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (menu->help) {
+		int len = strlen(menu->help);
+		while (menu->help[--len] == '\n')
+			menu->help[len] = 0;
+		fprintf(out, "  help\n%s\n", menu->help);
+	}
+}
+
+void zconfdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs("  depends ", out);
+				expr_fprint(prop->visible.expr, out);
+				fputc('\n', out);
+			}
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "zconf.lex.c"
+#include "util.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
+
diff -Naur linux-3.4.11/scripts/Makefile.lib linux-HEAD/scripts/Makefile.lib
--- linux-3.4.11/scripts/Makefile.lib	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/scripts/Makefile.lib	2015-11-18 09:04:24.000000000 +0000
@@ -328,6 +328,18 @@
 			-a $(UIMAGE_LOADADDR) -e $(UIMAGE_ENTRYADDR) \
 			-n $(UIMAGE_NAME) -d $(UIMAGE_IN) $(UIMAGE_OUT)
 
+# CE-Image
+# ---------------------------------------------------------------------------
+
+CE_DATA2BIN = ce-data2bin
+
+CE_LOADADDR ?= $(LOADADDR)
+CE_ENTRYADDR ?= $(CE_LOADADDR)
+
+quiet_cmd_ceimage = CEIMAGE $@
+      cmd_ceimage = $(CE_DATA2BIN) $< $(CE_LOADADDR) $(CE_ENTRYADDR) > $@
+
+
 # XZ
 # ---------------------------------------------------------------------------
 # Use xzkern to compress the kernel image and xzmisc to compress other things.
diff -Naur linux-3.4.11/sound/arm/pxa2xx-ac97.c linux-HEAD/sound/arm/pxa2xx-ac97.c
--- linux-3.4.11/sound/arm/pxa2xx-ac97.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/sound/arm/pxa2xx-ac97.c	2015-11-18 09:04:24.000000000 +0000
@@ -22,7 +22,7 @@
 #include <sound/pxa2xx-lib.h>
 
 #include <mach/regs-ac97.h>
-#include <mach/audio.h>
+#include <plat/audio.h>
 
 #include "pxa2xx-pcm.h"
 
diff -Naur linux-3.4.11/sound/arm/pxa2xx-ac97-lib.c linux-HEAD/sound/arm/pxa2xx-ac97-lib.c
--- linux-3.4.11/sound/arm/pxa2xx-ac97-lib.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/sound/arm/pxa2xx-ac97-lib.c	2015-11-18 09:04:24.000000000 +0000
@@ -24,7 +24,7 @@
 
 #include <mach/irqs.h>
 #include <mach/regs-ac97.h>
-#include <mach/audio.h>
+#include <plat/audio.h>
 
 static DEFINE_MUTEX(car_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(gsr_wq);
diff -Naur linux-3.4.11/sound/soc/codecs/Kconfig linux-HEAD/sound/soc/codecs/Kconfig
--- linux-3.4.11/sound/soc/codecs/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/sound/soc/codecs/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -437,3 +437,6 @@
 
 config SND_SOC_TPA6130A2
 	tristate
+
+config SND_SOC_UCB1400
+	tristate
diff -Naur linux-3.4.11/sound/soc/codecs/Makefile linux-HEAD/sound/soc/codecs/Makefile
--- linux-3.4.11/sound/soc/codecs/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/sound/soc/codecs/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -98,6 +98,8 @@
 snd-soc-wm9713-objs := wm9713.o
 snd-soc-wm-hubs-objs := wm_hubs.o
 
+snd-soc-ucb1400-objs := ucb1400.o
+
 # Amp
 snd-soc-max9877-objs := max9877.o
 snd-soc-tpa6130a2-objs := tpa6130a2.o
@@ -202,6 +204,8 @@
 obj-$(CONFIG_SND_SOC_WM9713)	+= snd-soc-wm9713.o
 obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
 
+obj-$(CONFIG_SND_SOC_UCB1400)	+= snd-soc-ucb1400.o
+
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
 obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
diff -Naur linux-3.4.11/sound/soc/codecs/ucb1400.c linux-HEAD/sound/soc/codecs/ucb1400.c
--- linux-3.4.11/sound/soc/codecs/ucb1400.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/sound/soc/codecs/ucb1400.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,321 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/ucb1400.h>
+
+#include <sound/initval.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/ac97_codec.h>
+
+static uint16_t	ucb1400_regs[0x80/2] = {
+	[AC97_RESET/2]			= 0x02a0, /* 0x00 */
+	[AC97_MASTER/2]			= 0x8000, /* 0x02 */
+	[AC97_MIC/2]			= 0x0000, /* 0x0e */
+	[AC97_REC_SEL/2]		= 0x0000, /* 0x1a */
+	[AC97_REC_GAIN/2]		= 0x0000, /* 0x1c */
+	[AC97_GENERAL_PURPOSE/2]	= 0x0000, /* 0x20 */
+	[AC97_POWERDOWN/2]		= 0x0000, /* 0x26 */
+	[AC97_EXTENDED_ID/2]		= 0x0001, /* 0x28 */
+	[AC97_EXTENDED_STATUS/2]	= 0x0000, /* 0x2a */
+	[AC97_PCM_FRONT_DAC_RATE/2]	= 0xbb80, /* 0x2c */
+	[AC97_PCM_LR_ADC_RATE/2]	= 0xbb80, /* 0x32 */
+	[AC97_VENDOR_ID1/2]		= 0x5053, /* 0x7c */
+	[AC97_VENDOR_ID2/2]		= 0x4304, /* 0x7e */
+
+	[UCB_IO_DATA/2]			= 0x0000, /* 0x5a */
+	[UCB_IO_DIR/2]			= 0x0000, /* 0x5c */
+	[UCB_IE_RIS/2]			= 0x0000, /* 0x5e */
+	[UCB_IE_FAL/2]			= 0x0000, /* 0x60 */
+	[UCB_IE_STATUS/2]		= 0x0000, /* 0x62 */
+	[UCB_TS_CR/2]			= 0x0000, /* 0x64 */
+	[UCB_ADC_CR/2]			= 0x0000, /* 0x66 */
+	[UCB_ADC_DATA/2]		= 0x0000, /* 0x68 */
+	[UCB_FCSR1/2]			= 0x0000, /* 0x6a */
+	[UCB_FCSR2/2]			= 0x0000, /* 0x6c */
+	[UCB_TEST_CTRL/2]		= 0x0000, /* 0x6e */
+	[UCB_EXTRA_INT/2]		= 0x0000, /* 0x70 */
+};
+
+static const char *ucb1400_rec_sel_left[] = {
+	"Mic", "NC", "NC", "NC", "LineL"
+};
+
+static const char *ucb1400_rec_sel_right[] = {
+	"Left", "NC", "NC", "NC", "LineR"
+};
+
+static const char *ucb1400_feature_mode[] = {
+	"flat", "minimum", "minimum", "maximum",
+};
+
+static const struct soc_enum ucb1400_enum[] = {
+	SOC_ENUM_SINGLE(AC97_REC_SEL, 8, 5, ucb1400_rec_sel_left),
+	SOC_ENUM_SINGLE(AC97_REC_SEL, 0, 5, ucb1400_rec_sel_right),
+	SOC_ENUM_SINGLE(UCB_FCSR1,    7, 4, ucb1400_feature_mode),
+};
+
+static const struct snd_kcontrol_new ucb1400_snd_ac97_controls[] = {
+	SOC_DOUBLE("Master Volume", AC97_MASTER,  8, 0, 63, 1),
+	SOC_SINGLE("Master Switch", AC97_MASTER, 15, 1,  1),
+
+	SOC_SINGLE("Mic 20db boost", AC97_MIC,    6, 1,  0),
+
+	SOC_ENUM("Record Select L", ucb1400_enum[0]),
+	SOC_ENUM("Record Select R", ucb1400_enum[1]),
+
+	SOC_DOUBLE("Record Gain", AC97_REC_GAIN,  8, 0, 15, 0),
+
+	SOC_SINGLE("ADC/DAC loopback", AC97_GENERAL_PURPOSE,  7, 1, 0),
+
+	SOC_SINGLE("Bass Boost",   UCB_FCSR1,  11, 15, 0),
+	SOC_SINGLE("Treble Boost", UCB_FCSR1,   9,  3, 0),
+	SOC_ENUM("Mode", ucb1400_enum[2]),
+
+	SOC_SINGLE("Headphone driver", UCB_FCSR1,   6,  1, 0),
+	SOC_SINGLE("De-emphasis",      UCB_FCSR1,   5,  1, 0),
+	SOC_SINGLE("DC filter",        UCB_FCSR1,   4,  1, 0),
+	SOC_SINGLE("High-pass filter", UCB_FCSR1,   3,  1, 0),
+};
+
+static const struct snd_soc_dapm_widget ucb1400_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("LINEOUTL"),
+	SND_SOC_DAPM_OUTPUT("LINEOUTR"),
+	SND_SOC_DAPM_INPUT("LINEINL"),
+	SND_SOC_DAPM_INPUT("LINEINR"),
+	SND_SOC_DAPM_INPUT("MIC"),
+};
+
+static unsigned int ac97_read(struct snd_soc_codec *codec,
+			      unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+
+	switch (reg) {
+	case AC97_RESET:
+	case AC97_GPIO_STATUS:
+	case AC97_VENDOR_ID1:
+	case AC97_VENDOR_ID2:
+	case AC97_REC_GAIN:
+	case UCB_IO_DATA:
+	case UCB_IE_STATUS:
+	case UCB_EXTRA_INT:
+		return soc_ac97_ops.read(codec->ac97, reg);
+
+	default:
+		reg /= 2;
+
+		if (reg >= ARRAY_SIZE(ucb1400_regs))
+			return -EIO;
+
+		return cache[reg];
+	}
+}
+
+static int ac97_write(struct snd_soc_codec *codec, unsigned int reg,
+		      unsigned int val)
+{
+	u16 *cache = codec->reg_cache;
+
+	if (reg < 0x7c)
+		soc_ac97_ops.write(codec->ac97, reg, val);
+	reg = reg >> 1;
+	if (reg < ARRAY_SIZE(ucb1400_regs))
+		cache[reg] = val;
+
+	return 0;
+}
+
+static int ucb1400_set_bias_level(struct snd_soc_codec *codec,
+				  enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+	case SND_SOC_BIAS_PREPARE:
+		ac97_write(codec, AC97_POWERDOWN, 0x0000);
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		/* Audio Vref power-down, Audio DAC output down,
+		   Audio ADC in down */
+		ac97_write(codec, AC97_POWERDOWN, (1<<11) | (1<<9) | (1<<8));
+		break;
+	case SND_SOC_BIAS_OFF:
+		/* disable everything including AC link */
+		ac97_write(codec, AC97_POWERDOWN,
+			   (1<<11) | (1<<9) | (1<<8) |
+			   (1<<12) | (1<<13));
+		break;
+	}
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+static int ac97_prepare(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec =rtd->codec;
+	int reg;
+	u16 vra;
+
+	vra = ac97_read(codec, AC97_EXTENDED_STATUS);
+	ac97_write(codec, AC97_EXTENDED_STATUS, vra | 0x1);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		reg = AC97_PCM_FRONT_DAC_RATE;
+	else
+		reg = AC97_PCM_LR_ADC_RATE;
+
+	return ac97_write(codec, reg, runtime->rate);
+}
+
+#define UCB1400_AC97_RATES (SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 | \
+			    SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \
+			    SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+			    /* SNDRV_PCM_RATE_12000 | SNDRV_PCM_RATE_24000 | */ \
+			    SNDRV_PCM_RATE_48000)
+
+static struct snd_soc_dai_ops ucb1400_dai_ops_hifi = {
+	.prepare	= ac97_prepare,
+};
+
+
+/* codec DAI instance */
+static struct snd_soc_dai_driver ucb1400_dai[] = {
+	{
+		.name = "ucb1400-hifi",
+		.ac97_control = 1,
+		.playback = {
+			.stream_name = "HiFi Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = UCB1400_AC97_RATES,
+			.formats = SND_SOC_STD_AC97_FMTS,
+		},
+		.capture = {
+			.stream_name = "HiFi Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = UCB1400_AC97_RATES,
+			.formats = SND_SOC_STD_AC97_FMTS,
+		},
+		.ops = &ucb1400_dai_ops_hifi,
+	},
+};
+
+void ucb1400_dump(struct snd_ac97 *ac97)
+{
+	size_t		i;
+	uint16_t	regs[ARRAY_SIZE(ucb1400_regs)];
+
+	for (i = 0; i < ARRAY_SIZE(regs); ++i)
+		regs[i] = soc_ac97_ops.read(ac97, i*2);
+
+	print_hex_dump(KERN_INFO, "ac97: ", DUMP_PREFIX_OFFSET,
+		       16, 2, regs, sizeof regs, 0);
+}
+EXPORT_SYMBOL(ucb1400_dump);
+
+static int ucb1400_probe(struct snd_soc_codec *codec)
+{
+	struct snd_soc_dapm_context	*dapm = &codec->dapm;
+	int				ret = 0;
+
+	ret = snd_soc_new_ac97_codec(codec, &soc_ac97_ops, 0);
+	if (ret < 0) {
+		dev_err(codec->dev, "ucb1400: failed to register AC97 codec\n");
+		return ret;
+	}
+
+	soc_ac97_ops.reset(codec->ac97);
+
+	ucb1400_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	snd_soc_add_codec_controls(codec, ucb1400_snd_ac97_controls,
+				   ARRAY_SIZE(ucb1400_snd_ac97_controls));
+
+
+	snd_soc_dapm_new_controls(dapm, ucb1400_dapm_widgets,
+				  ARRAY_SIZE(ucb1400_dapm_widgets));
+
+	return 0;
+}
+
+static int ucb1400_remove(struct snd_soc_codec *codec)
+{
+	snd_soc_free_ac97_codec(codec);
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_ucb1400 = {
+	.probe			= ucb1400_probe,
+	.read			= ac97_read,
+	.write			= ac97_write,
+	.remove			= ucb1400_remove,
+	.set_bias_level		= ucb1400_set_bias_level,
+
+	.reg_cache_size		= ARRAY_SIZE(ucb1400_regs),
+	.reg_word_size		= sizeof(ucb1400_regs[0]),
+	.reg_cache_step		= 2,
+	.reg_cache_default	= ucb1400_regs,
+};
+
+static int __devinit ucb1400_platform_probe(struct platform_device *pdev)
+{
+	int	rc;
+
+	rc = snd_soc_register_codec(&pdev->dev,
+				    &soc_codec_dev_ucb1400,
+				    &(ucb1400_dai[0]),
+				    ARRAY_SIZE(ucb1400_dai));
+	return rc;
+}
+
+static int __devexit ucb1400_platform_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver ucb1400_codec_driver = {
+	.driver = {
+		.name = "ucb1400-codec",
+		.owner = THIS_MODULE,
+	},
+
+	.probe = ucb1400_platform_probe,
+	.remove = __devexit_p(ucb1400_platform_remove),
+};
+
+static int __init ucb1400_init(void)
+{
+	return platform_driver_register(&ucb1400_codec_driver);
+}
+module_init(ucb1400_init);
+
+static void __exit ucb1400_exit(void)
+{
+	platform_driver_unregister(&ucb1400_codec_driver);
+}
+module_exit(ucb1400_exit);
+
+MODULE_DESCRIPTION("UCB1400 Codec Driver");
+MODULE_AUTHOR("Enrico Scholz");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ucb1400-codec");
diff -Naur linux-3.4.11/sound/soc/codecs/wm9712.c linux-HEAD/sound/soc/codecs/wm9712.c
--- linux-3.4.11/sound/soc/codecs/wm9712.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/sound/soc/codecs/wm9712.c	2015-11-18 09:04:24.000000000 +0000
@@ -148,7 +148,7 @@
 
 SOC_SINGLE("Capture ADC Switch", AC97_REC_GAIN, 15, 1, 1),
 SOC_ENUM("Capture Volume Steps", wm9712_enum[6]),
-SOC_DOUBLE("Capture Volume", AC97_REC_GAIN, 8, 0, 63, 1),
+SOC_DOUBLE("Capture Volume", AC97_REC_GAIN, 8, 0, 63, 0),
 SOC_SINGLE("Capture ZC Switch", AC97_REC_GAIN, 7, 1, 0),
 
 SOC_SINGLE_TLV("Mic 1 Volume", AC97_MIC, 8, 31, 1, main_tlv),
@@ -713,3 +713,4 @@
 MODULE_DESCRIPTION("ASoC WM9711/WM9712 driver");
 MODULE_AUTHOR("Liam Girdwood");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:wm9712-codec");
diff -Naur linux-3.4.11/sound/soc/pxa/Kconfig linux-HEAD/sound/soc/pxa/Kconfig
--- linux-3.4.11/sound/soc/pxa/Kconfig	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/sound/soc/pxa/Kconfig	2015-11-18 09:04:24.000000000 +0000
@@ -1,6 +1,6 @@
 config SND_PXA2XX_SOC
 	tristate "SoC Audio for the Intel PXA2xx chip"
-	depends on ARCH_PXA
+	depends on ARCH_PXA || ARCH_MMP
 	select SND_ARM
 	select SND_PXA2XX_LIB
 	help
@@ -14,6 +14,7 @@
 
 config SND_PXA2XX_SOC_AC97
 	tristate
+	depends on ARCH_PXA
 	select AC97_BUS
 	select SND_ARM
 	select SND_PXA2XX_LIB_AC97
@@ -26,6 +27,12 @@
 	tristate
 	select PXA_SSP
 
+config SND_PXA_SOC_AC97
+	tristate
+	select AC97_BUS
+	select SND_ARM
+	select SND_SOC_AC97_BUS
+
 config SND_PXA2XX_SOC_CORGI
 	tristate "SoC Audio support for Sharp Zaurus SL-C7x0"
 	depends on SND_PXA2XX_SOC && PXA_SHARP_C7xx
diff -Naur linux-3.4.11/sound/soc/pxa/Makefile linux-HEAD/sound/soc/pxa/Makefile
--- linux-3.4.11/sound/soc/pxa/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/sound/soc/pxa/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -3,11 +3,13 @@
 snd-soc-pxa2xx-ac97-objs := pxa2xx-ac97.o
 snd-soc-pxa2xx-i2s-objs := pxa2xx-i2s.o
 snd-soc-pxa-ssp-objs := pxa-ssp.o
+snd-soc-pxa-ac97-objs := pxa-ac97.o pxa-ac97-bus.o
 
 obj-$(CONFIG_SND_PXA2XX_SOC) += snd-soc-pxa2xx.o
 obj-$(CONFIG_SND_PXA2XX_SOC_AC97) += snd-soc-pxa2xx-ac97.o
 obj-$(CONFIG_SND_PXA2XX_SOC_I2S) += snd-soc-pxa2xx-i2s.o
 obj-$(CONFIG_SND_PXA_SOC_SSP) += snd-soc-pxa-ssp.o
+obj-$(CONFIG_SND_PXA_SOC_AC97) += snd-soc-pxa-ac97.o
 
 # PXA Machine Support
 snd-soc-corgi-objs := corgi.o
diff -Naur linux-3.4.11/sound/soc/pxa/pxa2xx-ac97.c linux-HEAD/sound/soc/pxa/pxa2xx-ac97.c
--- linux-3.4.11/sound/soc/pxa/pxa2xx-ac97.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/sound/soc/pxa/pxa2xx-ac97.c	2015-11-18 09:04:24.000000000 +0000
@@ -23,7 +23,7 @@
 #include <mach/hardware.h>
 #include <mach/regs-ac97.h>
 #include <mach/dma.h>
-#include <mach/audio.h>
+#include <plat/audio.h>
 
 #include "pxa2xx-ac97.h"
 
@@ -269,3 +269,4 @@
 MODULE_AUTHOR("Nicolas Pitre");
 MODULE_DESCRIPTION("AC97 driver for the Intel PXA2xx chip");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pxa2xx-ac97");
diff -Naur linux-3.4.11/sound/soc/pxa/pxa2xx-pcm.c linux-HEAD/sound/soc/pxa/pxa2xx-pcm.c
--- linux-3.4.11/sound/soc/pxa/pxa2xx-pcm.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/sound/soc/pxa/pxa2xx-pcm.c	2015-11-18 09:04:24.000000000 +0000
@@ -146,3 +146,4 @@
 MODULE_AUTHOR("Nicolas Pitre");
 MODULE_DESCRIPTION("Intel PXA2xx PCM DMA module");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pxa-pcm-audio");
diff -Naur linux-3.4.11/sound/soc/pxa/pxa-ac97-bus.c linux-HEAD/sound/soc/pxa/pxa-ac97-bus.c
--- linux-3.4.11/sound/soc/pxa/pxa-ac97-bus.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/sound/soc/pxa/pxa-ac97-bus.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,437 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define DEBUG
+
+#include "pxa-ac97.h"
+
+#include <linux/sched.h>
+#include <linux/export.h>
+
+struct pxa_ac97_device	*g_pxa_ac97_device = NULL;
+
+static struct pxa_ac97_device *to_pxa_ac97(struct snd_ac97 *ac97)
+{
+	/* HACK: Codec initialization does not provide the required
+	 * information to calculate the real device object.  Use global
+	 * pointer instead of. */
+	return g_pxa_ac97_device;
+#if 0
+	return ac97->private_data;
+#endif
+}
+
+static uintptr_t pxa_ac97_reg_addr(struct snd_ac97 const *ac97,
+				   unsigned short reg)
+{
+	uintptr_t		reg_addr;
+
+	if (cpu_is_pxa25x()) {
+		/* set up primary or secondary codec space */
+		if (reg == AC97_GPIO_STATUS)
+			reg_addr = ac97->num ? SMC_REG_BASE : PMC_REG_BASE;
+		else
+			reg_addr = ac97->num ? SAC_REG_BASE : PAC_REG_BASE;
+	} else {
+		reg_addr = ((ac97->num == 0) ? PAC_REG_BASE :
+			    (ac97->num == 1) ? SAC_REG_BASE :
+			    (ac97->num == 2) ? PMC_REG_BASE : SMC_REG_BASE);
+	}
+
+	reg_addr += (reg >> 1) * 4;
+
+	return reg_addr;
+}
+
+static int pxa_ac97_acquire_car(struct pxa_ac97_device *pxa)
+{
+	unsigned int		timeout = 1000;
+
+	while ((_ac97_read(pxa, CAR) & CAR_CAIP) != 0 && timeout > 0)
+		--timeout;
+
+	if (timeout == 0)
+		dev_err(pxa->dev, "failed to lock access to codec\n");
+
+	return timeout > 0 ? 0 : -1;
+}
+
+static void pxa_ac97_release_car(struct pxa_ac97_device *pxa)
+{
+	_ac97_write(pxa, 0, CAR);
+}
+
+static int pxa_ac97_wait_for_gsr(struct pxa_ac97_device *pxa,
+				 unsigned long gsr_bits,
+				 unsigned int wait_jiffies)
+{
+	int		rc;
+
+	rc = wait_event_timeout(pxa->gsr_wq,
+				pxa->gsr_bits & gsr_bits,
+				wait_jiffies);
+
+	if (rc < 0) {
+		unsigned long	gsr = ac97_read_gsr(pxa);
+
+		if (!(gsr & gsr_bits))
+			dev_err(pxa->dev,
+				"timeout while waiting for GSR bits %08lx; active bits=%08lx\n",
+				gsr_bits, gsr);
+		else {
+			dev_dbg(pxa->dev,
+				"GSR bits %08lx set after timeout; problem with interupt handler?\n",
+				gsr_bits);
+			rc = 0;
+		}
+	}
+
+	return rc;
+}
+
+static void pxa_ac97_clear_gsr(struct pxa_ac97_device *pxa,
+			       unsigned long gsr_bits)
+{
+	_ac97_write(pxa, gsr_bits, GSR);
+	pxa->gsr_bits &= ~gsr_bits;
+}
+
+static unsigned short pxa_ac97_bus_read_internal(struct pxa_ac97_device *pxa,
+						 unsigned short reg_addr)
+{
+	unsigned short		val;
+
+	if (pxa_ac97_acquire_car(pxa) < 0)
+		return -1;
+
+	pxa_ac97_clear_gsr(pxa, GSR_SDONE);
+
+	/* read dummy data */
+	val = _ac97_read(pxa, reg_addr);
+
+	if (pxa_ac97_wait_for_gsr(pxa, GSR_SDONE, HZ/1000 + 1) < 0) {
+		dev_err(pxa->dev, "ac97_read: read error (reg_addr=%04x)\n",
+			reg_addr);
+		val = -1;
+
+		/* release CAR explicitly */
+		pxa_ac97_release_car(pxa);
+		goto out;
+	}
+
+	/* read the valid data now */
+	pxa_ac97_acquire_car(pxa);
+	pxa_ac97_clear_gsr(pxa, GSR_SDONE);
+	val = _ac97_read(pxa, reg_addr);
+
+	/* wait for cycle to finish which we have just started */
+	pxa_ac97_wait_for_gsr(pxa, GSR_SDONE, HZ/1000 + 1);
+
+out:
+	return val;
+}
+
+static unsigned short pxa_ac97_bus_read(struct snd_ac97 *ac97,
+					unsigned short reg)
+{
+	struct pxa_ac97_device	*pxa = to_pxa_ac97(ac97);
+	uintptr_t		reg_addr = pxa_ac97_reg_addr(ac97, reg);
+	unsigned short		val = -1;
+
+	mutex_lock(&pxa->car_mutex);
+
+	if (reg == AC97_GPIO_STATUS)	/* ch12 reg is always valid */
+		val = _ac97_read(pxa, reg_addr);
+	else {
+		/* enable SDONE interrupts */
+		ac97_set_clear(pxa, GCR, GCR_SDONE_IE, 0);
+		val = pxa_ac97_bus_read_internal(pxa, reg_addr);
+		ac97_set_clear(pxa, GCR, 0, GCR_SDONE_IE);
+	}
+
+	mutex_unlock(&pxa->car_mutex);
+
+	return val;
+}
+
+static void pxa_ac97_bus_write(struct snd_ac97 *ac97, unsigned short reg,
+			       unsigned short val)
+{
+	struct pxa_ac97_device	*pxa = to_pxa_ac97(ac97);
+	uintptr_t		reg_addr  = pxa_ac97_reg_addr(ac97, reg);
+
+	mutex_lock(&pxa->car_mutex);
+
+	if (pxa_ac97_acquire_car(pxa) < 0)
+		goto out;
+
+	ac97_set_clear(pxa, GCR, GCR_CDONE_IE, 0);
+	pxa_ac97_clear_gsr(pxa, GSR_CDONE);
+
+	_ac97_write(pxa, val, reg_addr);
+
+	if (pxa_ac97_wait_for_gsr(pxa, GSR_CDONE, HZ/1000 + 1) < 0) {
+		dev_err(pxa->dev, "%s: write error (ac97_reg=%02x val=%04x)\n",
+			__func__, reg, val);
+
+		/* release CAR explicitly */
+		pxa_ac97_release_car(pxa);
+	}
+
+	ac97_set_clear(pxa, GCR, 0, GCR_CDONE_IE);
+
+out:
+	mutex_unlock(&pxa->car_mutex);
+}
+
+static void pxa_ac97_assert_nCOLD(struct pxa_ac97_device *pxa)
+{
+	/* clear everything but nCRST */
+	_ac97_write(pxa, GCR_nCOLD_RST, GCR);
+
+	/* assert nCRST */
+	_ac97_write(pxa, 0, GCR);
+	pxa->gsr_bits = 0;
+
+	if (pxa->reset_codec)
+		pxa->reset_codec(pxa->platform_priv, 1);
+}
+
+static void pxa_ac97_deassert_nCOLD(struct pxa_ac97_device *pxa)
+{
+	if (pxa->reset_codec)
+		pxa->reset_codec(pxa->platform_priv, 0);
+
+	_ac97_write(pxa, GCR_nCOLD_RST, GCR);
+}
+
+#ifdef CONFIG_PXA25x
+static inline void pxa_ac97_warm_pxa25x(struct pxa_ac97_device *pxa)
+{
+	pxa->gsr_bits = 0;
+
+	ac97_set_clear(pxa, GCR,
+		       GCR_WARM_RST | GCR_PRIRDY_IEN | GCR_SECRDY_IEN,
+		       0);
+
+	pxa_ac97_wait_for_gsr(pxa, GSR_PCR | GSR_SCR, HZ/100);
+}
+
+static inline void pxa_ac97_cold_pxa25x(struct pxa_ac97_device *pxa)
+{
+	pxa_ac97_assert_nCOLD(pxa);
+	udelay(2);			/* tRST_LOW */
+	pxa_ac97_deassert_nCOLD(pxa);
+
+	ac97_set_clear(pxa, GCR, GCR_CDONE_IE|GCR_SDONE_IE, 0);
+	pxa_ac97_wait_for_gsr(pxa, GSR_PCR | GSR_SCR, HZ/100);
+}
+#else
+extern void pxa_ac97_warm_pxa25x(struct pxa_ac97_device *pxa);
+extern void pxa_ac97_cold_pxa25x(struct pxa_ac97_device *pxa);
+#endif
+
+#ifdef CONFIG_PXA27x
+static inline void pxa_ac97_warm_pxa27x(struct pxa_ac97_device *pxa)
+{
+	pxa->gsr_bits = 0;
+
+	/* warm reset broken on Bulverde, so manually keep AC97 reset high */
+	pxa27x_assert_ac97reset(pxa->reset_gpio, 1);
+	udelay(10);
+	ac97_set_clear(pxa, GCR, GCR_WARM_RST, 0);
+	pxa27x_assert_ac97reset(pxa->reset_gpio, 0);
+	udelay(500);
+}
+
+static inline void pxa_ac97_cold_pxa27x(struct pxa_ac97_device *pxa)
+{
+	pxa_ac97_assert_nCOLD(pxa);
+
+	/* PXA27x Developers Manual section 13.5.2.2.1 */
+	clk_enable(pxa->conf_clk);
+	udelay(5);
+	clk_disable(pxa->conf_clk);
+	pxa_ac97_deassert_nCOLD(pxa);
+	udelay(50);
+}
+#else
+extern void pxa_ac97_warm_pxa27x(struct pxa_ac97_device *);
+extern void pxa_ac97_cold_pxa27x(struct pxa_ac97_device *);
+#endif
+
+#ifdef CONFIG_PXA3xx
+static inline void pxa_ac97_warm_pxa3xx(struct pxa_ac97_device *pxa)
+{
+	int timeout = 100;
+
+	pxa->gsr_bits = 0;
+
+	/* Can't use interrupts */
+	ac97_set_clear(pxa, GCR, GCR_WARM_RST, 0);
+	while (!(ac97_read_gsr(pxa) & (GSR_PCR | GSR_SCR)) && timeout--)
+		mdelay(1);
+}
+
+static inline void pxa_ac97_cold_pxa3xx(struct pxa_ac97_device *pxa)
+{
+	int timeout = 1000;
+
+	/* Hold CLKBPB for 100us */
+	_ac97_write(pxa, 0, GCR);
+	_ac97_write(pxa, GCR_CLKBPB, GCR);
+	udelay(100);
+	_ac97_write(pxa, 0, GCR);
+
+	pxa_ac97_assert_nCOLD(pxa);
+	udelay(2);			/* tRST_LOW */
+	pxa_ac97_deassert_nCOLD(pxa);
+
+	_ac97_write(pxa, GCR_WARM_RST | GCR_COLD_RST, GCR);
+
+	/* Can't use interrupts on PXA3xx */
+	while (!(ac97_read_gsr(pxa) & (GSR_PCR | GSR_SCR)) && timeout--)
+		mdelay(10);
+}
+#else
+extern void pxa_ac97_warm_pxa3xx(struct pxa_ac97_device *pxa);
+extern void pxa_ac97_cold_pxa3xx(struct pxa_ac97_device *pxa);
+#endif
+
+#ifdef CONFIG_CPU_PXA168
+static inline void pxa_ac97_warm_pxa168(struct pxa_ac97_device *pxa)
+{
+	pxa->gsr_bits = _ac97_read(pxa, GSR);
+	ac97_set_clear(pxa, GCR, GCR_PRIRDY_IEN|GCR_SECRDY_IEN, 0);
+
+	pxa_ac97_wait_for_gsr(pxa, GSR_PCR | GSR_SCR, HZ/100);
+}
+
+static inline void pxa_ac97_cold_pxa168(struct pxa_ac97_device *pxa)
+{
+	int timeout = 10;
+
+	pxa_ac97_assert_nCOLD(pxa);
+	ac97_set_clear(pxa, GCR, GCR_CLKBPB, 0);
+	udelay(1);
+	ac97_set_clear(pxa, GCR, 0, GCR_CLKBPB);
+
+	udelay(2);			/* tRST_LOW */
+	pxa_ac97_deassert_nCOLD(pxa);
+
+	/* Can't use interrupts on PXA3xx */
+	while (!(ac97_read_gsr(pxa) & (GSR_PCR | GSR_SCR)) && timeout--)
+		mdelay(10);
+}
+#else
+extern void pxa_ac97_warm_pxa168(struct pxa_ac97_device *pxa);
+extern void pxa_ac97_cold_pxa168(struct pxa_ac97_device *pxa);
+#endif
+
+static bool pxa_ac97_try_warm_reset(struct pxa_ac97_device *pxa)
+{
+	unsigned long		gsr;
+
+	if (cpu_is_pxa25x())
+		pxa_ac97_warm_pxa25x(pxa);
+	else if (cpu_is_pxa27x())
+		pxa_ac97_warm_pxa27x(pxa);
+	else if (cpu_is_pxa3xx())
+		pxa_ac97_warm_pxa3xx(pxa);
+	else if (cpu_is_pxa168())
+		pxa_ac97_warm_pxa168(pxa);
+	else
+		BUG();
+
+	gsr = ac97_read_gsr(pxa);
+
+	if (!(gsr & (GSR_PCR | GSR_SCR))) {
+		dev_info(pxa->dev, "warm reset timeout (GSR=%#lx)\n",
+			 gsr);
+
+		return false;
+	}
+
+	return true;
+}
+
+static bool pxa_ac97_try_cold_reset(struct pxa_ac97_device *pxa)
+{
+	unsigned long		gsr;
+
+	if (cpu_is_pxa25x())
+		pxa_ac97_cold_pxa25x(pxa);
+	else if (cpu_is_pxa27x())
+		pxa_ac97_cold_pxa27x(pxa);
+	else if (cpu_is_pxa3xx())
+		pxa_ac97_cold_pxa3xx(pxa);
+	else if (cpu_is_pxa168())
+		pxa_ac97_cold_pxa168(pxa);
+	else
+		BUG();
+
+	gsr = ac97_read_gsr(pxa);
+
+	if (!(gsr & (GSR_PCR | GSR_SCR))) {
+		dev_info(pxa->dev, "cold reset timeout (GSR=%#lx)\n",
+			 gsr);
+
+		return false;
+	}
+
+	return true;
+}
+
+static void pxa_ac97_bus_finish_reset(struct pxa_ac97_device *pxa)
+{
+	ac97_set_clear(pxa, GCR,
+		       0, GCR_PRIRDY_IEN|GCR_SECRDY_IEN);
+}
+
+static void pxa_ac97_bus_warm_reset(struct snd_ac97 *ac97)
+{
+	struct pxa_ac97_device	*pxa = to_pxa_ac97(ac97);
+
+	mutex_lock(&pxa->car_mutex);
+
+	pxa_ac97_try_warm_reset(pxa);
+	pxa_ac97_bus_finish_reset(pxa);
+
+	mutex_unlock(&pxa->car_mutex);
+}
+
+static void pxa_ac97_bus_cold_reset(struct snd_ac97 *ac97)
+{
+	struct pxa_ac97_device	*pxa = to_pxa_ac97(ac97);
+
+	mutex_lock(&pxa->car_mutex);
+
+	if (!pxa_ac97_try_cold_reset(pxa))
+		pxa_ac97_try_warm_reset(pxa);
+
+	pxa_ac97_bus_finish_reset(pxa);
+
+	mutex_unlock(&pxa->car_mutex);
+}
+
+
+struct snd_ac97_bus_ops soc_ac97_ops = {
+	.read		= pxa_ac97_bus_read,
+	.write		= pxa_ac97_bus_write,
+	.warm_reset	= pxa_ac97_bus_warm_reset,
+	.reset		= pxa_ac97_bus_cold_reset,
+};
+EXPORT_SYMBOL_GPL(soc_ac97_ops);
diff -Naur linux-3.4.11/sound/soc/pxa/pxa-ac97.c linux-HEAD/sound/soc/pxa/pxa-ac97.c
--- linux-3.4.11/sound/soc/pxa/pxa-ac97.c	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/sound/soc/pxa/pxa-ac97.c	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,564 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@sigma-chemnitz.de>
+ *
+ * Based on Nicolas Pitre's pxa2xx ac97 driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 and/or 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "pxa-ac97.h"
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+
+#include <sound/core.h>
+#include <sound/ac97_codec.h>
+#include <sound/soc.h>
+
+#include <mach/hardware.h>
+#include <mach/dma.h>
+
+#include <plat/audio.h>
+
+static struct pxa2xx_pcm_dma_params const pcm_template[] __devinitconst = {
+	[PXA_AC97_DMA_PCM_OUT] = {
+		.name		= PXA_AC97_DMA_CH_PCM_TX,
+		.dev_addr	= PCDR,
+		.drcmr		= &DRCMR(12),
+		.dcmd		= (DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				   DCMD_BURST32 | DCMD_WIDTH4),
+	},
+
+	[PXA_AC97_DMA_PCM_IN] = {
+		.name		= PXA_AC97_DMA_CH_PCM_RX,
+		.dev_addr	= PCDR,
+		.drcmr		= &DRCMR(11),
+		.dcmd		= (DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				   DCMD_BURST32 | DCMD_WIDTH4),
+	},
+
+	[PXA_AC97_DMA_AUX_MONO_OUT] = {
+		.name		= PXA_AC97_DMA_CH_PCM_MODEM_TX,
+		.dev_addr	= MODR,
+		.drcmr		= &DRCMR(10),
+		.dcmd		= (DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				   DCMD_BURST16 | DCMD_WIDTH2),
+	},
+
+	[PXA_AC97_DMA_AUX_MONO_IN] = {
+		.name		= PXA_AC97_DMA_CH_PCM_MODEM_RX,
+		.dev_addr	= MODR,
+		.drcmr		= &DRCMR(9),
+		.dcmd		= (DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				   DCMD_BURST16 | DCMD_WIDTH2),
+	},
+
+	[PXA_AC97_DMA_MIC_MONO_IN] = {
+		.name		= PXA_AC97_DMA_CH_PCM_MIC,
+		.dev_addr	= MCDR,
+		.drcmr		= &DRCMR(8),
+		.dcmd		= (DCMD_INCTRGADDR | DCMD_FLOWSRC |
+				   DCMD_BURST16 | DCMD_WIDTH2),
+	},
+
+#if PXA_AC97_HAVE_SURROUND
+	[PXA_AC97_DMA_SURROUND_TX] = {
+		.name		= PXA_AC97_DMA_CH_PCM_SURROUND_TX,
+		.dev_addr	= PCSDR,
+		.drcmr		= &DRCMR(95),
+		.dcmd		= (DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				   DCMD_BURST32 | DCMD_WIDTH4),
+	},
+
+	[PXA_AC97_DMA_CENTRE_TX] = {
+		.name		= PXA_AC97_DMA_CH_PCM_CENTRE_TX,
+		.dev_addr	= PCCLDR,
+		.drcmr		= &DRCMR(96),
+		.dcmd		= (DCMD_INCSRCADDR | DCMD_FLOWTRG |
+				   DCMD_BURST32 | DCMD_WIDTH4),
+	},
+#endif
+};
+
+static int pxa_ac97_probe(struct snd_soc_dai *dai)
+{
+	struct pxa_ac97_device		*pxa = snd_soc_dai_get_drvdata(dai);
+
+	BUG_ON(g_pxa_ac97_device != NULL);
+	g_pxa_ac97_device = pxa;
+
+	return 0;
+}
+
+static int pxa_ac97_remove(struct snd_soc_dai *dai)
+{
+	struct pxa_ac97_device		*pxa = snd_soc_dai_get_drvdata(dai);
+
+	BUG_ON(g_pxa_ac97_device != pxa);
+	g_pxa_ac97_device = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int pxa_ac97_suspend(struct snd_soc_dai *dai)
+{
+	struct pxa_ac97_device		*pxa = snd_soc_dai_get_drvdata(dai);
+
+	ac97_set_clear(pxa, GCR, GCR_ACLINK_OFF, 0);
+	clk_disable(pxa->clk);
+
+	return 0;
+}
+
+static int pxa_ac97_resume(struct snd_soc_dai *dai)
+{
+	struct pxa_ac97_device		*pxa = snd_soc_dai_get_drvdata(dai);
+
+	clk_enable(pxa->clk);
+	return 0;
+}
+
+#else
+#define pxa_ac97_suspend	NULL
+#define pxa_ac97_resume	NULL
+#endif
+
+static int pxa_ac97_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params,
+			      struct snd_soc_dai *cpu_dai)
+{
+	struct pxa_ac97_device		*pxa = snd_soc_dai_get_drvdata(cpu_dai);
+	struct pxa2xx_pcm_dma_params	*dma_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data = &pxa->dma_params[PXA_AC97_DMA_PCM_OUT];
+	else
+		dma_data = &pxa->dma_params[PXA_AC97_DMA_PCM_IN];
+
+	snd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);
+	return 0;
+}
+
+static struct snd_soc_dai_ops pxa_ac97_hifi_dai_ops = {
+	.hw_params	= pxa_ac97_hw_params,
+};
+
+static int pxa_ac97_hw_aux_params(struct snd_pcm_substream *substream,
+				  struct snd_pcm_hw_params *params,
+				  struct snd_soc_dai *cpu_dai)
+{
+	struct pxa_ac97_device		*pxa = snd_soc_dai_get_drvdata(cpu_dai);
+	struct pxa2xx_pcm_dma_params	*dma_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data = &pxa->dma_params[PXA_AC97_DMA_AUX_MONO_OUT];
+	else
+		dma_data = &pxa->dma_params[PXA_AC97_DMA_AUX_MONO_IN];
+
+	snd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);
+	return 0;
+}
+
+static struct snd_soc_dai_ops pxa_ac97_aux_dai_ops = {
+	.hw_params	= pxa_ac97_hw_aux_params,
+};
+
+static int pxa_ac97_hw_mic_params(struct snd_pcm_substream *substream,
+				  struct snd_pcm_hw_params *params,
+				  struct snd_soc_dai *cpu_dai)
+{
+	struct pxa_ac97_device		*pxa = snd_soc_dai_get_drvdata(cpu_dai);
+	struct pxa2xx_pcm_dma_params	*dma_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return -ENODEV;
+	else
+		dma_data = &pxa->dma_params[PXA_AC97_DMA_MIC_MONO_IN];
+
+	snd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);
+	return 0;
+}
+
+static struct snd_soc_dai_ops pxa_ac97_mic_dai_ops = {
+	.hw_params	= pxa_ac97_hw_mic_params,
+};
+
+#if PXA_AC97_HAVE_SURROUND
+static int pxa_ac97_hw_surround_params(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *params,
+				       struct snd_soc_dai *cpu_dai)
+{
+	struct pxa_ac97_device		*pxa = snd_soc_dai_get_drvdata(cpu_dai);
+	struct pxa2xx_pcm_dma_params	*dma_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data = &pxa->dma_params[PXA_AC97_DMA_SURROUND_TX];
+	else
+		return -ENODEV;
+
+	snd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);
+	return 0;
+}
+
+static struct snd_soc_dai_ops pxa_ac97_surround_dai_ops = {
+	.hw_params	= pxa_ac97_hw_surround_params,
+};
+
+static int pxa_ac97_hw_centre_params(struct snd_pcm_substream *substream,
+				       struct snd_pcm_hw_params *params,
+				       struct snd_soc_dai *cpu_dai)
+{
+	struct pxa_ac97_device		*pxa = snd_soc_dai_get_drvdata(cpu_dai);
+	struct pxa2xx_pcm_dma_params	*dma_data;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data = &pxa->dma_params[PXA_AC97_DMA_CENTRE_TX];
+	else
+		return -ENODEV;
+
+	snd_soc_dai_set_dma_data(cpu_dai, substream, dma_data);
+	return 0;
+}
+
+static struct snd_soc_dai_ops pxa_ac97_centre_dai_ops = {
+	.hw_params	= pxa_ac97_hw_centre_params,
+};
+#endif
+
+
+
+#define PXA2XX_AC97_RATES	SNDRV_PCM_RATE_8000_48000
+
+/*
+ * There is only 1 physical AC97 interface for pxa2xx, but it
+ * has extra fifo's that can be used for aux DACs and ADCs.
+ */
+static struct snd_soc_dai_driver pxa_ac97_dai[] = {
+	{
+		.name		= "pxa2xx-ac97",
+		.ac97_control	= 1,
+		.probe		= pxa_ac97_probe,
+		.remove		= pxa_ac97_remove,
+		.suspend	= pxa_ac97_suspend,
+		.resume		= pxa_ac97_resume,
+		.ops		= &pxa_ac97_hifi_dai_ops,
+		.playback	= {
+			.stream_name	= "AC97 Playback",
+			.channels_min	= 2,
+			.channels_max	= 2,
+			.rates		= PXA2XX_AC97_RATES,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,},
+		.capture = {
+			.stream_name	= "AC97 Capture",
+			.channels_min	= 2,
+			.channels_max	= 2,
+			.rates		= PXA2XX_AC97_RATES,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,},
+	}, {
+		.name		= "pxa2xx-ac97-aux",
+		.ac97_control	= 1,
+		.ops		= &pxa_ac97_aux_dai_ops,
+		.playback	= {
+			.stream_name	= "AC97 Aux Playback",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= PXA2XX_AC97_RATES,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,},
+		.capture	= {
+			.stream_name	= "AC97 Aux Capture",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= PXA2XX_AC97_RATES,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,},
+	}, {
+		.name		= "pxa2xx-ac97-mic",
+		.ac97_control	= 1,
+		.ops		= &pxa_ac97_mic_dai_ops,
+		.capture	= {
+			.stream_name	= "AC97 Mic Capture",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= PXA2XX_AC97_RATES,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+	},
+#if PXA_AC97_HAVE_SURROUND
+	{
+		.name		= "pxa2xx-ac97-surround",
+		.ac97_control	= 1,
+		.ops		= &pxa_ac97_surround_dai_ops,
+		.playback	= {
+			.stream_name	= "Surround Playback",
+			.channels_min	= 2,
+			.channels_max	= 2,
+			.rates		= PXA2XX_AC97_RATES,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+	}, {
+		.name		= "pxa2xx-ac97-centre",
+		.ac97_control	= 1,
+		.ops		= &pxa_ac97_centre_dai_ops,
+		.playback	= {
+			.stream_name	= "Center Playback",
+			.channels_min	= 2,
+			.channels_max	= 2,
+			.rates		= PXA2XX_AC97_RATES,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+	},
+#endif
+};
+
+static irqreturn_t pxa_ac97_irq(int irq, void *dev_id)
+{
+	struct pxa_ac97_device	*pxa = dev_id;
+	unsigned long		status;
+
+	status = _ac97_read(pxa, GSR);
+
+	if (status) {
+		_ac97_write(pxa, status, GSR);
+		pxa->gsr_bits |= status;
+		wake_up(&pxa->gsr_wq);
+
+		/* Although we don't use those we still need to clear them
+		   since they tend to spuriously trigger when MMC is used
+		   (hardware bug? go figure)... */
+		if (cpu_is_pxa27x()) {
+			_ac97_write(pxa, MISR_EOC,   MISR);
+			_ac97_write(pxa, PCMISR_EOC, PCMISR);
+			_ac97_write(pxa, MCSR_EOC,   MCSR);
+		}
+
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static __devinit int pxa_ac97_hw_probe(struct platform_device *pdev,
+				       struct pxa_ac97_device *pxa_ac97)
+{
+	int		rc;
+	bool		have_clk = false;
+	struct resource	*res_mem;
+	struct resource	*res_irq;
+
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+
+	if (res_mem == NULL || res_irq == NULL) {
+		dev_err(&pdev->dev, "Insufficient resource specification\n");
+		return -EINVAL;
+	}
+
+	pxa_ac97->res_mem = request_mem_region(res_mem->start,
+					       resource_size(res_mem),
+					       "PXA AC97");
+	if (pxa_ac97->res_mem == NULL) {
+		dev_err(&pdev->dev, "Failed to request mem region\n");
+		rc = -EBUSY;
+		goto err;
+	}
+
+	pxa_ac97->io = ioremap(res_mem->start, resource_size(res_mem));
+	if (pxa_ac97->io == NULL) {
+		dev_err(&pdev->dev, "Failed to map mem region\n");
+		rc = -ENOMEM;
+		goto err;
+	}
+
+	if (cpu_is_pxa27x()) {
+		/* Use GPIO 113 as AC97 Reset on Bulverde */
+		pxa27x_assert_ac97reset(pxa_ac97->reset_gpio, 0);
+
+		pxa_ac97->conf_clk = clk_get(pxa_ac97->dev, "AC97CONFCLK");
+		if (IS_ERR(pxa_ac97->conf_clk)) {
+			rc = PTR_ERR(pxa_ac97->conf_clk);
+			pxa_ac97->conf_clk = NULL;
+			goto err;
+		}
+	}
+
+	pxa_ac97->clk = clk_get(pxa_ac97->dev, "AC97CLK");
+	if (IS_ERR(pxa_ac97->clk)) {
+		dev_err(pxa_ac97->dev, "clk_get() failed\n");
+		rc = PTR_ERR(pxa_ac97->clk);
+		pxa_ac97->clk = NULL;
+		goto err;
+	}
+
+	rc = clk_enable(pxa_ac97->clk);
+	if (rc) {
+		dev_err(pxa_ac97->dev, "clk_enable() failed\n");
+		goto err;
+	}
+
+	have_clk = true;
+
+	rc = request_irq(res_irq->start, pxa_ac97_irq, IRQF_DISABLED,
+			 "AC97", pxa_ac97);
+	if (rc < 0) {
+		dev_err(pxa_ac97->dev, "request_irq(%d) failed\n",
+			res_irq->start);
+		goto err;
+	}
+
+	pxa_ac97->irq = res_irq->start;
+	return 0;
+
+err:
+	if (have_clk) {
+		ac97_set_clear(pxa_ac97, GCR, GCR_ACLINK_OFF, 0);
+		clk_disable(pxa_ac97->clk);
+	}
+
+	if (pxa_ac97->clk)
+		clk_put(pxa_ac97->clk);
+
+	if (pxa_ac97->io)
+		iounmap(pxa_ac97->io);
+
+	if (pxa_ac97->res_mem)
+		release_mem_region(pxa_ac97->res_mem->start,
+				   resource_size(pxa_ac97->res_mem));
+
+	return rc;
+}
+
+static void pxa_ac97_hw_free(struct pxa_ac97_device *pxa_ac97)
+{
+	free_irq(pxa_ac97->irq, pxa_ac97);
+	ac97_set_clear(pxa_ac97, GCR, GCR_ACLINK_OFF, 0);
+	clk_disable(pxa_ac97->clk);
+	clk_put(pxa_ac97->clk);
+	iounmap(pxa_ac97->io);
+	release_mem_region(pxa_ac97->res_mem->start,
+			   resource_size(pxa_ac97->res_mem));
+}
+
+static __devinit int pxa_ac97_dev_probe(struct platform_device *pdev)
+{
+	struct pxa_ac97_device	*pxa;
+	size_t			i;
+	pxa2xx_audio_ops_t	*pdata = pdev->dev.platform_data;
+	int			rc;
+
+	pxa = kzalloc(sizeof *pxa, GFP_KERNEL);
+	if (!pxa)
+		return -ENOMEM;
+
+	pxa->dev = &pdev->dev;
+
+	if (cpu_is_pxa27x())
+		pxa->reset_gpio = 113;
+	else
+		pxa->reset_gpio = -1;
+
+	mutex_init(&pxa->car_mutex);
+	init_waitqueue_head(&pxa->gsr_wq);
+
+	if (pdata) {
+		pxa->platform_priv = pdata->priv;
+		pxa->reset_codec   = pdata->reset_codec;
+
+		if (cpu_is_pxa27x() && pdata->reset_gpio)
+			pxa->reset_gpio = pdata->reset_gpio;
+	}
+
+	rc = pxa_ac97_hw_probe(pdev, pxa);
+	if (rc < 0)
+		goto err;
+
+	for (i = 0; i < ARRAY_SIZE(pcm_template); ++i) {
+		struct resource	*res;
+
+		pxa->dma_params[i] = pcm_template[i];
+		pxa->dma_params[i].dev_addr += pxa->res_mem->start;
+
+		res = platform_get_resource_byname(pdev, IORESOURCE_DMA,
+						   pcm_template[i].name);
+		if (unlikely(!res))
+			dev_warn(&pdev->dev,
+				 "Missing DMA resource specification for \"%s\"; assuming legacy value\n",
+				 pcm_template[i].name);
+		else
+			pxa->dma_params[i].drcmr = &DRCMR(res->start);
+
+		dev_dbg(&pdev->dev,
+			"DMA#%zu addr=%08x, drcmr=%p(%d) dcmd=%08x name='%s'\n",
+			i,
+			pxa->dma_params[i].dev_addr,
+			pxa->dma_params[i].drcmr,
+			res ? res->start : -1,
+			pxa->dma_params[i].dcmd,
+			pxa->dma_params[i].name);
+	}
+
+	platform_set_drvdata(pdev, pxa);
+	rc = snd_soc_register_dais(&pdev->dev, pxa_ac97_dai,
+				   ARRAY_SIZE(pxa_ac97_dai));
+
+	if (rc < 0) {
+		pxa_ac97_hw_free(pxa);
+		goto err;
+	}
+
+	return 0;
+
+err:
+	kfree(pxa);
+	return rc;
+}
+
+static int __devexit pxa_ac97_dev_remove(struct platform_device *pdev)
+{
+	struct pxa_ac97_device	*pxa = platform_get_drvdata(pdev);
+
+	snd_soc_unregister_dais(&pdev->dev, ARRAY_SIZE(pxa_ac97_dai));
+	pxa_ac97_hw_free(pxa);
+	kfree(pxa);
+
+	return 0;
+}
+
+static struct platform_driver pxa_ac97_driver = {
+	.probe		= pxa_ac97_dev_probe,
+	.remove		= __devexit_p(pxa_ac97_dev_remove),
+	.driver		= {
+		.name	= "pxa2xx-ac97",
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+//		.pm	= &pxa_ac97_pm_ops,
+#endif
+	},
+};
+
+static int __init pxa_ac97_init(void)
+{
+	return platform_driver_register(&pxa_ac97_driver);
+}
+module_init(pxa_ac97_init);
+
+static void __exit pxa_ac97_exit(void)
+{
+	platform_driver_unregister(&pxa_ac97_driver);
+}
+module_exit(pxa_ac97_exit);
+
+MODULE_AUTHOR("Enrico Scholz");
+MODULE_DESCRIPTION("AC97 driver for the Marvell PXA family");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:pxa2xx-ac97");
diff -Naur linux-3.4.11/sound/soc/pxa/pxa-ac97.h linux-HEAD/sound/soc/pxa/pxa-ac97.h
--- linux-3.4.11/sound/soc/pxa/pxa-ac97.h	1970-01-01 00:00:00.000000000 +0000
+++ linux-HEAD/sound/soc/pxa/pxa-ac97.h	2015-11-18 09:04:24.000000000 +0000
@@ -0,0 +1,124 @@
+/*	--*- c -*--
+ * Copyright (C) 2011 Enrico Scholz <enrico.scholz@informatik.tu-chemnitz.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef H_LINUX_SOUND_SOC_PXA_PXA_AC97_H
+#define H_LINUX_SOUND_SOC_PXA_PXA_AC97_H
+
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/resource.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+
+#include <sound/pxa2xx-lib.h>
+
+#include <plat/ac97.h>
+
+#include <mach/hardware.h>
+
+#ifdef CONFIG_ARCH_MMP
+#  include <mach/cputype.h>
+#endif
+
+
+#ifndef CONFIG_ARCH_PXA
+#  define cpu_is_pxa25x()	(0)
+#  define cpu_is_pxa27x()	(0)
+#  define cpu_is_pxa3xx()	(0)
+#endif
+
+#ifndef CONFIG_ARCH_MMP
+#  define cpu_is_pxa168()	(0)
+#endif
+
+#if defined(CONFIG_PXA3xx) || defined(CONFIG_CPU_PXA168)
+#  define PXA_AC97_HAVE_SURROUND	1
+#else
+#  define PXA_AC97_HAVE_SURROUND	0
+#endif
+
+enum {
+	PXA_AC97_DMA_PCM_OUT,
+	PXA_AC97_DMA_PCM_IN,
+	PXA_AC97_DMA_AUX_MONO_OUT,
+	PXA_AC97_DMA_AUX_MONO_IN,
+	PXA_AC97_DMA_MIC_MONO_IN,
+
+#if PXA_AC97_HAVE_SURROUND
+	PXA_AC97_DMA_SURROUND_TX,
+	PXA_AC97_DMA_CENTRE_TX,
+#endif
+
+	PXA_AC97_DMA_MAX,
+};
+
+struct pxa_ac97_device {
+	struct device		*dev;
+	struct resource		*res_mem;
+	int			irq;
+	void __iomem		*io;
+
+	struct clk		*clk;
+
+	struct mutex		car_mutex;
+	wait_queue_head_t	gsr_wq;
+	long volatile		gsr_bits;
+
+	/* PXA27x only */
+	struct clk		*conf_clk;
+	int			reset_gpio;
+
+	void			(*reset_codec)(void *, int);
+	void			*platform_priv;
+
+	struct pxa2xx_pcm_dma_params	dma_params[PXA_AC97_DMA_MAX];
+};
+
+extern struct pxa_ac97_device	*g_pxa_ac97_device;
+
+inline static unsigned long _ac97_read(struct pxa_ac97_device const *pxa_ac97,
+				       uintptr_t addr)
+{
+	return __raw_readl(pxa_ac97->io + addr);
+}
+
+inline static void _ac97_write(struct pxa_ac97_device const *pxa_ac97,
+			       uint32_t v, uintptr_t addr)
+{
+	__raw_writel(v, pxa_ac97->io + addr);
+}
+
+inline static void ac97_set_clear(struct pxa_ac97_device const *pxa_ac97,
+				  uintptr_t addr, uint32_t v, uint32_t m)
+{
+	uint32_t	tmp = __raw_readl(pxa_ac97->io + addr);
+
+	tmp &= ~m;
+	tmp |=  v;
+
+	__raw_writel(tmp, pxa_ac97->io + addr);
+}
+
+inline static unsigned long ac97_read_gsr(struct pxa_ac97_device const *pxa_ac97)
+{
+	return _ac97_read(pxa_ac97, GSR) | pxa_ac97->gsr_bits;
+}
+
+extern void pxa27x_assert_ac97reset(int reset_gpio, int on);
+
+#endif	/* H_LINUX_SOUND_SOC_PXA_PXA_AC97_H */
diff -Naur linux-3.4.11/sound/soc/soc-core.c linux-HEAD/sound/soc/soc-core.c
--- linux-3.4.11/sound/soc/soc-core.c	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/sound/soc/soc-core.c	2015-11-18 09:04:24.000000000 +0000
@@ -1851,6 +1851,7 @@
 		return -ENOMEM;
 	}
 
+	codec->ac97->bus->card = codec->card->snd_card;
 	codec->ac97->bus->ops = ops;
 	codec->ac97->num = num;
 
diff -Naur linux-3.4.11/tools/perf/Makefile linux-HEAD/tools/perf/Makefile
--- linux-3.4.11/tools/perf/Makefile	2012-09-14 22:18:55.000000000 +0000
+++ linux-HEAD/tools/perf/Makefile	2015-11-18 09:04:24.000000000 +0000
@@ -504,7 +504,6 @@
 		BASIC_CFLAGS += -DNO_NEWT_SUPPORT
 	else
 		# Fedora has /usr/include/slang/slang.h, but ubuntu /usr/include/slang.h
-		BASIC_CFLAGS += -I/usr/include/slang
 		EXTLIBS += -lnewt -lslang
 		LIB_OBJS += $(OUTPUT)util/ui/setup.o
 		LIB_OBJS += $(OUTPUT)util/ui/browser.o
